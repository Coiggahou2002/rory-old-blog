{"pages":[{"title":"About Me","text":"个人介绍 123456789101112131415161718192021222324252627public class cjpark { public class College_Student { String name; int age; String college; String major; boolean isAlive; boolean isSingleDog; public void Study(); public void GoForward(); public void ChaseYourDream(); } public static void main (String[] args) { College_Student cj = new College_Student(); cj.name = &quot;蔡嘉豪&quot;; cj.age = 18; cj.college = &quot;HITSZ&quot;; cj.major = &quot;Computer Science&quot;; cj.isAlive = true; cj.isSingleDog = true; while (cj.IsAlive()) { cj.Study(); cj.GoForward(); cj.ChaseYourDream(); } }}","link":"/cjpark/about/index.html"},{"title":"","text":".navbar .nav-item .nav-link:hover { color: #ffffff; } /* #navbar { background-color: #6C60C8; } */ /* a:hover{ color: #A62FFF; } */","link":"/cjpark/css/custom.css"}],"posts":[{"title":"Anki×生物-记忆方法和经验分享","text":"主题概览 Anki的简要介绍 我是如何了解到Anki的 高三后期Anki的使用体验及效果 Anki给我带来的思考和启发 前言 说来惭愧。 笔者本来计划高考后的暑假集中精力写一系列文章来分享高考的应试经验和收获，当作是将自己三年的一些经验进行简单的总结和输出，能够分享出来供大家参考。但因暑假非常非常忙，跟同学一起搞一波小创业的同时还要兼顾家里的琐事，实在抽不出时间。大一入学一个月来更是各种头秃（真·高四），今天总算在学习之余能抽空写一篇文章，分享笔者高三后期使用Anki记忆生物知识的经历。 引入 你是否有过这样的经历？ 每完成一章学习之后，将知识集中梳理到笔记本上 做了详细全面的总结，还加入了个人的理解和思考 甚至还整理了知识大纲或者思维导图… 但是只有快到期末的时候才会翻开复习 而且翻开后发现都忘差不多了。。。 如果您有这样的习惯，笔者强烈推荐您尝试一下Anki~ 今年疫情期间，笔者宅在家里复习备考，时间比较充裕，于是按照【植物】和【动物】两个专题将整个高中知识从不同的切入点重构了一遍，在幕布整理成大纲后，还将相关的经验分享到了知乎（文末附链接）。 但笔者后来发现，知识“主题式”、“脉络式”的梳理工作固然重要（我将其理解为类似于梳理重构记忆神经回路的过程，这对形成知识体系很有帮助），但当我们面对联系松散的、碎片化的记忆内容时，这种方式是不太适用的。 简单来讲，我们需要搞清楚的问题是——我想要训练的，是对知识体系脉络的熟悉感和掌控感，还是对各种碎片化知识的迅速反应？ 举个例子，当你需要构建《生物必修三》的【生态系统】章节的整体框架和知识结构时，你需要的是上述中的前者——利用一切你能利用的大纲、思维导图、手写框图等【结构化整理工具】来整理和重构你的记忆网络；当你需要将《生物选修一》中的各种制果酒果醋酸菜腐乳的步骤细节记得滚瓜烂熟形成肌肉记忆时，你需要的是上述中的后者——训练自己对特定关键词的迅速反应能力。 今天笔者想要介绍的Anki就是上文提到的“训练快速反应”的非常理想的一款工具。 什么是Anki 广义上来讲，Anki是一种记忆方法。 大家应该都了解过所谓的“艾宾浩斯遗忘曲线”，笔者在此不再赘述——简单来讲，其想要传达的核心思想就是：要想建立牢固的记忆，必须依靠“间隔重复”的方法，按一定的周期定期回顾复习，不断提醒大脑巩固记忆。 Anki便是一种将“间隔重复”和“遗忘曲线”理论付诸实践的方法。它的基本记忆模块叫“记忆卡片”，一定数目的关系比较密切的、属于同一目录的卡片组成“记忆牌组”，使用者需要每天学习一定数目的卡片，同时复习之前已经学习过的卡片，系统会根据用户对卡片的熟悉程度，自动安排每张卡片在之后每一天的复习间隔和出现次数——这样以来，使用者不需要将精力分散在安排复习计划上（毕竟这是一件让人非常头疼的事情），只需要每天在黄金记忆时间（起床后与睡前）或碎片时间打开App进行卡片的复习和学习即可，以达到“在不知不觉间”牢固记忆的目的。 现在市面上有不同基于Anki的电脑客户端和App，文末会附上传送门，方便大家作进一步的了解，本文的焦点主要还是集中在Anki的思想方法和简单应用。 我是如何了解到Anki的 说来也巧，今年疫情在家备考时，经常上知乎写一些与数学、生物相关的文章，既是利用输出的方式来巩固已有知识，也当作是极度紧张焦虑时期的一种自我缓冲和放松的方式。 但说不焦虑是假的，在当时笔者学校进行的各种线上测试中，笔者成绩起伏不定，内心非常焦虑，各种知识点看了又忘，答题手感差，记忆也不流畅，经常半夜因为焦虑而睡不着觉。 就在某天凌晨2点，笔者在知乎刷到了叶峻峣写的有关Anki的文章，当时看了非常激动——笔者终于有机会可以借助软件工具来改正自己的不良的复习习惯了。当时笔者在黑夜中从床上蹦起来，坐在书桌前一边阅览Anki专栏的相关文章，一边思索着如何将自己需要将哪些知识放到Anki中复习、以及如何将要记忆的知识用卡片的形式组织起来… 完成了初步计划之后，抬头一看已经凌晨4点半，当时距离高考还有3个月多一些，但笔者在两个多月的黑暗孤独的备考以来，第一次在窗外依稀的光亮中看到了希望。 Anki的使用体验和效果 先说效果： 想必全国卷地区的在读高三生或者高考过来人都知道，《生物必修三》《生物选修一》《生物选修三》这三本课本中，有大量需要背诵的碎片知识，尤其是后两本书的各种碎片化知识更是几乎毫无联系，但偏偏理综就爱考上述内容的默写题。笔者在离高考剩下3个月左右的时间开始使用Anki，在不算长的时间内，成功做到了对对上述三本教材中几乎所有默写题滚瓜烂熟、秒问秒答的程度。 当初在手机上下载Anki的App之后，笔者每天抽1小时左右仔细阅读生物教材，将每个所有可能以【问答/默写题】形式考察的知识点，都制成了Anki卡片。 BTW，当时笔者在家里实在静不下心来学习，于是每天都会去社区图书馆，是的你没看错，所有Anki卡片的学习和复习都是在我走路往返图书馆的路上完成的！ 只要你每天肯割舍那么一点点走路听歌的时间，日积月累就会达到惊人的效果，这就是科学的“间隔重复”记忆方法的力量！ 备注：除了背诵生物文字默写题以外，笔者在平时订正理综试卷时，也会将一些易错点以【短语/短句】的形式概括制成卡片来反复提醒自己，亲测这种方法比所谓的错题本要有效得多~ 最后笔者高考的成绩虽说没能特别理想，差一步踏进北航，但也算是没有什么遗憾了。即便最后看不到生物成绩，难以量化评估Anki的使用效果，但至少在高三的后期阶段，Anki作为一项提高效率的记忆工具，极大地增强了笔者的应试信心（算是有一种模糊的精神寄托？），这也算是很重要的一项收获。 思考和启发 说了这么多有关Anki的具体原理和使用体验，笔者还认为，我们更应该从“使用Anki得到的良好效果”来反向思考一个问题——那就是合适的工具和方法之于提升学习效率的重要性。 从小到大，我们都被长辈灌输一种“个人努力胜于一切”的观念，以至于我们在成长过程中、在学习生活中，都或多或少地过分强调了“个人主观能动性”，认为只要拼命努力就可以做好一切事情，反倒忽视了工具、方法在提高效率方面不可替代的重要性。 在做一件事情之前，笔者认为需要先准备好以下几点： （尽量避免过多的理论，只给出具体的例子） 1.信息 信息优势帮助你走向正确的决策和路线 如果你在高一就清楚地了解到高三的考察重点和高压氛围，你是不是可以从高一就开始认真审阅生物课本、背诵重点句，而不是到高三才意识到这些内容的重要性？你是不是可以从高一就开始坚持晨跑，提前准备好强健的体魄以应对高强度的竞争，而不是在高三后期每天累成狗之后还要坚持下操场练体能？… 2.资源 资源优势使你避开弯路并加快你进步的速度 如果你在高一阶段就向有经验的学长学姐去了解【圆锥曲线】模块的经典书籍和学习路线，你是不是可以避免在鱼龙混杂的教辅市场东摸西找、最后还将时间浪费在了一本质量堪忧的教辅书上、建立了错误的思维模式？如果你在高一阶段就设法了解过某个学科的优秀网课资源，是不是可以避免受教学水平较差的老师的错误引导导致学习痛苦不堪（我是说如果）？… 3.工具 工具提高你的学习效率 如果你提前了解过Anki这款高效的记忆工具，你是不是可以在高中三年的学习中积累大量的卡片和知识、让自己复习的效率数倍于他人？如果你提前了解过各种数学绘图软件，你是不是在学习导数的时候对各种动态参数变化问题能有更直观的理解和体会？ 4.决心 这反而是最次要的 确定自己的学习路线并坚定地执行有多重要，想必不需要我过多地叙述了。 以上都是我的切身体会，笔者只想强调一点，那就是：在开始做一件事情之前，你在上述四个方面所花时间的价值，远远高于后续坚持努力的时间价值。 当然，努力也很重要，我们要用最高效的方法，付出不亚于他人的努力。","link":"/cjpark/2020/10/26/Anki_Biology/"},{"title":"笔记 | 计算机网络基础","text":"Description: 本文为笔者的计网复习笔记 📕 前置知识 比特与字节 比特 (bit)：也叫位，每个比特的值为 0 或 1 字节 (byte)：即平常说的 1kB 中的 B，一个字节等于 8 比特 1 byte=8 bits1 \\ byte = 8 \\ bits 1 byte=8 bits 关于传输速率 1 kbps=1000 bits/s1 \\,kbps = 1000 \\,bits /s 1kbps=1000bits/s 1 kBps=1000 bytes/s1 \\,kBps = 1000 \\,bytes/s 1kBps=1000bytes/s 1 kB/s=8 kb/s1\\,kB/s = 8\\,kb/s 1kB/s=8kb/s kbps 表示每秒能够传输多少千个比特。 kBps 则表示每秒能够传输多少千个字节。 🔍 常见专业英文术语 缩写 详写 翻译 备注 LAN Local Area Network 局域网 WAN Wide Area Network 广域网 WWW World Wide Web 万维网 internet 网际网 将多个网络连接构成更大的网络 The Internet 互联网 互联全世界的计算机网络 ISP Internet Service Provider 互联网服务提供商 URL Uniform Resource Locator 统一资源定位器 MAC Media Access Control Address MAC地址 一个网卡一个MAC地址 DNS Domain Name System 域名管理系统 相当于电话簿，根据域名查询IP地址 ADSL Asymmetric Digital Subscriber Line 非对称数字用户环路 TCP/IP 利用IP进行通信时所必须用到的协议群的总称 IP Internet Protocol 网际协议 根据IP地址把数据送给正确的计算机 UDP User Datagram Protocol 用户数据报协议 根据端口号把数据送给正确的程序 TCP Tramisson Control Protocol 传输控制协议 所有数据必须到达。可处理乱序、丢包问题并自动检测网络拥堵程度，实时调整发包频次 OSI Open System Interconnection model 开放式系统互联通信参考模型 Physical Layer 物理层 Data Link Layer 数据链路层 Network Layer 网络层 Transport Layer 传输层 Session Layer 会话层 Presentation Layer 表示层 Application Layer 应用程序层 HTTP Hyper Text Transfer Protocol 超文本传输协议 HTML Hyper Text Markup Language 超文本标记语言 CSS Cascading Style Sheet 层叠样式表 FTP File Transfer Protocol 文件传输协议 SMTP Simple Mail Transfer Protocol 邮件传输协议 POP3 Post Office Protocol - Version 3 邮件传输协议 IMAP Internet Message Access Protocol 邮件传输协议 MIME Multipurpose Internet Mail Extension 邮件传输协议 Router 路由器 找出最高效的传输线路 🔖 常见概念 节点和主机 概念 描述 主机 配有 IP 地址但不进行路由控制的设备 路由器 既配有 IP 地址又具备路由控制能力的设备 节点是主机和路由器的总称 信源、信道和信宿 信源：信息发送者 信道：传送信息的媒体 信宿：信息的接收者 网络拓扑 网络拓扑指的是网络的连接形态 总线型 环型 星型 网状型 分组交换 将不同大小的信息按统一的大小拆分，加上辅助信息（如发送地址）后，重新封装成数据包来传输（可以混合次序传输） 调制解调器 Modem 调制(Modulation) 在计算机信息传输进电话线路之前，将数字信号转换为模拟信号 解调(Demodulation) 将经由电话线路传来的模拟信号转换为数字信号，再给计算机处理 其实就是我们平常所说的“猫” 路由器 Router 可以连接不同环境的局域网和广域网，还能选出两个网络节点之间最近、最快的传输路径。 相当于在各种范围的网络之间进行跳转的“中间人” 统一资源定位器 URL 统一格式 1协议://主机名.域名.顶级域名/路径/文件名.扩展名 常见协议类型 协议 含义 http:// HTML文件 https:// 加密的HTML文件 ftp:// 文件服务器、文件传输 file:// 本地文件 🌎 不同范围的网络 局域网 LAN 有限地理范围内（几千米） 传输速度快 常见类型 以太网 Ethernet 令牌环网 Token Ring 令牌总线网 Token Bus 无线局域网 Wi-Fi Bluetooth 广域网 WAN 相比局域网，时延更大 需要借助公共电信系统 常见广域网 PSTN (Public Switch Telephone Network) DDN 专线 (Digital Data Network) ISDN (Integrated Service Digital Network) ADSL (Asymmetric Digital Subscriber Line) 无线广域网 3G 网络 CDMA 2000 WCDMA TD-SCDMA 4G 网络 LTE HSPA+ WiMax 互联网（网际网） internet 将若干个局域网、广域网之间通过路由器互联，形成网际网 因特网 The Internet 是世界上最大的互联网，是由广域网连接的局域网的最大集合 📜 几种协议的解释 TCP 协议 数据包 (Packets) 有自己的序号，到达目的地后可排序并重新组合 要求接收方收到数据并确认无误后，发回确认码 (ACK) 根据确认码发回的成功率和来回时间，推断网络的拥挤程度，自动调整发包频次 HTTP 协议 属于 OSI 模型中应用层的协议 HTML 协议 属于 OSI 模型中表示层的协议 文件传输协议 即指 FTP 协议，传输时可以选择二进制或文本方式进行传输 FTP 是 OSI 应用层，不是传输层 邮件传输协议 SMTP 协议 (Simple Mail Transfer Protocol) POP3 协议 (Post Office Protocol - Version 3) IMAP 协议 (Internet Message Access Protocol) MIME 协议 (Multipurpose Internet Mail Extension) 以上协议都属于 OSI 模型中的应用层 🍔 TCP/IP 分层模型 一、物理层 负责机电信号的传输与控制 二、数据链路层 概述 传输数据帧 属于接口层，类似于“驱动程序”的功能 以太网 PPP 即 Point-to-Point Protocol，点对点连接计算机的协议 三、网络层 概述 负责解析信息的源和目标地址。 该层主要由 IP 协议和 ICMP 协议组成。 IP 协议 IP 协议根据 IP 地址将分组数据包发送到目的主机。 虽然 IP 也是分组交换的一种协议，但它不具有重发机制，属于非可靠性传输协议。 路由控制 Routing 与数据链路层的关系 数据链路层就像机票/火车票，只负责某个区间的通信传输，而网络层就像旅行日程表，起到引导全程的作用。 四、传输层 该层最主要的功能是让应用程序之间实现通信。 如何识别特定的应用程序？靠的是端口号。 该层代表性的协议有： UDP 不会关注接收端是否真的收到了数据 TCP 保证两端主机之间通信可达 能够处理丢包、乱序的情况 能有效利用带宽、缓解网络拥堵 五、应用层 TCP/IP 应用的架构绝大多数属于客户端/服务端模型 (Client / Server model) 客户端发送请求给服务端，服务端接受请求并发回数据包 🎈访问一个网站的全过程 Step 1. 在浏览器地址栏键入网址并按回车 例如输入了: http://drive.google.com/folder/file.txt 浏览器首先解析你输入的 URL 地址，第一步解析协议，发现是 http 协议，需要传输 HTML 文件. 下一步，浏览器拿着域名去询问 DNS 服务器，找到这个网址对应的 IP 地址（Google Drive 的服务器 IP 地址） 你的电脑和 Google Drive 的服务器建立 TCP 连接，向服务器发送请求，申请主机目录下 /folder/file.txt 文件的访问权限. 服务器端审核通过后，将文件传输到你的个人电脑上","link":"/cjpark/2020/12/05/computer_network/"},{"title":"算法 | 二分查找","text":"本文整理 LeetCode 上二分查找的相关题型。 基本知识 时间复杂度：O(logn)O(logn)O(logn) 空间复杂度：O(1)O(1)O(1) 递归实现 12345678public static int rank(int key, int[] a, int lo, int hi){ if (lo &gt; hi) return -1; int mid = lo + (hi-lo) / 2; if (key &lt; a[mid]) return rank(key, a, lo, mid-1); else if (key &gt; a[mid]) return rank(key, a, mid, hi); else return mid;} 非递归实现 1234567891011121314151617public static int BinarySearch(int[] nums, int target){ if (nums == NULL || nums.length == 0) return -1; int left = 0; int right = nums.length - 1; //要减1，搜索区间左闭右闭 while (left &lt;= right) { //小于等于 int mid = left + (right-left) / 2; //防溢出 if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid - 1; } else if (nums[mid] == target) { return mid; } } return -1;} 常见注意事项 是否需要保证搜索区间大于某个长度？（在 while 处修改循环条件） LeetCode相关题目 一、模板题 No.704 二分查找 No.374 猜数字大小 No.35 搜索插入位置 No.278 第一个错误版本 No.275 H指数 II 二、数列求和问题 No.367 有效的完全平方数 No.69 x的平方根 No.441 排列硬币 三、查找重复数的左右边界 No.34 在排序数组中查找元素的第一个和最后一个位置（Medium） 整体思路 二分查找整体框架不变，主要改动在于找到 target 之后的操作。 mid 命中目标之后，从目标位置出发，向左右扩展（最多扩展至 left 和 right ），分别用 l_bound 和 r_bound 表示扩展器的左、右边界，最后返回 l_bound 和 r_bound 即可。 注意细节 l_bound 和 r_bound 最后会多移动一步，需要增加一个判断，判断边界是否计入。 一定要小心边界是否取等，目的是防止数组访问越界。 代码实现 123456789101112131415161718192021222324252627282930313233class Solution { public int[] searchRange(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid; int l_bound; int r_bound; int[] result = new int[2]; while (left &lt;= right) { mid = left + (right - left) / 2; if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; else if (nums[mid] == target) { l_bound = mid; r_bound = mid; while (nums[l_bound] == target &amp;&amp; l_bound &gt; left) { l_bound--; } if (nums[l_bound] != target) l_bound++; //边界检查 while (nums[r_bound] == target &amp;&amp; r_bound &lt; right) { r_bound++; } if (nums[r_bound] != target) r_bound--; //边界检查 result[0] = l_bound; result[1] = r_bound; return result; } } result[0] = -1; result[1] = -1; return result; }} 四、与奇偶有关的二分 No.540 有序数组中的单一元素 思路分析 整体框架依然是二分查找。 每次检查 nums[mid] 与它左侧或右侧的元素是否相同，去除掉这对相同元素后，分别计算左、右两侧剩余数字的个数——如果是偶数，说明里面的数都是成对的；如果是奇数，说明我们要找的“落单数”就在里面。 然后我们将搜索区间转移到奇数侧，继续搜索。 由于操作时用到了 nums[mid-1] 与 nums[mid+1] ，所以为了防止数组访问越界，我们需要保证当前搜索区间的长度大于等于3，所以 while 处的循环条件需要稍微改一下。 最后 while 循环完成后，判断一下剩下的区间长度是1还是3（不可能是2），然后分别做出相应的处理即可。 代码实现 1234567891011121314151617181920212223242526272829303132class Solution { public int singleNonDuplicate(int[] nums) { if (nums.length == 1) return nums[0]; int left = 0; int right = nums.length - 1; int mid; while (right - left &gt; 2) { mid = left + (right - left) / 2; if (nums[mid] == nums[mid-1]) { if ((mid+1) % 2 == 1) { //奇数个 right = mid - 2; } else { //偶数个，不在这 left = mid + 1; } } else if (nums[mid] == nums[mid+1]){ if ((mid+2) % 2 == 1) { right = mid - 1; } else { left = mid + 2; } } else { return nums[mid]; } } if (right - left == 0) return nums[left]; if (right - left == 2) { if (nums[left] == nums[left+1]) return nums[right]; if (nums[right] == nums[right-1]) return nums[left]; } return 0; }} 五、与动态规划结合 待补充 六、与树相关的问题 面试题 04.02 最小高度树 给定一个有序数组 nums[] ，要求构建一棵高度最小的二叉树。 树的高度要尽可能小，意味着两边的数据分布尽可能均匀，可以构建二叉搜索树。 任何一棵子树，父节点的值必大于左儿子，且小于右儿子。 可以利用二分法构建，给定一个序列，选取 mid 作为根节点，由 mid 左边的子序列构建左子树，由 mid 右边的子序列构建右子树，如此递归。当序列左右边界错位（序列为空）时，递归出口，返回 null 。 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } public TreeNode helper (int[] num, int left, int right) { /*递归出口*/ if (right &lt; left) return null; int mid = left + (right - left) / 2; TreeNode root = new TreeNode(num[mid]); root.left = helper(num,left,mid-1); root.right = helper(num,mid+1,right); return root; }}","link":"/cjpark/2020/11/19/binary_search/"},{"title":"买卖股票的最佳时机 I","text":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解法 暴力扫描 使用双重嵌套循环，外层循环从头到尾遍历 prices[]，内层循环遍历从 prices[i] 到 prices[len-1]，寻找位于 i 之后的 j 使得 prices[j] 与 prices[i] 差值最大。 时间复杂度 O(n2)O(n^2)O(n2) ，扫描次数为 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 次，不使用额外空间。 12345678910111213141516171819202122232425262728293031class Solution { public int maxProfit(int[] prices) { /*Special Judge*/ if (prices.length == 0 || prices.length == 1) return 0; if (prices.length == 2) { if (prices[1] - prices[0] &gt; 0) { return prices[1] - prices[0]; } else { return 0; } } int now = 0; int max_price = 0; int max_profit = 0; int len = prices.length; for (int i = 0; i &lt; len; i++) { //在第i天买入 for (int j = i+1; j &lt; len; j++) { //寻找利润最高的第j天，当天卖出 if (prices[j] &gt; max_price &amp;&amp; prices[j] &gt; prices[i]) { max_price = prices[j]; } } if (max_price - prices[i] &gt; max_profit) { max_profit = max_price - prices[i]; } max_price = 0; } return max_profit; }} 优化做法 我们需要的结果是后面减前面的最大利润差。 假设我们现在处于第 i 天，我们可以认为，我们有穿越到过去的能力，能够穿越到第 i 天之前的历史最低点买入股票，再穿越回来，把股票卖掉，这样一来，未来的变数我们虽然不知道，但我们得到了第 i 天当天内的最优解。 这样一来，在 i 从头遍历到尾的过程中，我们只要用一个变量 max_profit 记录并更新我们曾经见过的最大利润差，在遍历完成后，返回 max_profit 即可。 由于只要扫描一次，时间复杂度 O(n)O(n)O(n) ，空间复杂度 O(1)O(1)O(1). 12345678910111213141516171819202122232425262728293031323334class Solution { public int maxProfit(int[] prices) { /*Corner Case*/ if (prices.length == 0 || prices.length == 1) return 0; if (prices.length == 2) { if (prices[1] - prices[0] &gt; 0) { return prices[1] - prices[0]; } else { return 0; } } /*以下处理的价格数组长度至少为3*/ int len = prices.length; int history_low = 10000000; //今天之前的历史最低价格，初始值要很大，保证一开始就能被覆盖 int now_profit = 0; //如果今天卖出，能赚的利润 int max_profit = 0; //到今天位置，曾出现的最大利润差 for (int i = 1; i &lt; len; i++) { //每天参考昨天的价格，更新历史最低价或者不更新 history_low = Math.min(prices[i-1], history_low); //如果能卖，计算今天卖出与历史最低价的利润差 if (prices[i] &gt; history_low) { now_profit = prices[i] - history_low; //更新最大利润差 max_profit = Math.max(now_profit, max_profit); } //清空缓存的“当天利润差”，进入下一天 now_profit = 0; } return max_profit; }} 一维动态规划 设 dp[i] 表示在第 i 天卖出手里股票得到的最大利润，history_low 表示截止第 i-1 天的历史最低股价。 状态转移方程为 dp[i]=max(dp[i−1], prices[i]−history_low)dp[i] = max \\left( dp[i-1], \\ prices[i] - history\\_low \\right) dp[i]=max(dp[i−1], prices[i]−history_low) 代码如下 123456789101112131415161718192021222324252627282930class Solution { public int maxProfit(int[] prices) { /*Corner Case*/ if (prices.length == 0 || prices.length == 1) return 0; if (prices.length == 2) { if (prices[1] - prices[0] &gt; 0) { return prices[1] - prices[0]; } else { return 0; } } /*以下处理的价格数组长度至少为3*/ int len = prices.length; int history_low = 10000000; //今天之前的历史最低价格，初始值要很大，保证一开始就能被覆盖 int[] dp = new int[len]; dp[0] = 0; for (int i = 1; i &lt; len; i++) { //每天参考昨天的价格，更新历史最低价或者不更新 history_low = Math.min(prices[i-1], history_low); if (prices[i] &gt; history_low) { //如果能卖，计算今天卖出与历史最低价的利润差 dp[i] = Math.max(dp[i-1], prices[i] - history_low); } else { //如果不能卖，则最大利润差不变，直接复制上一个dp的值 dp[i] = dp[i-1]; } } return dp[len-1]; }} 比较与分析 暴力扫描法最容易想到，但时间复杂度实在太高，不讨论。 一维动态规划的做法，性能上其实不如第二种做法，因为它使用了一个长度为 prices.length 的数组 dp[] 来存储每天计算出的最大利润差，而本质上，dp[i] 的值只与 dp[i-1] 和其他常数个辅助变量有关，所以没必要浪费存储空间，只需要使用2个变量，分别是 now_profit 和 max_profit 来记录当天利润差和历史最大利润差就可以了。 但是，动态规划胜在思路更加清晰易得，容易分析和入手，以后可以考虑先用DP思想思考问题，解决完之后，再考虑空间存储上的优化问题。","link":"/cjpark/2020/11/21/best_time_to_buy_and_sell_stock/"},{"title":"LC 217 存在重复元素","text":"题目 给定一个整数数组，判断是否存在重复元素。 如果任意一值在数组中出现至少两次，函数返回 true 如果数组中每个元素都不相同，则返回 false 示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/contains-duplicate 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 方法一 哈希表 一般来讲，这种涉及到统计有限长度数组中元素出现次数的题目，最容易想到的做法应该是哈希表法——即先进行一次数组遍历，将元素和出现次数统计到哈希表中，然后再遍历一次数组，同时在哈希表中进行快速搜索和查找。 为什么最容易想到哈希表？个人理解是：与普通数组O(n)复杂度额查找相比，哈希表的突出特点就在于具备快速查找访问的能力，所以比较适合这种需要多次用到查找的题目。 时间复杂度O(n)，空间复杂度O(n)，因哈希表占用空间。 当然由于哈希表本身的维护耗时，它在此题中表现并不突出，时间性能仅击败了 14% 的Java提交者，空间性能也不突出。 方法二 排序 + 并排指针 先对数组进行排序预处理，若存在重复元素，那么这几个重复元素必然相邻，用双指针并排前进，一旦检测到相邻项相同，说明存在重复元素。 时间复杂度O(nlogn)，空间复杂度O(1)，n为数组长度。 思路很简单，由于采用 Arrays.sort(arr) 进行排序预处理耗时较少，时间和空间性能都较好，击败了 99% 的Java提交者。 代码 Java 哈希表 123456789101112131415class Solution { public boolean containsDuplicate(int[] nums) { HashMap&lt;Integer, Integer&gt; record = new HashMap&lt;Integer, Integer&gt;(); int len = nums.length; for (int i = 0; i &lt; len; i++) { record.put(nums[i], record.getOrDefault(nums[i],0) + 1); } for (int i = 0; i &lt; len; i++) { if (record.get(nums[i]) &gt;= 2) { return true; } } return false; }} Java 排序 + 双指针 123456789101112131415161718192021222324class Solution { public boolean containsDuplicate(int[] nums) { int a = 0; int len = nums.length; int b = 1; if (len == 0 || len == 1) return false; Arrays.sort(nums); while (b &lt; len) { if (nums[a] == nums[b]) { return true; } else { a++; b++; } } if (b == len - 1) { return false; } return false; }}","link":"/cjpark/2020/11/03/contains_duplicate/"},{"title":"VSCode C&#x2F;C++环境配置傻瓜教程","text":"介绍VSCode C/C++环境配置过程 一、官网下载VS Code并安装 你想装在哪个盘都没问题 Visual Studio Code 64bit for Windows 官网下载地址 https://code.visualstudio.com 二、下载MinGW编译器 进行这一步首先你要翻墙，具体怎么翻墙请查看科学上网教程 访问SourceForge官网，在搜索框输入 mingw ，点击搜索，如图所示 [SourceForge官网链接：https://sourceforge.net/] 搜索结果出来后，向下滚动页面，选择 MinGW-w64 for 32 and 64 bit Windows ，即下图圈出的这一项（不要选其他！） 点击进入之后，不要急！不要点 Download ！点 Download 按钮下面的 File 点击File后，将页面向下滚动，找到并点击MinGW-W64 GCC-8.1.0下面的 x86_64-win32-seh 点击后稍等几秒，会自动开始下载，是一个 .7z 压缩包，我们先将它保存到桌面 三、安装编译器 1.打开压缩包，先将里面的文件拖到桌面上 如果压缩包打不开，请百度haozip，下载解压软件 2.将刚刚拿出来的mingw64文件夹，移动到C:\\Program Files目录下 备注：其实你想放哪都可以，只要你别忘了你把它放在什么路径下就行了 3.现在随便用点什么东西，记下下面三个路径（后面配置vscode会用到） 编译器目录： 1C:\\Program Files\\mingw64\\bin C++编译器地址： 1C:\\Program Files\\mingw64\\bin\\g++.exe C++Debugger地址： 1C:\\Program Files\\mingw64\\bin\\gdb.exe 如果自己将mingw64文件夹放到了别的目录，请自行替换成对应路径 4.按下图所示步骤打开【高级系统设置】 打开资源管理器，右键点击 此电脑 ，点击 属性 ，跳转到新的窗口，在新窗口左栏找到 高级系统设置 ，点击进入 5.打开环境变量配置窗口 6.选中下方【系统变量】条目框里面的【Path】，然后点击下方的【编辑】 7.点击【新建】，把之前讲过的”编译器目录“复制进去，点击确定 也就是这条路径 1C:\\Program Files\\mingw64\\bin 8.检验编译器是否安装成功 搜索 cmd 并运行 输入下面的命令（注意gcc和-v中间有一个空格） 1gcc -v 如果弹出一大堆东西，且最后一行写了gcc的版本号为8.1.0，则安装成功 四、配置VS Code 1.建立VS Code工作区 找个你喜欢的目录，在此目录下新建一个文件夹，比如CppWorkSpace，它将作为你用VS Code编写C/C++代码的工作区，比如我将我的工作区建立在以下路径 1D:\\CppWorkSpace 注意！工作区的完整路径（也就是从盘符开始一直到工作区文件夹经过的路径）不能含有中文字符！否则后续Debug过程会出现报错！ 接下来请在工作区目录下建立一个叫作 .vscode 的文件夹，即 1D:\\CppWorkSpace\\.vscode 进入 .vscode 文件夹，新建一个名叫 tasks.json 的文件 1D:\\CppWorkSpace\\.vscode\\tasks.json 打开VS Code，在顶部菜单栏选择 File -&gt; Open Folder ，选择你的CppWorkSpace文件夹 现在可以从VS Code的左边栏看见打开的工作区目录了 2.配置tasks.json文件 双击打开 tasks.json ，若里面有代码，将其全部删除，然后复制以下代码，粘贴到tasks.json中 12345678910111213141516171819{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;C/C++: g++.exe build active file&quot;, &quot;command&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [&quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;], &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceFolder}&quot; }, &quot;problemMatcher&quot;: [&quot;$gcc&quot;], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ] } 粘贴完毕后，我们需要做一点改动，将这个路径 123{&quot;command&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;} 替换成 123{&quot;command&quot;: &quot;C:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe&quot;} 也就是我们上文提到的【编译器地址】，但是注意！需要将单斜杠 \\ 改成双斜杠 \\\\ ，JSON文件才能识别你的编译器路径。 到这里， tasks.json 配置完毕。 请重启VS Code！ 3.配置launch.json文件 与上一条类似地，在 .vscode 目录下新建一个 launch.json 文件，并用VScode打开 如果打开后里面有代码，请全部删除，然后将以下代码复制粘贴至launch.json 1234567891011121314151617181920212223242526{&quot;version&quot;: &quot;0.2.0&quot;,&quot;configurations&quot;: [{&quot;name&quot;: &quot;g++.exe - Build and debug active file&quot;,&quot;type&quot;: &quot;cppdbg&quot;,&quot;request&quot;: &quot;launch&quot;,&quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;,&quot;args&quot;: [],&quot;stopAtEntry&quot;: false,&quot;cwd&quot;: &quot;${workspaceFolder}&quot;,&quot;environment&quot;: [],&quot;externalConsole&quot;: false,&quot;MIMode&quot;: &quot;gdb&quot;,&quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe&quot;,&quot;setupCommands&quot;: [{&quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,&quot;text&quot;: &quot;-enable-pretty-printing&quot;,&quot;ignoreFailures&quot;: true}],&quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot;}]} 我们需要将 123{ &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe&quot;} 替换成 123{ &quot;miDebuggerPath&quot;: &quot;C:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe&quot;} 也就是我们上文提到的【C++Debugger地址】，同样注意单斜杠全部改成双斜杠。 配置完成。 请重启VS Code！ 五、运行和Debug 1.编译运行 在工作区目录下新建一个 .cpp 文件，如 kbd.cpp ，随意编写一段C或C++代码，如 1234567#include &lt;cstdio&gt;using namespace std;int main (){printf(&quot;hahahaha&quot;);return 0;} 按下 Ctrl + Shift + B ，如有弹出选择，则选 C/C++:g++.exe build active file 此时不出意外，终端会弹出 1终端将被任务重用，按任意键关闭 或者 1Terminal will be reused, press any key to exit. 如图 说明已经编译器已经成功将 kbd.cpp 编译成 kbd.exe 并放到同个目录下 但它并不会自动帮你运行 此时可以返回VS Code自带终端，输入 1.\\kbd.exe 即可在VS Code自带终端里运行代码，如图 2.另一种方法——直接用自带终端编译运行 我们需要知道，命令行是有【当前目录】的，也就是这行字 1PS D:\\CppWorkSpace&gt; 的意思表示命令行当前操控的目录为D盘下的CppWorkSpace目录 我们需要编译的 .cpp 代码源文件必须在控制台操控的目录下 例如我想要编译CppWorkSpace目录下的a.c文件，则应输入 g++ a.c（中间有空格），即 1PS D:\\CppWorkSpace&gt;g++ a.c 片刻后命令行就会刷新，表示编译完成，这时可以直接用 .\\a.exe 命令运行编译好的程序 1PS D:\\CppWorkSpace&gt;.\\a.exe 全过程如下图中控制台所示 附常用命令： （1）在当前目录下新建名为 name 的文件夹 1mkdir name （2）进入当前目录下名为 folder 的子目录 1cd folder （3）用vscode打开当前目录作为工作区 1code . 3.调试 例如：在CppWorkSpace工作区下，打开 abc.cpp ，按 F5 部分笔记本电脑如联想小新的需要按 Fn + F5 就会有断点、调试、监控功能 如果按F5后报错 No such file or directory ，请检查文件完整路径是否含有中文！","link":"/cjpark/2020/10/15/cpp_vscode/"},{"title":"[Demo] 快速排序","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;//对要操作的变量采用全局定义，可以避免指针的操作int a[101],n;int times = 0;void quickSort(int left, int right){ //left,right分别为左右指针 int i, j, t, bin; //若指针错位，退出函数 if (left &gt; right) { return; } //bin是一开始确定的基准数，也就是left指针所指的数 bin = a[left]; i = left;//左搜索针 j = right;//右搜索针 while (i != j) { while (a[j] &gt;= bin &amp;&amp; i &lt; j) { j--; } //先右后左，右搜索针找不到就一直找，找到符合要求的第一个，才轮到左搜索针出发 while (a[i] &lt;= bin &amp;&amp; i &lt; j) { i++; } //此时i,j都找到目标，若未互相超过对方，则交换两数 if (i &lt; j) { t = a[i]; a[i] = a[j]; a[j] = t; } /* 问： 如果不在两个while处加上“i&lt;j”的条件， i,j到底会不会穿越对方？ 答： 假设现在i,j尚未碰面，j正在移动， 最坏的情况是，j向左移动一直找不到比bin小的数， 那么j的救命稻草，一定是i所指的数，这个数在上一步刚刚因为 自身比bin要小而被交换到这里，所以j最多移动到i所指的位置， 不可能穿越i； 但是！这时候轮到i移动了！i还没移动时，所指的数， 一定是比bin小的，正是因为这样它才被换过来， 所以i必然是至少要前进1步的，一旦这1步走出去， i就会超越j，这对情侣各奔东西，再也无法回头看对方一眼， 到此为止，算法完蛋。 综上，两处while都必须加上i&lt;j的条件，确保两者不互相穿过对方。 */ } //最后，将[两针碰面位置所指的数]与bin交换 a[left] = a[i]; a[i] = bin; //此后，数组被分成以bin为界限的各自独立的两块，分别再对这两个序列使用quickSort即可（递归） //传递给quickSort函数的是左右边界定位标，表明要处理序列的起点和终点 quickSort(left, i-1); quickSort(i+1, right); /* 问：如何确保递归自动退出而不陷入死循环？ 答：这就要用到quickSort()函数刚开始加入的判断语句， if(left&gt;right)return; 如果排序已经完成，此时quickSort处理的对象，起点等于终点， 即传入参数left=right，执行完后，递归传入left不变，right减一， 就会造成left&gt;right，此时让函数return即可结束递归。 */ return;}int main(){ scanf(&quot;%d&quot;,&amp;n); for (int i=1; i&lt;=n; i++) { scanf(&quot;%d&quot;,&amp;a[i]); } quickSort(1, n); for (int i=1; i&lt;=n; i++) { printf(&quot;%d &quot;,a[i]); } return 0;}","link":"/cjpark/2020/09/26/demo_quicksort/"},{"title":"[Demo] 归并排序","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void Merge (int arr[], int L, int M, int R){ /*此处数组的头指针和尾指针需要参数给出，便于获取数组长度*/ int LEFT_SIZE = M - L + 1; //M算作左序列一份子，左序列长度额外加一 int RIGHT_SIZE = R - M; //M不算右序列份子，右序列长度不需要加一 //分别新建数组存放左、右子序列 int L_arr[LEFT_SIZE]; int R_arr[RIGHT_SIZE]; //先原封不动将数组左、右两边分别copy到左、右子序列 for (int i = L; i &lt;= M; i++) { //M是属于左序列的，所以要从L到M遍历 L_arr[i-L] = arr[i]; } for (int j = M+1; j &lt;= R; j++) { //M不属于右序列，所以从(M+1)遍历到R R_arr[j-M-1] = arr[j]; } //复制完毕后，同时操作左右子序列，排序、重构母序列 int i = 0; //左序列起始位置 int j = 0; //右序列起始位置 int k = L; //k作为母序列控制指针 //i,j都未到终点时，交替移动 //此处不等号不取等，就是因为数组长度与末位下标相差1 while (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE) { if (L_arr[i] &lt;= R_arr[j]) { arr[k] = L_arr[i]; i++; k++; } else { arr[k] = R_arr[j]; j++; k++; } } //若j先超过终点，将左边子序列后面剩余的数按顺序照搬到母序列 while (i &lt; LEFT_SIZE) { arr[k] = L_arr[i]; k++; i++; } //若i先超过终点，将右边子序列后面剩余的数按顺序照搬到母序列 while (j &lt; RIGHT_SIZE) { arr[k] = R_arr[j]; k++; j++; }}void MergeSort (int arr[], int L, int R){ /* 为什么将分界点的计算放到MergeSort()里面而非其他位置？ 1.Merge()是被MergeSort()调用的子函数，在MergeSort中算出M，以参数形式传给Merge()，更方便 2.避免了在main()中计算M的麻烦，保证了main()中只写主干程序 */ /* 此处有巨坑，算出半长度后要记得加上左指针值， 另外要考虑整数除法其实是向下取整的， 要特别注意到最深处（每个子序列只有一个数）时，L,M,R的取值分别是多少， 以此确定[防止递归死循环的判定条件]应该怎么写， 可以举简单序列在纸上模拟运行到最后一步，观察L,M,R的特点， 本例中得出判定条件为 if (L &gt; (R-1)) */ int M = L + (R - L) / 2; //中点到底偏向哪边不重要，举简单例子观察就行 //递归调用函数必备，防死循环的条件判定 //一般来讲，最好通过观察实际用例来写，yy很容易出错 if (L &gt; (R-1)) { return; } else { MergeSort(arr, L, M); MergeSort(arr, M+1, R); Merge(arr, L, M, R); } }int main (){ //输入待排序列的长度与内容 int n = 0; int arr[100000]; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;,&amp;arr[i]); } //排序 MergeSort(arr, 0, n-1); //输出结果 for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;,arr[i]); } return 0;}/* 补充： 1.测试用例一定要全面，长度为奇数和偶数的序列都要测试； 2.从0开始还是从1开始？在写的时候就要想好，等全部码完再查错很困难； 3.不等号到底要不要取等？用特殊样例测清楚再写； 4.如果从0开始管理数组，特别注意数组长度和末尾下标之间是相差1的；*/","link":"/cjpark/2020/10/03/demo_mergesort/"},{"title":"搞设计必备的工具&#x2F;资源&#x2F;网站","text":"给看官们推荐一下笔者常用的设计资源和网站 Dribbble—灵感之源 Dribbble 是全球最大的在线设计交流网站，来自世界各地的顶尖设计师经常在该站上发布自己的作品。 笔者平时会经常上去观摩大师的设计，获取配色灵感，提高审美标准，同时get到设计界的最新潮流。 笔者坚信，多欣赏优秀的设计作品是提高设计感觉的重要方式。 什么是设计感觉？ 当你拿到一组内容时，脑子里浮现出的东西——如何排版布局？间距应该宽松还是紧凑？这样的内容使用什么风格更有表现力和冲击力？是 Material 还是 圆角弥散阴影风 ？使用 衬线字体 还是 无衬线字体 ？ 以上都属于 设计感觉 的范畴。 该网站上展示的设计作品种类很多——各种风格的插画、App UI设计图、网页设计图、图标设计集、LOGO设计集等等… 这里截取 Dribbble 上的几幅 Shots 供大家欣赏。 iSlide—万能插件 讲到设计，就不得不讲到我们的老朋友 Power Point. 熟悉笔者的朋友都知道，平时笔者大部分的设计都是使用我们最熟悉的软件 Microsoft Power Point 来完成的。 比如，下面的 展示页面 或 Banner 都是我用PPT完成的。 思政课课堂展示封面 微信公众号卡片内容呈现 公众号推文首图 会议PPT封面 清华大学录取名单卡片 言归正传，Power Point 之所以能成为我快速实现设计想法的得力助手，离不开 iSlide 这款PPT插件的功劳。 iSlide是集强大的排版布局功能、内容丰富的素材库于一身的一款PPT设计辅助插件。 在笔者看来，这款插件最有价值的功能当属其即拿即用的素材库——包含大量的图标素材、图片素材和矢量插画。 有了上述的辅助，再搭配简单的阴影和渐变，做出下面的Banner图简直不要太轻松~~ 关于iSlide插件的介绍就先到这里，实话实说，笔者对其强大功能仍知之甚少，还需要不断地实践与探索，欢迎读者与笔者分享你的使用心得~ ICONFONT—图标资源 笔者有一个习惯——在做PPT展示或页面设计时，遇到具有 并列关系 的内容需要 分点罗列 时，笔者会在每个内容条目前加上一个与内容相关的小图标，而不是选择使用干巴巴的 项目符号 。 因为笔者相信，形象化的表达比干涩的文字更有感染力，图标就是它的灵魂。 那么如何方便快捷地寻找我们需要的图标呢？ 这里笔者推荐阿里巴巴的图标站：https://www.iconfont.cn 在搜索栏键入关键字就能找到有关的大量图标。 如下图搜索 Folder 便可以找到与“文件夹”有关的图标。 点击图标弹出下载界面，可以自定义图标的颜色，在线生成 .svg ，.ai ，.png 等格式的图标，非常便捷。一般来说，在设计PPT时，下载 PNG 格式即可，其清晰度足以满足设计需要。 WebGradients—渐变配色灵感 WebGradients是一个专注于提供渐变配色方案的网站，进入主页即可看到很多以圆形填充展示的渐变色搭配。 每种配色方案都提供两端的16进制色码，还可以直接复制 CSS 样式代码，也可以下载 PNG 或者 Sketch 格式的文件。 网址：https://webgradients.com/ 另外，若需要将16进制色码转换为 RGB 或 HSL 色码，可到以下网站。 https://www.sioe.cn/yingyong/yanse-rgb-16/ Eagle—素材管理 Eagle是笔者最近才开始使用的一款设计素材管理软件，当初听说它一群设计师使用 Electron 开发的，顿时让笔者产生了极大的兴趣。 上手试用一番后，产品的整体使用体验非常棒。Eagle客户端支持包括图片、PPTX、AI、PS、字体等设计素材的管理。 主要管理方式有：文件夹分类管理，标签Tags分类管理，主色调分类管理。 还支持根据主色调、文件类型、图片形状等属性快速筛选图片素材，爱了爱了。 Procreate—手绘插画 Procreate这款App相比不需要笔者过多介绍了，强烈建议手持 iPad + Apple Pencil 的朋友入手，软件操作非常简单，极易上手。笔者在平时空闲时也喜欢画画人像，权当学习之余的放松方式，还是非常好的。（虽然入学以后就没画过了…） 今天关于设计的分享就到这里，以后笔者会不定期回来补充~","link":"/cjpark/2020/11/07/design_tools/"},{"title":"LC 771 宝石与石头","text":"题目 给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此 &quot;a&quot; 和 &quot;A&quot; 是不同类型的石头。 示例 1: 12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/jewels-and-stones 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 传统方法的时间复杂度必然来源于遍历 S 的同时需要不断对 J 进行时间复杂度为O(n)的线性查找，使用哈希表来储存 J 即可提高查找速度。 代码 1234567891011121314151617class Solution { public int numJewelsInStones(String J, String S) { if (J.length() == 0) return 0; if (S.length() == 0) return 0; int diamond_nums = 0; HashMap&lt;Character, Integer&gt; diamond = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; J.length(); i++) { diamond.put(J.charAt(i), 0); } for (int i = 0; i &lt; S.length(); i++) { if (diamond.containsKey(S.charAt(i))) { diamond_nums++; } } return diamond_nums; }}","link":"/cjpark/2020/11/05/diamond_and_stone/"},{"title":"算法技巧 | 双指针","text":"一、快慢指针 No.26 删除排序数组中的重复项 图解（搬运） 代码实现 1234567891011121314151617181920212223242526272829class Solution { public int removeDuplicates(int[] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return 1; if (nums.length == 2) { if (nums[0] == nums[1]) return 1; else return 2; } int len = nums.length; int slow = 0; int fast = 1; while (fast &lt; len - 1) { if (nums[fast] == nums[slow]) { fast++; } else { slow++; nums[slow] = nums[fast]; } } //fast位于末尾时，额外写判断，因为while不处理最后边界情况 if (nums[slow] == nums[fast]) { return slow+1; } else { slow++; nums[slow] = nums[fast]; return slow+1; } }} No.83 删除排序链表中的重复元素 快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。 1234567891011121314151617181920212223242526272829303132333435class Solution { public ListNode deleteDuplicates(ListNode head) { //针对长度0、1、2的链表写特判 if (head == null) return head; if (head.next == null) return head; if (head.next.next == null) { if (head.val == head.next.val) { head.next = null; return head; } else { return head; } } //快慢指针 ListNode slow, fast; slow = head; fast = head; while (fast.next != null) { while (slow.val == fast.val &amp;&amp; fast.next != null) { fast = fast.next; } if (fast.next != null) { slow = slow.next; slow.val = fast.val; } } if (fast.val &gt; slow.val) { //注意，此处只有写大于号才能准确判定还有未出现的数需要前移 slow = slow.next; slow.val = fast.val; } slow.next = null; return head; }} No.876 链表的中间节点 操作方法 此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。 代码实现 123456789101112131415class Solution { public ListNode middleNode(ListNode head) { if (head.next == null) return head; //单元素链表，返回自己 if (head.next.next == null) return head.next; //以下处理的链表长度至少为3 ListNode slow, fast; slow = head; fast = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; }} 拓展 如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。 二、同步双指针 剑指Offer 22. 返回链表倒数第k个节点 两次遍历法 先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。 1234567891011121314151617class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode x; int count = 0; for (x = head; x.next != null; x = x.next) { count++; } x = head; for (int i = 0; i &lt;= count - k; i++) { x = x.next; } return x; }} 定距同步双指针 开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。 12345678910111213141516171819class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode p1; ListNode p2; p1 = head; p2 = head; for (int i = 0; i &lt; k; i++) { p2 = p2.next; } while (p2 != null) { p1 = p1.next; p2 = p2.next; } return p1; }} 剑指Offer 24. 反转链表 辅助栈法 123456789101112131415class Solution { public ListNode reverseList(ListNode head) { if (head == null) return null; if (head.next == null) return head; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x,y; for (x = head; x != null; x = x.next) { stk.push(x.val); } for (y = head; y != null; y = y.next) { y.val = stk.pop(); } return head; }} 原地反转（三指针法） 12345678910111213141516171819202122232425class Solution { public ListNode reverseList(ListNode head) { /*使用三根指针是为了在改变next过程中保证衔接*/ if (head == null) return null; if (head.next == null) return head; //以上特判已经排除链表长度小于2的情况 //三指针同步向前移动 ListNode pre, cur, fu; pre = null; cur = head; fu = head.next; while (fu != null) { cur.next = pre; pre = cur; cur = fu; fu = fu.next; } //while结束后，最后一个节点尚未反转 //反转尾节点 cur.next = pre; return cur; }}","link":"/cjpark/2020/11/20/double_cursor/"},{"title":"LC 724 寻找数组中心索引","text":"题目 给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例 1： 123456输入：nums = [1, 7, 3, 6, 5, 6]输出：3解释：索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。 示例 2： 12345输入：nums = [1, 2, 3]输出：-1解释：数组中不存在满足此条件的中心索引。 说明： nums 的长度范围为 [0, 10000]。 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/find-pivot-index 分析 外层循环对数组每个元素进行遍历 内层两个分开的循环，左指针遍历当前元素左边的元素并求和，右指针遍历当前元素右边的元素并求和，然后比较左右和是否相等，相等则截断操作并返回索引值 后来发现自己是SB，明明可以不用右指针，可在一开始就遍历数组元素，对所有元素求和并储存all_sum，以后每次得到left_sum时，可直接用一条减法来算出right_sum，就不用浪费时间 注意自己测试的用例一定要涵盖一般情况和特殊情况，确定没有问题再提交 传参时传入指向数组的指针时，在函数中可直接用数组名访问数组（因为实际上这个指针传入的就是数组的首地址，跟直接传数组名是一样的效果） 注意小细节：for循环最后一步的自增，小于号取不取等，是否所有的输入情况都已经保证函数有出口（返回值）… 代码 1234567891011121314151617181920212223242526272829int pivotIndex(int* nums, int numsSize){ int left_sum = 0; int right_sum = 0; int i = 0, l_piv = 0, r_piv = 0; int all_sum = 0; for (int k = 0; k &lt; numsSize; k++) { all_sum += nums[k]; } for (i = 0; i &lt; numsSize; i++) { for (l_piv = 0; l_piv &lt; i; l_piv++) { left_sum += nums[l_piv]; } right_sum = all_sum - left_sum - nums[i]; // for (r_piv = numsSize-1; r_piv &gt; l_piv; r_piv--) { // right_sum += nums[r_piv]; // } if (left_sum == right_sum) { return l_piv; break; } left_sum = 0; right_sum = 0; //printf(\\n); } if (i == numsSize) { return -1; } return 0;}","link":"/cjpark/2020/10/20/find_middle_index/"},{"title":"[Demo] 堆排序","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;void SwapInArray(int arr[], int x, int y){ /*Function：将数组中两个元素的值进行交换*/ int tmp; tmp = arr[x]; arr[x] = arr[y]; arr[y] = tmp; return; }void Heapify(int tree[], int n, int i){ /*Function：使tree[]中给定的以i为父节点的单个子树成为堆*/ //[递归出口]若遍历到任何一个叶节点，结束Heapify if (i &gt; n/2) { return; } //首先默认i节点数值最大 int max = i; //若左儿子存在且更大，暂时标记左儿子最大（先不交换，因为可能右儿子还要更大） if (i*2 &lt;= n &amp;&amp; tree[i*2] &gt; tree[max]) { max = i*2; } //若右儿子存在且还要更大，标记右儿子为该三元子树中的最大节点 if (i*2+1 &lt;= n &amp;&amp; tree[i*2+1] &gt; tree[max]) { max = i*2+1; } //如果i不是最大，说明需要更换 if (max != i) { //交换i和儿子max的数值（不交换编号） SwapInArray(tree, max, i); Heapify(tree, n, max); /* 为什么此处需要递归？ 因为我们在BuildMaxTree()中是自底向上使用Heapify()的， 可能会出现的情况是：Build之前的乱序树中，接近顶端 有一些很小很小的数，我们在Build时遍历到此处，对接近顶端的 子树使用Heapify时，这些很小的数会下沉，成为下方子树的父节点， 而它的子节点有可能比它要大，所以我们要对这些子树继续Heapify， 让这些很小的数继续下沉，有多深沉多深， 所以Heapify()需要递归调用自己来处理脚下的所有树， 保证让上面任何应该下沉的小数都下沉到它应该去的深度。 */ } return;}void BuildMaxHeap(int tree[], int n){ /*Function：将无序数组建立成最大堆*/ //从倒数第二层最后一个节点开始，向上遍历每一个节点，对每一个节点Heapify() for (int i = n/2; i &gt;= 1; i--) { Heapify(tree, n, i); }}int DeleteMax(int tree[], int n){ /* 将末尾叶节点值直接赋给树顶节点， 此时除了树顶外所有子树都满足最大堆， 再对树顶节点Heapify() */ int tmp; tmp = tree[1]; tree[1] = tree[n]; Heapify(tree, n, 1); return tmp;}int main(){ int tree[10001]; int arr[10001];//存放排序结果 int num; scanf(&quot;%d&quot;, &amp;num); for (int i = 1; i &lt;= num; i++) { scanf(&quot;%d&quot;, &amp;tree[i]); } BuildMaxHeap(tree, num); //倒序记录最大堆输出结果 for(int i = num; i &gt;= 1; i--) { arr[i] = DeleteMax(tree,i); /* 如果每次for循环都向DeleteMax()传递参数num， 那么DeleteMax()中的n--就不起作用， 于是改成每次for循环向DeleteMax()传输i, 等效于手动删除堆的末尾叶节点. */ } for (int i = 1; i &lt;= num; i++) { printf(&quot;%d &quot;,arr[i]); } return 0;}","link":"/cjpark/2020/10/04/demo_heapsort/"},{"title":"算法 | 动态规划","text":"本文为笔者学习动态规划的刷题总结笔记。 💡 思路提要 关键点分析 自顶向下存在大量重叠子问题 记忆化 / 备忘录 充分利用已知信息 状态转移 / 递推关系 主要步骤 确定状态定义 写出状态转移方程 初始化 dp 数组 递推 dp 状态压缩（滑动窗口 / 滚动数组） 补充边界特判 📔 典型例题 一、递推型 DP No.70 爬楼梯 一维DP写法 123456789101112131415class Solution { public int climbStairs(int n) { if (n == 0 || n == 1) return 1; if (n == 2) return 2; int[] dp = new int[n+1]; int rec = 0; dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; }} 空间优化 只需要三个变量 low ，mid ，high 交替前进。 12345678910111213141516class Solution { public int climbStairs(int n) { if (n == 0 || n == 1) return 1; if (n == 2) return 2; int low, mid, high; low = 1; mid = 1; high = 2; for (int i = 1; i &lt; n-1; i++) { low = mid; mid = high; high = low + mid; } return high; }} No.746 使用最小花费爬楼梯 虽然本题对上一题做了小小的手脚和改动，但其中涉及的临界处理（ dp[] 数组的长度相比原数组长度，需要增加一个单位）值得一练。 （此题省略空间优化写法） 1234567891011121314151617181920212223class Solution { public int minCostClimbingStairs(int[] cost) { int len = cost.length; /*Special Judge*/ if (len == 2) return cost[0]; if (len == 3) return Math.min(cost[0]+cost[2], cost[1]); //为什么要len+1？是为了处理最后通过2步踏上目标阶梯的情况 int[] dp = new int[len+1]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; len+1; i++) { dp[i] = Math.min(dp[i-1], dp[i-2]); //如果最后是通过2步走上台阶的，数组会越界，此处防止越界 if (i != len) dp[i] += cost[i]; } //比较最后到底是2步上还是1步上花费更少，并返回小的结果 return Math.min(dp[len],dp[len-1]); }} 面试题 17.16. 按摩师 题目分析 首先审清楚题意：题中所说的这位按摩师是个奋斗逼，除了不能连续接任务之外，需要不惜一切代价提高自己的收入。 也就是说，这位按摩师一定会让自己所接的任务尽可能地密集，任务与任务之间的间隔预约数 kkk 一定满足 1⩽k⩽31\\leqslant k \\leqslant 31⩽k⩽3 （可以用反证法证明，假设间隔数比 3 大，按摩师一定可以再多接中间的若干处任务）。 另外一个需要挖掘的条件是：最后一个预约和倒数第一个预约，按摩师一定会接其中一个（同样可用反证法证明，如果按摩师接了倒数第 3 个及以前的任务，后面一定还可以再接任务，有钱为什么不赚呢？） 我们将 “按摩师在完成第 iii 个预约后的最大工作总时长” 记为 OPT(i) ( i 从 0 开始计)，根据上面的分析，我们的最终目标是求 max(OPT(len−1), OPT(len−2))max \\left( OPT(len-1), \\ OPT(len-2) \\right) max(OPT(len−1), OPT(len−2)) 状态转移方程 按摩师一定是相隔 2 个或 3 个任务的位置来到当前任务的。 所以有 OPT(i)=max(OPT(i−2), OPT(i−3))+nums[i]OPT(i) = max \\left( OPT(i-2),\\ OPT(i-3) \\right) + nums[i] OPT(i)=max(OPT(i−2), OPT(i−3))+nums[i] 递归写法 12345678910111213141516class Solution { public int massage(int[] nums) { /*Special Judge*/ int len = nums.length; if (len == 0) return 0; if (len == 1) return nums[0]; if (len == 2) return Math.max(nums[0],nums[1]); return Math.max(OPT(nums,len-1),OPT(nums,len-2)); } public int OPT(int[] nums, int i) { if (i == 0) return nums[0]; if (i == 1) return nums[1]; if (i == 2) return nums[0] + nums[2]; return Math.max(OPT(nums,i-2)+nums[i], OPT(nums,i-3)+nums[i]); }} 由上图的递归树可见，递归写法存在太多重叠子问题，效率太低，从而因 MLE 卡在了下面的测试样例处. 1[226,174,214,16,218,48,153,131,128,17,157,142,88,43,37,157,43,221,191,68,206,23,225,82,54,118,111,46,80,49,245,63,25,194,72,80,143,55,209,18,55,122,65,66,177,101,63,201,172,130,103,225,142,46,86,185,62,138,212,192,125,77,223,188,99,228,90,25,193,211,84,239,119,234,85,83,123,120,131,203,219,10,82,35,120,180,249,106,37,169,225,54,103,55,166,124] 一维DP写法 从本质上看，这道题与跳台阶无异，本质上是 “选与不选” 类问题，从这个角度出发，一维的DP递推就很好写了。 1234567891011121314151617class Solution { public int massage(int[] nums) { /*Special Judge*/ int len = nums.length; if (len == 0) return 0; if (len == 1) return nums[0]; if (len == 2) return Math.max(nums[0],nums[1]); int[] dp = new int[len]; dp[0] = nums[0]; dp[1] = nums[1]; dp[2] = nums[2] + nums[0]; for (int i = 3; i &lt; len; i++) { dp[i] = Math.max(dp[i-2],dp[i-3]) + nums[i]; } return Math.max(dp[len-1],dp[len-2]); }} 空间优化 首先我们忽略题目具体细节，将整体模型抽象出来，本题实际上就是跳台阶，只不过每次跳台阶的步数只能是 2 步或者 3 步。 也就是说，跳上第 i 层台阶所需的步数 dp[i] ，只与 dp[i-2] 和 dp[i-3] 有关。换句话说，我们只需要一个长度为 4 的数组 dp[] ，在每次通过 dp[0] 和 dp[1] 计算出 dp[4] 后，通过平行赋值实现滚动数组（有点类似于在原来长度为 nums.length 的 dp[] 数组上，放一个长度为 4 的滑动窗口），即可将使用的额外空间降到 O(1)O(1)O(1) 级别。 另外需要对 nums.length 为 3 的情况写特判，此处不赘述。 1234567891011121314151617181920212223242526class Solution { public int massage(int[] nums) { /*Special Judge*/ int len = nums.length; if (len == 0) return 0; if (len == 1) return nums[0]; if (len == 2) return Math.max(nums[0],nums[1]); if (len == 3) { return Math.max(nums[0]+nums[2], nums[1]); } /*以下处理的nums[]长度不少于4*/ int[] dp = new int[4]; dp[0] = nums[0]; dp[1] = nums[1]; dp[2] = nums[2] + nums[0]; for (int i = 3; i &lt; len; i++) { dp[3] = Math.max(dp[0],dp[1]) + nums[i]; if (i != len-1) { dp[0] = dp[1]; dp[1] = dp[2]; dp[2] = dp[3]; } } return Math.max(dp[3],dp[2]); }} 相似题目 No.198 打家劫舍 剑指Offer 42. 连续子数组最大和 状态定义 dp[i] 表示以 nums[i] 结尾的连续子数组的和 状态转移方程 dp[i]={dp[i−1]+nums[i],dp[i−1]≥0nums[i],dp[i−1]&lt;0dp\\left[ i \\right] =\\begin{cases} dp\\left[ i-1 \\right] +nums\\left[ i \\right] , dp\\left[ i-1 \\right] \\ge 0\\\\ nums\\left[ i \\right] , dp\\left[ i-1 \\right] &lt;0\\\\ \\end{cases} dp[i]={dp[i−1]+nums[i],dp[i−1]≥0nums[i],dp[i−1]&lt;0​ 一维DP写法 12345678910111213141516class Solution { public int maxSubArray(int[] nums) { int len = nums.length; int[] dp = new int[len]; int res = -99999; dp[0] = nums[0]; for (int i = 1; i &lt; len; i++) { if (dp[i-1] &gt;= 0) dp[i] = dp[i-1] + nums[i]; else dp[i] = nums[i]; } for (int i = 0; i &lt; len; i++) { res = Math.max(res,dp[i]); } return res; }} 空间优化 舍弃 dp[] 数组，只需要一个变量 sum ，当 sum 为负数时，直接用 nums[i] 覆盖，当 sum 为非负数，则加上 nums[i] 的值。 在此同时，用一个记录变量 max_sum 记录该过程中曾经出现的最大和即可。 状态压缩后，辅助空间从 O(n)O(n)O(n) 减少至 O(1)O(1)O(1)，遍历次数从 2 次减少到 1 次（不需要浪费一次遍历来寻找最大值） 123456789101112131415161718class Solution { public int maxSubArray(int[] nums) { int len = nums.length; int sum = nums[0]; int max_sum = sum; sum = nums[0]; for (int i = 1; i &lt; len; i++) { if (sum &lt; 0) { sum = nums[i]; } else if (sum &gt;= 0) { sum += nums[i]; } max_sum = Math.max(max_sum, sum); } return max_sum; }} 剑指Offer 47. 礼物的最大价值 题目分析 前面做的都是“爬楼梯”型的一维DP，本题属于二维DP. 分析单个状态，除了特殊值（行列边界）外，每个格子都只能从它的上方或左方到达，每个位置都贪心，总礼物价值即可最大（二维DP数组右下角的值，就是最终的结果）. 为了避免多余的判定和讨论，一开始先初始化 dp[][] 的行列边界，边界值的每个格子的前一步都只有一种可能（要么从上面来，要么从左边来），所以 dp[][] 的边界值填充很简单，累加求和即可. 状态定义 设 dp[i][j] 为：拿完 (i,j)(i,j)(i,j) 位置格子的礼物后，手中礼物的最大价值. 状态转移方程 dp[i][j]=max(dp[i−1][j], dp[i][j−1])+grid[i][j]dp[i][j]= max \\left( dp[i-1][j],\\ dp[i][j-1] \\right) + grid[i][j] dp[i][j]=max(dp[i−1][j], dp[i][j−1])+grid[i][j] 二维DP写法 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public int maxValue(int[][] grid) { /*获取数组长和宽*/ int row_len = grid.length; //m int col_len = grid[0].length; //n /*特判：单个，单行，单列，三种情况*/ if (row_len == 1) { int sum = 0; for(int i = 0; i &lt; col_len; i++) { sum += grid[0][i]; } return sum; } if (col_len == 1) { int sum = 0; for(int i = 0; i &lt; row_len; i++) { sum += grid[i][0]; } return sum; } int[][] dp = new int[row_len][col_len]; dp[0][0] = grid[0][0]; /*初始化二维dp数组的横竖边界，使得后续的格子都可以由上边或左边的格子走到，避免特殊情况讨论*/ for (int row = 1; row &lt; row_len; row++) { dp[row][0] = dp[row-1][0] + grid[row][0]; } for (int col = 1; col &lt; col_len; col++) { dp[0][col] = dp[0][col-1] + grid[0][col]; } /*开始二维DP，走到尽头就是答案*/ for (int row = 1; row &lt; row_len; row++) { for (int col = 1; col &lt; col_len; col++) { dp[row][col] = Math.max(dp[row-1][col], dp[row][col-1]) + grid[row][col]; } } return dp[row_len-1][col_len-1]; }} 空间优化 待补充 相似题目 No.64 最小路径和（二维 DP Table） 二、背包 DP 0-1 背包 有 NNN 件物品和一个容量是 VVV 的背包。每件物品只能使用一次. 第 iii 件物品的体积是 viv_ivi​ ，价值是 wiw_iwi​ . 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 约束条件 ∑vi≤V\\sum v_i \\leq V ∑vi​≤V 目标函数 max(∑wi)max\\left( \\sum w_i \\right) max(∑wi​) 状态定义 f[i][j]f[i][j]f[i][j] 表示考虑前 iii 个物品放入容量为 jjj 的背包中时能取得的最大价值. 状态转移 f[i][j]={f[i−1][j]，不选第i件物品f[i−1][j−v[i]]+w[i]，选第i件物品f\\left[ i \\right] \\left[ j \\right] =\\begin{cases} f\\left[ i-1 \\right] \\left[ j \\right] \\text{，不选第}i\\text{件物品}\\\\ f\\left[ i-1 \\right] \\left[ j-v\\left[ i \\right] \\right] +w\\left[ i \\right] \\text{，选第}i\\text{件物品}\\\\ \\end{cases} f[i][j]={f[i−1][j]，不选第i件物品f[i−1][j−v[i]]+w[i]，选第i件物品​ 递归 1234567891011121314public int PickDrugs(int M, int T, int[] val, int[] time) { return DP(M,T,M,T,val,time);}public DP(int k, int t, int M, int T, int[] val, int[] time) { if (k == 0) return 0; if (t &lt; time[k]) { return DP(k-1, t, M, T, val, time); } else { return Math.max( DP(k-1, t-time[k], M, T, val, time) + val[k], DP(k-1, t, M, T, val, time)); }} 二维 DP Table 迭代 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;const int N = 1010; //背包个数与物品件数最大值，可修改int n,m; //n为物品数，m为背包容量int v[N],w[N];int f[N][N]; //DP Tableint res; //存结果int main(){ cin&gt;&gt;n&gt;&gt;m; for (int i = 1; i &lt;= n; i++) cin&gt;&gt;v[i]&gt;&gt;w[i]; //先列后行遍历二维数组 for (int j = 1; j &lt;= m; j++) { for (int i = 1; i &lt;= n; i++) { if (j-v[i] &gt;= 0) { //防止数组下标越界 f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i]); } else { f[i][j] = f[i-1][j]; } } } //取得全局最优解时，背包未必恰好装满，所以需要遍历Table最后一行取最大值 for (int i = 1; i &lt;= m; i++) { res = max(res, f[n][i]); } cout&lt;&lt;res&lt;&lt;endl; return 0;} 题目 0-1背包模板问题 lgP1048 采药","link":"/cjpark/2020/11/21/dynamic_programming/"},{"title":"Hexo + Gitee 部署个人博客","text":"最近在尝试搭建个人博客，本来刚安装好WordPress，突然觉得这种动态的CMS有点过于臃肿，用来作个人博客的管理平台有点杀鸡用牛刀的意思. 后来在B站看了CodeSheep的介绍视频，决定尝试VuePress，但搭建好后又发现过于“静态”，缺少给文章打tag , category 之类的功能，对于经常需要更新的博客，维护起来比较麻烦（可能还是更适合做完全静态的展示页面，如开发者文档）。 几经周转，最终在今天用Hexo将博客部署在了Gitee上，写作和文章管理的体验都非常不错。 基本步骤 下面展示我个人安装过程的主要步骤 1. 安装Node.js 到官网下载Node.js并无脑安装即可，安装后会自带npm包管理器 注意，官网一般会提供两个版本，分别是LTS(Long Term Support)和Current版，下载LTS版即可 下载后可打开命令行输入以下命令验证是否安装成功 12node -vnpm -v 2. 安装Git Google搜索Git，选择系统对应版本无脑下载安装即可 3. 安装cnpm 这一步是可选的，只为了加快速度 管理员身份打开Powershell或cmd（Win10用户可以用Windows Terminal，非常舒适），输入以下命令 1npm install -g cnpm --registry=https://registry.npm.taobao.org Windows用户在这一步可能会遭遇命令行报错，需要键入以下命令并按回车 1set-ExecutionPolicy RemoteSigned 下文默认打开命令行都使用管理员身份 4. 安装Hexo 1cnpm -g hexo-cli 同理，可输入 hexo -v 来验证安装成功 5. 初始化Hexo 建立准备用于存放博客所有文件的文件夹，例如 D:\\Hexo_Blog 用命令行进入这个目录 1cd D:\\Hexo_Blog Tips:一般命令行会有路径补全功能，只要输入文件夹名前几个字母再按 Tab 键即可自动补全路径 确认命令行当前操作目录位于 D:\\Hexo_Blog ，在此目录下输入以下命令，初始化Hexo 1hexo init 如果在这一步报错，请检查是否已经正确安装Git 6. 本地预览博客 至此，Hexo的安装和初始化已经完成，此时Hexo会为博客自动安装默认主题，并放入一篇名为Hello World的文章 我们可以启动本地服务暂时预览，命令行键入 1hexo server 打开浏览器，在地址栏输入: localhost:4000，按回车即可预览 Hexo的日常操作介绍 目录结构 12345678910.├── _config.yml ├── package.json├── public ├── scaffolds├── source| ├── _drafts| ├── _posts| └── img└── themes _config.yml ：Hexo的配置文件，可修改博客主题、文档模板等配置 /source/_posts/ ：存放 .md 格式的文章 /source/img/ ：存放整个博客的图片资源，在配置文件中的 /img/... 指的就是该位置 /public/ ：存放Hexo通过渲染将 source 中的 .md 文件渲染成的 .html 文件，也就是生成的静态页面 /themes/ ：存放第三方主题的位置，下载的主题需要存放到此处 创建和写作 可以通过以下命令新建文章，Hexo会自动创建 article_title.md 文件并存放于 /source/_post 目录下 1hexo new &quot;article_title&quot; 像我就比较头铁，直接在 /source/_post 目录下自己建 .md 文档即可开始写作 写作前可以在markdown文件的头部书写一些文章的元数据，如 123456789---title: 这里写文章名data: 2020-10-28author: cjcategory: 这里写文章从属的目录名（可省略）tags: [标签1,标签2]index_img: 文章缩略图路径banner_img: 文章Banner大图路径--- 生成静态页面 输入以下命令，Hexo会自动将 /source/ 目录下的所有文章全部生成静态页面，存放到 /public/ 目录下 1hexo generate 本地服务器预览 输入以下命令，Hexo自动将博客部署到本地，默认端口4000，访问地址 http://localhost:4000 即可预览 1hexo server 注意，本地预览可以理解为“暂时挂载的服务”，可以在刚才的命令行窗口按 Ctrl + C 结束挂载，如果你修改了配置文件或需要重新生成页面，你需要先结束挂载 将Hexo部署到云（以Gitee为例） 创建Gitee仓库 登录Gitee创建个人仓库，可以选 private 或者 public，其他选项随意（如果没有Gitee账户需要先注册一个） 下面我们需要记住和区分三样东西：仓库名、仓库路径、网站路径 以我的博客为例（其中的 coiggahou 是我的Gitee用户名，cjpark 是我的仓库名，，分别替换成你的即可） 123我的仓库名称: cjpark我的仓库路径为: https://gitee.com/coiggahou/cjpark 我的网站路径: https://coiggahou.gitee.io/cjpark 创建本地Git信息 之前在本地安装Git之后，如果没有进行基础配置，那么需要配置以下用户名和邮箱（作为每次push时的凭据） 12git config --global user.name &quot;填写用户名&quot;git config --global user.email &quot;填写邮箱&quot; 本地和Gitee通讯 终端输入 1ssh-keygen -t rsa -C &quot;这里输入简单短语描述公钥名称&quot; 再输入 1cat ~/.ssh/id_rsa.pub 可以看到公钥的内容，我们将其全部选中并复制，准备放到Gitee上 访问Gitee，个人 -&gt; 设置 -&gt; 安全设置 -&gt; SSH公钥 -&gt; 添加公钥 -&gt; 输入并保存公钥 接下来在终端输入以下命令测试是否配置成功 1ssh -T git@gitee.com 若输出“Hi!..”表明本地和Gitee通讯成功 安装Hexo用于部署的插件 1npm install hexo-deployer-git 在Hexo配置中添加仓库信息 打开 _config.yml，找到以下 deploy 分支，填写下面的信息 1234deploy: type: git repo: 这里填写仓库地址 branch: 推送到仓库的分支（没设置就填master） 将站点push到仓库 在本地站点目录下，执行 1hexo deploy 注意，这里我们push到仓库的只是本地站点目录的 /public/ 目录，也就是所有由Hexo生成的静态页面，其他配置文件和 /source/等目录都不会被push到仓库 开启Gitee Pages服务 登录Gitee，进入之前创建的用于存放博客文件的仓库，点击 服务 中的 Gitee Pages，完成基本设置，开启服务 访问站点 此步常见问题是访问后能加在基本的HTML结构，但是网页没有CSS样式，解决方案如下 打开 _config.yml，找到以下项并填写或修改 12url: 填写网站的地址root: 填写网站的目录（如果你的网站建立在子目录，需要特别注意填写此处） 更新 Gitee Pages 总体来讲，日常写作更新博文的流程如下： /source/_post/ 目录下新建 .md 文件，添加元数据，写作（图片素材应放在 /source/img/ 目录下，文章中才能正常插入显示） 写作完成后，运行 hexo generate 生成静态页面 运行 hexo server 本地预览 本地预览确认达到理想效果后，hexo deploy 推送到仓库 登录Gitee进入对应仓库的Gitee Pages服务，点击更新 访问站点即可看到更新 个人建议 从此以后，我们的文章都将存放于本地博客站点目录下的 /source/_post/ 目录下，但我总觉得不太安全，于是在Gitee另外开了一个仓库，用于存放我本地 /source/ 目录下的所有文件。 大致操作步骤为： 在Gitee新建私人仓库 进入 /source/ 目录下，在此处打开命令行终端，按照Gitee初始仓库的操作至指南进行即可 12345git init //本地仓库初始化git add -A //这步是将source目录下所有文件添加到本地仓库git commit -m &quot;first-commit&quot;git remote add origin git@gitee.com:用户名/仓库名.gitgit push -u origin master //将本地的master分支push到远端的仓库，其中origin是仓库的别名 由于我之前已经建立了SSH公钥，故push时只需要输入密码即可 这样一来，每次我在本地写好文章之后，就可以直接将文章push到Gitee的远程仓库作为备份，剩下再按 generate -&gt; deploy 的步骤部署到站点，也就是实现文章存储与站点部署相分离，保证文档的安全。 参考 Hexo官方文档 https://hexo.io/docs/ EasyHexo（实用Hexo入门指南） https://easyhexo.com/ Hexo Fluid（我使用的Hexo主题）https://hexo.fluid-dev.com/docs","link":"/cjpark/2020/10/27/hexo_plus_gitee/"},{"title":"Python脚本实现自动登录校园网","text":"准备工作 1.下载chromedriver 如果没有安装Chrome浏览器，请先安装。 打开Chrome -&gt; 帮助 -&gt; 关于 ，查看Chrome版本号。 Tips：版本号是类似于 86.0.4240.183 这样的一串数字 下载与上述版本号相同版本的 chromedriver 下载地址：https://npm.taobao.org/mirrors/chromedriver 版本号最后三位数字可以不同，例如我的Chrome版本为 86.0.4240.183 ，我下载的chromedriver版本为 86.0.4240.22 。 下载完成后解压得到 chromedriver.exe ，将其复制到Chrome目录和Python目录下。 以下是我个人电脑上的Chrome目录与Python3.9的目录，供参考。 12Chrome --- C:/Program Files/Google/Chrome/ApplicationPython --- C:/Users/你的用户名/AppData/Local/Programs/Python/Python39 2.安装pywin32库 打开终端（命令行），输入 1pip install pywin32 等待安装成功即可。 pywin32是一个包含了大量WindowsAPI的Python库 3.安装pyinstaller打包器 打开终端（命令行），输入 1pip install pyinstaller 等待安装成功即可。 pyinstaller用于将 .py 源文件打包编译成 .exe 可执行文件 代码 12345678910111213141516171819202122232425262728from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesimport timedef openChrome(): option = webdriver.ChromeOptions() option.add_argument('disable-infobars') driver = webdriver.Chrome(chrome_options=option) return driverdef operationAuth(driver): url = &quot;http://10.248.98.2&quot; driver.get(url) elem1 = driver.find_element_by_id(&quot;username&quot;) elem1.send_keys(&quot;1234567&quot;) #Enter your id elem1 = driver.find_element_by_id(&quot;password&quot;) elem1.send_keys(&quot;ilovehit&quot;) #Enter your password driver.find_element_by_id(&quot;login&quot;).click() print(&quot;Success!&quot;)if __name__ == '__main__': driver = openChrome() operationAuth(driver) 后续 可以在Windows任务计划程序添加编译好的可执行文件，选择“每次开启启动时运行”。 解放双手！Python万岁！","link":"/cjpark/2020/11/04/hit_lan_auto_login/"},{"title":"LC 520 检测大写字母","text":"题目 给定一个单词，你需要判断单词的大写使用是否正确。 我们定义，在以下情况时，单词的大写用法是正确的： 全部字母都是大写，比如&quot;USA&quot;。 单词中所有字母都不是大写，比如&quot;leetcode&quot;。 如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。 否则，我们定义这个单词没有正确使用大写字母。 示例 1: 123输入: &quot;USA&quot;输出: True示例 2: 示例 2: 123输入: &quot;FlaG&quot;输出: False注意: 输入是由大写和小写拉丁字母组成的非空单词。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/detect-capital 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 属于字符数组的遍历问题。 单词正确的情况分为3种：USA型，Google型，flag型。 先检测首字母和第二位字母来确定类型，然后分别给 type 变量赋值1、2、3来标记上述三种类型。 三种类型遍历时，采用略微不同的检测方法即可。 注意逻辑闭合，递归出口不漏补缺。 不需要知道大小写字母的ASCII码范围，直接比较字符即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142bool detectCapitalUse(char * word){ int type = 0; //1为全大写，2为第一个大写，3为全小写 //检查第一个 if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { word++; //检查第二个 if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { type = 1; } else { type = 2; } } else { type = 3; } switch (type) { case 1: for (; *word != '\\0'; word++) { if (!(*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z')) { return false; } } return true; case 2: for (; *word != '\\0'; word++) { if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { return false; } } return true; case 3: for (; *word != '\\0'; word++) { if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { return false; } } return true; default: return false; }} 其他解法 先遍历字符串，获取字符串长度 length ，同时统计大写字母出现的次数。 当且仅当符合以下情况时，返回 true 字符串长度与大写字母个数相等 大写字母个数为1，且第一个字母大写 大写字母个数为0 其余情况返回 false 即可。 这种解法更快，因为只涉及遍历和计数，而且遍历是一气呵成，不需要受条件判断的阻滞。 123456789101112131415161718192021222324bool detectCapitalUse(char * word){ int length = 0; int caps = 0; bool isHeadCap = false; if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { isHeadCap = true; } while (*word != '\\0') { length++; if (*word &gt;= 'A' &amp;&amp; *word &lt;= 'Z') { caps++; } word++; } if (length == caps) { return true; } else if (caps == 1 &amp;&amp; isHeadCap) { return true; } else if (caps == 0) { return true; } else { return false; }}","link":"/cjpark/2020/11/01/check_capital_letter/"},{"title":"笔记 | 图论","text":"Description: 本文为作者的图论学习笔记。 📔 基本概念 一、图的表示 G=(V,E)G=(V,E)G=(V,E)，VVV为顶点集，EEE为边集 常将顶点数为 ppp ，边数为 qqq 的图简称为 (p,q)(p,q)(p,q) 图 在没有特殊说明时，GGG 指无向图，DDD 指有向图 二、图的基本信息描述 边 无向图中的边用无序对表示，如 (u,v)(u,v)(u,v) 有向图中的边用有序对表示，如 &lt;u,v&gt;&lt;u,v&gt;&lt;u,v&gt; 表示从 uuu 到 vvv 的有向边 阶 图的阶数就是图中顶点的总个数 度 对于无向图的顶点 一个顶点的度，指的是该顶点直接相连的边的数目，记作 deg(u)deg(u)deg(u) 对于有向图的顶点 入度：与该顶点直接相连的“入边”的数目，记 deg−(u)deg^{-}(u)deg−(u) 出度：与该顶点直接相连的“出边”的数目，记 deg+(u)deg^{+}(u)deg+(u) 度：该顶点入度与出度的和 最大度与最小度 δ(G)\\delta(G)δ(G) ：所有顶点度数中的最小值 Δ(G)\\Delta(G)Δ(G) ：所有顶点度数中的最大值 相应地，加上符号，如 δ+(G)\\delta ^{+}(G)δ+(G) ， 表示有向图的入度、出度的最大最小值 特殊度数的点 孤立点：度数为 0 的顶点 悬挂点：度数为 1 的顶点 奇度顶点：度数为奇数的顶点，简称奇点 偶度顶点：度数为偶数的顶点，简称偶点 度数列 顶点标定的无向图，按标定顺序列出每个顶点的度数，即是该图的度数列（唯一）. 度满足的基本关系 0≤deg(u)≤p−10\\leq deg(u)\\leq p-1 0≤deg(u)≤p−1 邻域 对于无向图 G=(V,E)G=(V,E)G=(V,E) ，∀u∈V\\forall u\\in V∀u∈V ，uuu 的邻域 NG(u)N_G(u)NG​(u) 指的是与 uuu 直接相连的所有顶点的集合，uuu 的闭邻域 $\\bar{N}_G\\left( u \\right) $ 则是邻域再加上 uuu 本身。 $N_G\\left( u \\right) =\\left{ v|v\\in V\\land \\left( u,v \\right) \\in E\\land u\\ne v \\right} $ $\\bar{N}_G\\left( u \\right) =N_G\\left( u \\right) \\cup \\left{ u \\right} $ 对于有向图 D=(V,E)D=(V,E)D=(V,E) ，它的邻域就是先驱和后继元集的并集，闭邻域定义与无向图类似，加上自己即可。 先驱和后继元集 这是有向图专用概念。对于有向图 D=(V,E)D=(V,E)D=(V,E)，∀u∈V\\forall u\\in V∀u∈V ，uuu 的先驱元集指的是直接通过有向边指向 uuu 的所有顶点的集合，后继元集则指的是 uuu 通过有向边直接指向的所有顶点的集合。 先驱元集：$\\varGamma _{D}^{-}\\left( v \\right) =\\left{ u|u\\in V\\land &lt;u,v&gt;\\in E\\land u\\ne v \\right} $ 后继元集：$\\varGamma _{D}^{+}\\left( v \\right) =\\left{ u|u\\in V\\land &lt;v,u&gt;\\in E\\land u\\ne v \\right} $ 边与点的关系 关联 若 ek=(vi,vj)e_k=(v_i,v_j)ek​=(vi​,vj​) 或 ek=&lt;vi,vj&gt;e_k=&lt;v_i,v_j&gt;ek​=&lt;vi​,vj​&gt; ，称 eke_kek​ 与 vi(vj)v_i(v_j)vi​(vj​) 关联，即边与点关联。 相邻 点相邻：两顶点之间有边连接，则称这两个顶点相邻 边相邻：两条边中，一条边的终点是另一条边的起始点，则这两条边相邻 平行边 无向图中关联两个顶点的边如果多于 1 条，则这些边都称为平行边，平行边的条数称为重数。 三、图的种类 平凡图 只有一个顶点的图 空图 V(G)=∅V(G)=\\varnothingV(G)=∅，即一个顶点都没有的图 零图 ∣E(G)∣=0|E(G)|=0∣E(G)∣=0，即没有边的图，nnn 阶零图记作 NnN_nNn​ 基图 基图的概念附属于有向图。将给定的有向图的所有边去掉方向之后，得到的便是该有向图的基图。 简单图 不含平行边也不含环的图 多重图 含平行边的图 rrr-正则图 所有顶点的度都等于 rrr 的图 完全图 KnK_nKn​ 给定图 G=(V,E)G=(V,E)G=(V,E) ，每个顶点都与其余 (n−1)(n-1)(n−1) 个顶点相连，这样的图称为 nnn 阶完全图，即 KnK_nKn​ nnn 阶完全图的总边数为 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 圈图 CnC_nCn​ 轮图 WnW_nWn​ 圈图中央加一个“总站” 四、路 通路 图中任一顶点与边的交替序列称为通路 回路 起点和终点相同的通路 简单通路 边不重复的通路 复杂通路 边有重复的通路 简单回路 起点和终点相同的简单通路 复杂回路 边有重复的回路 初级通路 / 路径 点不重复、边也不重复的通路 初级回路 / 圈 起点和重点相同的路径。长度为奇数的圈称奇圈，否则称偶圈。 长为 1 的圈只能是环，长为 2 的圈只能由平行边生成，因此圈的长度至少为 3. 欧拉通路 不重复地遍历每一条边（顶点可以重复）的通路 欧拉回路 起点和终点相同的欧拉通路 哈密顿通路 遍历每个顶点且不走重复边的通路 哈密顿回路 起点和终点相同的哈密顿通路 五、图的关系 子图 V'\\subseteq V \\and E'\\subseteq E，则 G′G'G′ 为 GGG 的子图（先从 GGG 的点集中挑若干个点组成新的点集，再从原图中与这些点关联的边集中挑若干条边，这样生成的新图 G′G'G′ 就是子图） 母图 子图的相对概念 真子图 V'\\subset V \\and E'\\subset E（改成真子集），其余同子图概念定义 生成子图 V' = V \\and E'\\subseteq E，简单来讲，即顶点数不减少的子图 导出子图 1. 由点集导出的子图 设 V′⊆VV'\\subseteq VV′⊆V，∀u,v∈V′\\forall u,v\\in V'∀u,v∈V′ ，若 (u,v)∈E(u,v)\\in E(u,v)∈E，则有 (u,v)∈E′(u,v)\\in E'(u,v)∈E′，并称 G′=(V′,E′)G'=(V',E')G′=(V′,E′) 为 GGG 由 V′V'V′ 导出的子图. 即：从原图中挑若干个点作为导出子图的点集，将新点集中的点两两配对，检查每个点对的边是否在原图中有，如果有，那导出子图也必须有. 2. 由边集导出的子图 设 E′⊆EE'\\subseteq EE′⊆E，∀(u,v)∈E′\\forall (u,v)\\in E'∀(u,v)∈E′，若 u,v∈Vu,v\\in Vu,v∈V，则有 u,v∈V′u,v\\in V'u,v∈V′，并称 G′=(V′,E′)G'=(V',E')G′=(V′,E′) 为 GGG 由 E′E'E′ 导出的子图. 即：从原图中挑若干条边作为导出子图的边集，新边集中关联到的所有点，导出子图必须有. 🔒 重要定理 握手定理 给定无向图 G=(V,E)G=(V,E)G=(V,E) ，所有顶点的度数之和等于总边数的一半。换句话说，每条边对度数总和的贡献为 2。 ∑u∈Vdeg(u)=2q\\sum_{u\\in V}^{}{deg\\left( u \\right) =2q} u∈V∑​deg(u)=2q 有向图也满足上述结论，并且还满足所有顶点的入度之和等于出度之和（所谓有入必有出）。 ∑u∈Vdeg−(u)=∑u∈Vdeg+(u)=q\\sum_{u\\in V}^{}{deg^{-}\\left( u \\right)} =\\sum_{u\\in V}^{}{deg^{+}\\left( u \\right)} = q u∈V∑​deg−(u)=u∈V∑​deg+(u)=q 握手定理推论 任何图中，奇度顶点的个数必定为偶数. 证明简述 给定一个图 G=(V,E)G=(V,E)G=(V,E) ，将点集 VVV 按度数分成 V奇V_{奇}V奇​ 和 V偶V_{偶}V偶​ 两部分，由握手定理可知，所有顶点度数之和为边数的两倍，即所有顶点的度数和为偶数，而属于 V偶V_{偶}V偶​ 这部分顶点的度数和必然为偶数（若干个偶数和必为偶数），那么想要让总度数和为偶数的话，V奇V_{奇}V奇​ 部分的所有顶点度数和必须为偶数，而因为 V奇V_{奇}V奇​ 部分的每个顶点度数都是奇数，所以 ∣V奇∣|V_{奇}|∣V奇​∣ 就必须是偶数（偶数个奇数的和才能是偶数），结束。 可图化判定 给定一个度数列，它是可图化的，当且仅当 ∑i=1pdeg(ui)\\sum_{i=1}^{p}deg(u_i)∑i=1p​deg(ui​) 为偶数 判定简单图的必要条件 Δ(G)≤n−1\\Delta(G)\\le n-1Δ(G)≤n−1 Ramsey 定理 6 个人当中，或有 3 个人互相认识，或有 3 个人互相不认识 连通性判定 欧拉回路的判定 含有至少 2 个顶点的连通多重图具有欧拉回路，当且仅当它的奇度顶点个数为 0. 欧拉通路的判定 连通多重图具有欧拉通路但无欧拉回路，当且仅当它恰有 2 个奇度顶点. 哈密顿回路的判定 1.完全图的哈密顿回路 当 n≥3n\\ge3n≥3 时，KnK_nKn​ 有哈密顿回路 2.欧尔定理 如果 GGG 是有 nnn 个顶点的简单图，且 n≥3n\\ge3n≥3 ，并且对于 GGG 中每一对不相邻的顶点 uuu 和 vvv 来说，都有 deg⁡(u)+deg⁡(v)≥n\\deg(u)+\\deg(v)\\ge n deg(u)+deg(v)≥n 则 GGG 有哈密顿回路. 3.狄拉克定理 如果 GGG 是有 nnn 个顶点的简单图，且 n≥3n\\ge3n≥3 ，并且 GGG 中每个顶点的度都至少为 $\\lceil \\frac{n}{2} \\rceil $ ，则 GGG 有哈密顿回路. 个人理解：欧尔定理要求在图中随便挑两个不相邻顶点，它们“配合”的度数要足够大，而狄拉克定理可看作是将这种“配合”平均分担到每一个顶点身上，算是欧尔定理的推论. 哈密顿回路的否定 如果图中存在度为 1 的顶点，则该图必定没有哈密顿回路. 💡 经典问题 中国邮递员问题 在图中找出一条回路，使得该回路以最少的边数（或者边权之和最小）至少遍历每条边一次. 旅行商问题 Traveling Salesman Problem 一个旅行商人想要拜访 nnn 个城市，每个城市只能拜访 1 次（除出发点外），最后回到出发的城市，要求找出一条路径，使得路径总和最小.","link":"/cjpark/2020/12/11/graph_notes/"},{"title":"Java 学习日记","text":"记录 Java 学习之路的点点滴滴 2020/12/06 面向对象基础 6 多态性 父类的引用指向子类的对象 该对象的方法列表与父类相同 当该对象调用它的某个方法时，若该方法被子类重写过，则实际执行的是子类的方法 多态是方法的多态，与属性无关 2020/12/05 是的，今天太nm忙了，没学💔 2020/12/04 面向对象基础 5 方法的重写 子类继承父类之后，可以重写父类的同名同参方法 重写方法的权限修饰符不允许降级 父类中的私有方法不允许子类重写 假设被重写方法的返回值为 A 类型，则重写方法的返回值类型只能是 A 或 A 的子类（若是基本数据类型则必须严格相同） 重写方法抛出的异常类型不大于被重写方法的抛出异常类型 静态方法不可以被重写 @Override 注解 super 与 this 关键字 父类和子类的属性可以同名（没有覆盖之说） 用 this 调属性时，先从本类找起，找不到再逐步往上去父类找 用 super 调属性时，跳过本类，从直接父类开始往上找，直到找到为止 super() 表示直接调用父类构造器 2020/12/03 JDBC Client / Server 和 Browser / Server 架构的对比 JavaWeb 知识框架概览 数据库 MySQL 安装与基本配置 SQL 的基本查询语句学习 2020/12/02 面向对象基础 4 继承性 extends 关键字 父类 (SuperClass) 与子类 (SubClass) 直接父类与间接父类 继承内容包括父类的属性和方法 Java 只支持单继承和多层继承（即子类的父类最多只能有一个，与人类社会规则相似） 自定义类默认继承于 java.lang.Object 类 IDEA 中快捷键 Ctrl + H 可调出 Hierarchy 视图查看继承树 项目二 客户信息管理系统 MVC 模式简单实践 Customer 类封装数据对象 CustomerList 类负责对象管理与增删改查等逻辑 CustomerView 类负责视图界面与用户响应 2020/12/01 面向对象基础 3 import static 关键字 用于导入某个包下的静态结构 例如 import static java.lang.Math.* 之后可以不用再写 Math. import 关键字 用于导入某个包下的指定类/接口（不包括子包中的结构） 写在导包语句的后面 使用 .* 代表导入包内的所有类/接口 java.lang 包的导入默认省略 若要使用不同包下的同名类，则在类名前面加包名即可 package 关键字 使用包管理类 声明在每个下属类文件的首行 命名中 . 代表文件目录层级 同一包下的类和接口不允许出现同名 JDK 提供的常用包 Package Name Classes Included java.lang String，System，Math，Object 等核心类 java.util 日期日历、集合框架等实用工具类 java.io 输入/输出功能类 java.net 与网络有关的操作接口 java.sql 进行 JDBC 数据库编程的有关类和接口 java.awt 用于构建 GUI 的有关类 java.text 格式化相关类 this() 调用构造器 高级构造器调用低级构造器，减少代码冗余 若要调用必须写在第一行 this 关键字 在方法内部使用，表示方法所属对象的引用 在构造器内部使用，表示正在构造的对象 UML 类图 JavaBean（符合以下标准的类） 类是公共的 有一个空参的构造器 有属性以及对应的访问器和设置器 构造器 Constructor 未自定义构造器时，系统默认提供空参构造器，一旦自定义，那么系统不会再提供，空参构造器也要自己写 不应理解为特殊的方法 可以设置权限 可重载，用于创建对象、初始化属性 类的属性的封装 权限 设置为 private 不允许直接访问和修改 访问器 提供公共的 getVal 方法获取值 设置器 相比直接调属性赋值，设置器可以提供检查输入规范的入口，防止出现非法数据赋值 IDEA 右键空白处 Generate 可以一键生成 Getter and Setter 权限修饰符 类的内部 同一个包下 不同包的子类 同一个工程 private √ (default) √ √ protected √ √ √ public √ √ √ √ Class 只能被 public 或 (default) 修饰，(default) 类跨包不可用 总结：跨包仅 public 可见，包内 (default) 与 public 可见. 2020/11/30 面向对象基础 2 构造器 Setter 类要写在主类外面才能用 this 访问器 Getter 对象数组的内存解析 栈空间存数组首地址，堆空间存数组内容 数组元素的值为对象的地址（地址中包含了对象的类型） 匿名对象 直接调用仅限一次 常用于方法传参 自定义工具类 将自己常用的函数封装到自己的类库中 只要在同一个 package 下就可以调用 调用前需要先 new 一个 工具类对象 方法的重载 同名方法，参数类型/个数不同 可变个数的形参 public void method(String ... strs) {} 可变个数指的是 0 个 ~ 多个 一个方法最多传一个可变形参 必须放在参数列表最后一个 会与数组传参的方式冲突（两者不构成重载） 在函数内需要遍历时直接当作数组来操作 引用和传参 参数传递都是值传递 基本数据类型传数据值，引用数据类型传地址值 对象之间赋值，只是赋地址，指向堆空间中同一个对象 关于 println() 方法 传入参数为非 char 数组名时，打印出来的是首地址值 传入 char[] 数组名时，由于 PrintStream 库中 println() 方法单独对字符数组做了重载，打印出来的结果是整个字符数组的所有元素连在一起组成的字符串 2020/11/29 面向对象基础 1 与面向过程的区别 面向过程注重事件和函数 面向对象注重类和对象的抽象设计 类和对象 属性和方法 对象的引用 对象的内存解析 栈空间存放引用和地址 堆空间存放数据块 成员变量和局部变量 局部变量没有权限修饰符 局部变量没有默认初始化值 非 static 属性加载到堆空间，局部变量加载到栈空间 常见数组异常 ArraysIndexOutOfBoundsException 下标越界 NullPointerException 空指针异常 常用数组方法 Arrays.equals(int[] a, int[] b) 判断两数组是否相同 Arrays.fill(int[] arr, int val) 以指定值填充数组 Arrays.toString(int[] a) 转换为便于输出的字符串 Arrays.sort(int[] a) 底层为快排 Arrays.binarySearch(int[] a) 二分查找 一维、二维数组的内存解析 栈空间放地址 堆空间放内容 二维数组声明时第一维长度不能省略 二维数组内容为地址 垃圾回收机制检测没有指针指向的内存进行回收 2020/11/28 InteliJ IDEA 2020 安装与基本配置 IDEA Key Map 常用 IDEA Templates 自定义 Templates IDEA 连接 Github 进行 Clone、Push、Share IDEA Debugger 断点调试 Step 与变量监视 Evaluate 笔记： 尚硅谷_宋红康_IntelliJIDEA的安装、配置与使用.pdf","link":"/cjpark/2020/11/28/java_learning_log/"},{"title":"LC 387 第一个唯一字符","text":"题目 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 示例： 12345s = &quot;leetcode&quot;返回 0s = &quot;loveleetcode&quot;返回 2 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 用Java自带的 HashMap 容器，建立一个 &lt;Character, Integer&gt; 的哈希表。 第一次遍历字符串时，在表中记录出现的每个字母及出现的次数。 第二次遍历字符串，以串中的每个字母为 Key ，逐个到哈希表中查找对应 Value ，即它在串中的出现次数，一旦发现 Value 为1，则马上返回该字母在串中的索引。 只需要遍历两次字符串，时间复杂度O(n). 收获 第一次使用Java的 HashMap 容器，有点爽… 123456789/*建立一个哈希表*/HashMap&lt;KeyType, ValueType&gt; MyMap = new HashMap&lt;KeyType, ValueType&gt;();/*给哈希表添加键值对*/MyMap.put(KeyType key, ValueType value);/*在哈希表中传入key，返回value值*/MyMap.getOrDefault(KeyType key, ValueType defaultValue); //提供了找不到key时的返回值MyMap.get(KeyType key); //未提供default值 学到的Java的String类方法 123String str;str.charAt(int index); //提供索引，返回串索引处字符str.length(); //获取串长度 代码 Java 12345678910111213141516class Solution { public int firstUniqChar(String s) { HashMap&lt;Character,Integer&gt; record = new HashMap&lt;Character,Integer&gt;(); int len = s.length(); for (int i = 0; i &lt; len; i++) { char tmp = s.charAt(i); record.put(tmp, record.getOrDefault(tmp,0)+1); } for (int i = 0; i &lt; len; i++) { if (record.get(s.charAt(i)) == 1) { return i; } } return -1; }}","link":"/cjpark/2020/11/03/first_unique_character_in_string/"},{"title":"LC 125 验证回文串","text":"题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 123输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 整体思路框架 头尾双指针向中间移动，凡是遇到非法字符就跳过，判断所有 有效字符对 是否符合要求，若直到两指针碰面都没有退出函数，说明所给串是回文串。 对大小写字母的处理 在最开始写代码的时候，我通过判断两字符差的绝对值是否为32来实现判断大小写字母是否成对，这样问题是非常大的，当我遇到测试用例 &quot;0P&quot; 时，才意识到，这样判断不出差错的前提是已知这两个字符都是英文字母，否则只要在ASCII码表中随意隔32抽两个字符都可以通过判断。 由上述可知，应该首先判断两个字符都为英文字母，再判断两者差的绝对值为32，才可判定它们是“大小对”。 但实际上有更简单的处理方法，因为我用的“头尾指针法”在一开始就需要将串遍历一次，所以不妨利用这次遍历，顺便将所有英文字母统一成大写字母或者小写字母，这样一来在后续判断中只需要单纯判断两字符是否相等，即可涵盖数字和字母两种情况了。 另外还需要注意的是，ASCII码表中，A~Z 是位于 a~z 之前的，而且很重要的一点是，他们是分开的两个连续块，换句话说，Z 与 a 之间还有若干个非英文字母字符，特别注意！ 双指针的思想 个人感觉在字符串处理中经常用到的“双指针法”的思想根源来自于快速排序算法，这种双指针遍历的方法应该是融会贯通于其中的，以后需要多联想和归纳类似的题目。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142bool isPalindrome(char * s){ //初始检测，若是空串，直接返回true if (*s == '\\0') { return true; } //定义辅助指针作头指针 char* headAsis; headAsis = s; //原指针移动到末尾，作尾指针 //扫描过程中顺便将所有大写字母转换为小写字母，免去后续比较的麻烦 while (*s != '\\0') { if (*s &gt;= 'A' &amp;&amp; *s &lt;= 'Z') { *s += 32; } s++; } s--; //将指向了结束符的尾指针回退1位 while (headAsis &lt; s) { //头尾指针分别检测所指值，若既不是小写字母也不是数字，则继续向中间移动 //移动过程也要注意限制，不能让头指针超过尾指针 while (headAsis &lt; s &amp;&amp; (*headAsis &lt; 'a' || *headAsis &gt; 'z') &amp;&amp; (*headAsis &lt; '0' || *headAsis &gt; '9')) { headAsis++; } while (headAsis &lt; s &amp;&amp; (*s &lt; 'a' || *s &gt; 'z') &amp;&amp; (*s &lt;'0' || *s &gt; '9')) { s--; } //若有效字符对符合要求，各自移动一格，重复循环 if (*headAsis == *s) { headAsis++; s--; continue; } else { //一旦出现不符合要求的字符对，退出 return false; } } //整个循环都没出问题，则为回文串 return true;} 其他解法 使用辅助空间 另开一个辅助字符数组，开始时先遍历原串，将合法字符（数字和字母）复制到辅助串中，复制完毕后，只需判断辅助串是否为简单的回文串即可，优点是简便，缺点是空间复杂度为O(|s|)","link":"/cjpark/2020/11/01/is_palindrome/"},{"title":"数据结构 | 链表","text":"Description: 本文介绍链表的常见操作和题型。 基本操作 以下为下文中提到的链表定义 123456/*Definition for singly-linked list.*/public class ListNode { int val; ListNode next; ListNode(int x) { val = x; }} 一、遍历 链表遍历模板 12345ListNode head;ListNode x;for (x = head; x != null; x = x.next) { /*Operations*/} No.1290 二进制链表转整数 辅助栈法 用辅助栈将链表数据反向取出，按转换算法转成十进制。 12345678910111213141516171819202122class Solution { public int getDecimalValue(ListNode head) { if (head.next == null) { return head.val; } //以下处理的链表长度大于1 int p = 0; int count = 0; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x; for (x = head; x != null; x = x.next) { stk.push(x.val); count++; } int sum = 0; for (int i = 0; i &lt; count; i++) { sum += stk.pop() * Math.pow(2,p); p++; } return sum; }} 移位法 顺序遍历链表，每次将 sum 左移一位，再加上 x.val. 1234567891011class Solution { public int getDecimalValue(ListNode head) { if (head.next == null) return head.val; int sum = 0; ListNode x; for (x = head; x != null; x = x.next) { sum = (sum &lt;&lt; 1) + x.val; } return sum; }} No.876 链表的中间节点 操作方法 此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。 代码实现 123456789101112131415class Solution { public ListNode middleNode(ListNode head) { if (head.next == null) return head; //单元素链表，返回自己 if (head.next.next == null) return head.next; //以下处理的链表长度至少为3 ListNode slow, fast; slow = head; fast = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; }} 拓展 如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。 剑指Offer 22. 返回链表倒数第k个节点 两次遍历法 先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。 1234567891011121314151617class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode x; int count = 0; for (x = head; x.next != null; x = x.next) { count++; } x = head; for (int i = 0; i &lt;= count - k; i++) { x = x.next; } return x; }} 定距同步双指针 开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。 12345678910111213141516171819class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode p1; ListNode p2; p1 = head; p2 = head; for (int i = 0; i &lt; k; i++) { p2 = p2.next; } while (p2 != null) { p1 = p1.next; p2 = p2.next; } return p1; }} 二、插入 三、删除 No.237 删除链表中的给定节点 操作方法 此题传入参数为要删除的节点，这意味着我们无法访问之前的节点，也就无法通过修改前面节点的指向来实现删除。 对于链表这种不连续存储的数据结构来讲，我们只关心它存储的值，所以我们可以有如下操作。 不妨记传入的欲删除节点为 x ，它后面的两个节点依次为 y , z。 先将 y 的 val 赋给 x，再将 x 指向 z ，即可删除 y 。 代码实现 123456class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; }} No.83 删除排序链表中的重复元素 快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。 1234567891011121314151617181920212223242526272829303132333435class Solution { public ListNode deleteDuplicates(ListNode head) { //针对长度0、1、2的链表写特判 if (head == null) return head; if (head.next == null) return head; if (head.next.next == null) { if (head.val == head.next.val) { head.next = null; return head; } else { return head; } } //快慢指针 ListNode slow, fast; slow = head; fast = head; while (fast.next != null) { while (slow.val == fast.val &amp;&amp; fast.next != null) { fast = fast.next; } if (fast.next != null) { slow = slow.next; slow.val = fast.val; } } if (fast.val &gt; slow.val) { //注意，此处只有写大于号才能准确判定还有未出现的数需要前移 slow = slow.next; slow.val = fast.val; } slow.next = null; return head; }} 四、反转 剑指Offer 06. 从尾到头打印链表 使用辅助栈，遍历链表，全部压入再逐个弹出。 12345678910111213141516class Solution { public int[] reversePrint(ListNode head) { Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x; int len = 0; for (x = head; x != null; x = x.next) { stk.push(x.val); len++; } int[] rec = new int[len]; for (int i = 0; i &lt; len; i++) { rec[i] = stk.pop(); } return rec; }} 剑指Offer 24. 反转链表 辅助栈法 123456789101112131415class Solution { public ListNode reverseList(ListNode head) { if (head == null) return null; if (head.next == null) return head; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x,y; for (x = head; x != null; x = x.next) { stk.push(x.val); } for (y = head; y != null; y = y.next) { y.val = stk.pop(); } return head; }} 原地反转（三指针法） 12345678910111213141516171819202122232425class Solution { public ListNode reverseList(ListNode head) { /*使用三根指针是为了在改变next过程中保证衔接*/ if (head == null) return null; if (head.next == null) return head; //以上特判已经排除链表长度小于2的情况 //三指针同步向前移动 ListNode pre, cur, fu; pre = null; cur = head; fu = head.next; while (fu != null) { cur.next = pre; pre = cur; cur = fu; fu = fu.next; } //while结束后，最后一个节点尚未反转 //反转尾节点 cur.next = pre; return cur; }}","link":"/cjpark/2020/11/20/linked_list/"},{"title":"LC 14 最长公共前缀","text":"题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot; 。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 1234输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。说明: 所有输入只包含小写字母 a-z 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 整体思路框架 采用逐个串扫描（横向扫描）的方法，先扫描第一个与第二个串，获取它们的公共前缀，再将此公共前缀串与第三个串比较，更新公共前缀，然后与第四个，第五个比较… 小优化 同样是逐串扫描，但不额外开辟空间来存放串与串比较得到的公共前缀串，而是使用一个整型变量 max_len 来记录和更新公共前缀的长度。 开局初始化 max_len 为第一个串的长度，然后与第二个串比较，更新 max_len ，然后比较第二、三个串（比较过程中只比较前 max_len 长度的部分，后面不理会）更新 max_len ，以此类推。 如此一来，max_len 必然越来越小，一般情况下可以大量减少位于后面的串的扫描次数，提高效率。 性能 时间复杂度 O(mn) ，m为字符串平均长度，n为字符串个数。 空间复杂度 O(1) ，使用的辅助空间不随数据规模改变。 Leetcode提交记录 用时 0ms，击败 100% 的 C语言 选手 空间 5.3MB , 击败 17% 的 C语言 选手 收获 char**strs 实际上是 (char*)* strs ，也就是说，一维数组 strs 是字符指针数组，它的每个元素都是一个字符指针——在本题中是一个字符串的首地址。 提供字符串指针（不允许改动），要求获取字符串长度——可以复制一个指针副本，移动指针副本来遍历字符串，再加一个计数变量，即可获取串长。 学会将问题分解成子问题，将子问题写成独立的函数，简化整体函数书写时的思维负担。 一定要注意函数异常出口的书写 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778int max_len = 0; //记录扫描到目前为止所允许的最大前缀长度int asis_max_len = 0; //辅助变量，记录每次比较两串时得到的公共前缀长度/*传入两个串的首地址，返回两串的最大公共前缀长度*/int GetSamePrefix(char* a, char* b){ int same_len = 0; //异常出口，给空串则返回空串 if (*a == '\\0' || *b == '\\0') { return 0; } //a,b串都没到末尾，且扫描长度不可以超过之前记录的max_len while (*a != '\\0' &amp;&amp; *b != '\\0' &amp;&amp; same_len &lt;= max_len) { if (*a == *b) { same_len++; a++; b++; } else { return same_len; } } return same_len;}//传入串地址，获取串长度，在主函数里用于初始化max_lenint GetStrlen(char* str){ char* str_copy; str_copy = str; //避免对原指针造成改动 int len = 0; while (*str_copy != '\\0') { len++; str_copy++; } return len;}char * longestCommonPrefix(char ** strs, int strsSize){ char** asis; asis = strs + 1; //辅助指针，与提供的指针并排前进（快一步） char* result; //后面用于存放前缀串地址，作返回值 //临界情况函数出口，给空串返回空串，只给一个串就返回该串 if (strsSize == 0) { return &quot;&quot;; } if (strsSize == 1) { return *strs; } max_len = GetStrlen(*strs); //初始化max_len为第一个串的长度，否则max_len一开始就是0，比较两串的子函数就无法执行 for (int i = 0; i &lt; strsSize-1; i++) { //用辅助变量记录每一次比较两串的得到的最大公共前缀长度 asis_max_len = GetSamePrefix(*strs,*asis); //比较max_len与辅助变量，若更小则赋给max_len，因为max_len只能越来越小 //容易犯的错误是：没有使用辅助变量，max_len更新被覆盖，可能会变大 if (max_len &gt;= asis_max_len) { max_len = asis_max_len; } //若到了某个位置获取的max_len为零，说明出现了一个老鼠屎，毁了一锅字符串 if (max_len == 0) { return &quot;&quot;; } else if (i == strsSize-2) { //如果坚持到了最后两个串，就该出结果了 //题目说要返回最大前缀串的地址，这里没有开新的串，而是利用max_len截取最后一个串的前缀，拷贝到倒数第二个串（因为倒数第二个串长度肯定大于等于前缀，不会越界），再末尾加上结束符，相当于临时用倒数第二个串“接住”了前缀，再利用strncpy()来返回它的地址即可。 result = strncpy(*strs,*asis,max_len); *(*strs+max_len) = '\\0'; return result; } else { //如果还有机会(max_len不为0)，又还没到最后，就继续移动 asis++; strs++; } } return &quot;&quot;; //这个出口不可能达到，但是如果不写，测试会报错，随便写一个} 其他解法 纵向扫描 先看第一个字符，将所有串的第一个字符全部扫描一遍并比较，看是否完全相同，若完全相同则进入下一个字符，以此类推。时间复杂度和空间复杂度均与横向扫描相同。（引用Leetcode的图解） 分治+递归 待补充 二分查找 待补充","link":"/cjpark/2020/11/02/longest_common_prefix/"},{"title":"MySQL 学习笔记","text":"本文记录笔者学习 MySQL 的过程和笔记 下载和安装 Community Server 免费 https://dev.mysql.com/downloads 术语 Term Description Remarks DB Database DBMS Database Management System 如 MySQL RDBMS Relational Database Management System 关系型数据库管理系统 DBA Database Administrator SQL Structure Query Language DDL Data Definition Language 如 CREATE，ALTER，DROP DML Data Manipulation Language 如 SELECT，INSERT DCL Data Control Language 命令 检查安装状态 1mysql --version 服务启动与停止 启动服务 1net start mysql0130 # your sql service name 停止服务 1net stop mysql0130 登录 命令行 1mysql -h 主机名 -P 端口号 -u root -p 基本操作 12345678910111213141516171819202122# 查看所有数据库SHOW DATABASES# 打开指定数据库USE 数据库名# 查看当前数据库的所有表SHOW TABLES# 查看非当前库的所有表SHOW TABLES FROM 数据库名# 查看表结构DESC 表名# 在当前库中创建表CREATE TABLE 表名( 列名 数据类型, 列名 数据类型, ...) 常用数据类型 DataType Expression 整型 int 字符串 varchar(max_size) SELECT 语句 123456789101112131415161718192021222324252627282930313233# 选择所有SELECT * FROM 表名# 选择指定列SELECT 列名1,列名2... FROM 表名# 选择所有互不相同的值SELECT DISTINCT 列名 FROM 表名# 选择某字段满足一定条件的行SELECT * FROM 表名 WHERE 与字段相关的条件表达式# 多条件选择SELECT * FROM 表名 WHERE (条件1 AND 条件2) OR 条件三# 枚举范围内选择SELECT * FROM 表名 WHERE 字段 IN (值1, 值2, ...)# 区间范围内选择SELECT * FROM 表名 WHERE 字段 BETWEEN 值1 AND 值2# 模糊选择SELECT * FROM 表名 WHERE 条件 LIKE 带通配符的表达式SELECT * FROM 表名 WHERE 条件 NOT LIKE 带通配符的表达式# 限制选择的条目数SELECT * FROM 表名 WHERE 条件 LIMIT 最多显示记录条数# 查询常量/表达式SELECT 常量/表达式# 给查询字段起别名SELECT 字段1 AS 字段1别名, 字段2 AS 字段2别名 ... FROM 表名 WHERE 条件 INSERT 语句 12345# 在指定表中插入完整新行INSERT INTO 表名 VALUES(值1,值2...)# 在指定表中插入新行并指定某些列的数据INSERT INTO 表名 (列1,列2...) VALUES(值1,值2...) UPDATE 语句 12# 更新指定位置数据UPDATE 表名 SET 字段名 = 新值 WHERE 条件表达式 DELETE 语句 12345# 删除指定行DELETE FROM 表名 WHERE 条件表达式# 删除所有行DELETE * FROM 表名 其他语句 12# 查看 MySQL 版本SELECT VERSION() 通配符 % 代替一串任意长度的字符 _ 代替一个字符 [ABC] 代替“A或B或C” [!ABC] 上述结果取反 [charlist] 通配符在 MySQL 中不适用，若需要则必须使用正则表达式 关于 + 号 不像 Java 中那样，SQL 表达式中的 + 只充当运算符，没有连接符功能 两个操作数都是数值型，则做加法运算 若操作数中有字符型，则将字符型转换为数值，若转换不成功，就当作 0 一旦操作数中有 null 则运算结果必定为 null 常用函数 1234567# 连接若干个字符串COMCAT(字符串A, 字符串B, ...)/* * 例如，将 first_name 和 last_name 字段合并，中间加空格 * SELECT COMCAT(first_name, ' ', last_name) FROM mytable */ 细节规范 SQL 对大小写不敏感，但建议关键字大写，具体数据名小写 字符串由单引号包围 单行注释用 #，多行注释与 java 相同 SQL 中不区分字符和字符串","link":"/cjpark/2020/12/03/mysql_note/"},{"title":"LC 434 字符串中的单词个数","text":"题目 You are given a string s , return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters. Example 1: 123Input: s = &quot;Hello, my name is John&quot;Output: 5Explanation: The five segments are [&quot;Hello,&quot;, &quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;John&quot;] Example 2: 12Input: s = &quot;Hello&quot;Output: 1 Example 3: 12Input: s = &quot;love live! mu'sic forever&quot;Output: 4 Example 4: 12Input: s = &quot;&quot;Output: 0 Constraints: 0 &lt;= s.length &lt;= 300 s consists of lower-case and upper-case English letters, digits or one of the following characters &quot;!@#$%^&amp;*()_+-=',.:&quot;. The only space character in s is ' '. 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/number-of-segments-in-a-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 既然题目说只要不是空格的都算字符，那此题本质上等价于：提供一个只有 0 和 1 两种元素的字符串（数组），找出连续的 1 串的个数。 将串以【字符段】和【空格段】分成若干片段，为这两种片段分别设置不同的入口，分别处理。在【字符段】切换到【空格段】的时候给计数器加一。 最后额外处理临界情况——字符串以【字符段】结束的情况。 由于只遍历字符串一次，因此时间复杂度O(n)，空间复杂度O(1) Leetcode提交 时间性能击败 100% 的 C 提交者 空间性能击败 11% 的 C 提交者 代码 123456789101112131415161718192021222324252627282930313233343536int countSegments(char * s){ int count = 0; //统计单词个数 //特殊情况出口 if (*s == '\\0') { return 0; } //外层循环推进整体扫描 while (*s != '\\0') { //内层循环对[字符段]-[空格段]交替处理 //while处理字符段 while (*s != ' ' &amp;&amp; *s != '\\0') { //只要遇到字符就推进 s++; //字符推进被空格截断则更新统计 if (*s == ' ') { count++; break; //更新完跳出循环，切换到对空格段的推进 } } //if处理空格段 if (*s == ' ') { s++; } } //整体扫描完成后，将指向结束符的指针回退一格 s--; //若串的最后以字符结束，需要特殊处理 if (*s != ' ') { count++; } return count;} 其他解法 待补充","link":"/cjpark/2020/11/02/num_of_segments_in_string/"},{"title":"VSCode配置Python环境","text":"本文介绍 VS Code 上配置 Python 环境的方法。 主要步骤 安装Python 到官网下载最新版Python并安装。 最后一步请点击 Disable path length limit。 安装完成后可到终端验证，输入 1python --version 出现“用户取消了安装”，则取消勾选“为所有用户安装Python” 安装VSCode插件 到插件商店中安装Python插件。 建立VSCode工作区 建立一个文件夹用作Python的WorkSpace。 用VSCode打开该目录，在该目录下新建一个名为 .vscode 的文件夹。 进入该文件夹中，新建 settings.json 空白配置文件。 选择解释器 VSCode打开刚刚建立的WorkSpace目录后，按 Ctrl + Shift + P ，在弹出的输入框中输入 Python:Select Interpreter 并回车，然后选择刚安装的Python版本即可。 编译运行程序 在 WorkSpace 目录下新建 hello.py 输入 1print(&quot;Hello&quot;) 右键点击编辑器空白处选择“在控制台运行Python程序”，即可在VSCode自带的终端看到运行结果。 参考 可以参考VSCode的官方英文文档，里面给出了配置Python环境的详细指引。 https://code.visualstudio.com/docs/python/python-tutorial","link":"/cjpark/2020/11/04/python_for_vscode/"},{"title":"归纳总结 | 指针","text":"本文介绍 C 语言中的指针和数组相关知识。 基础知识 变量 一个变量具有三项属性： 属性 解释 数据类型 (Element Type) 如 int ，char 地址 (Memory Address) 对于64位计算机来讲，一条内存地址值占8个字节 值 (Value) 变量的“内容” 运算符 &amp;：取地址运算符，可根据值来取地址，在一个值前面加上该操作符，就可以得到其对应的地址 *：取值运算符，可根据地址来取值，在一个地址前面加上该操作符，就可以得到地址中存储的值 指针 (Pivot) 指针的全名，叫作指针变量，既然指针是变量，也就意味着指针具备上述三种属性（类型，地址，值） 类型 123int* pInt; //定义一个用于指向整型变量的指针pIntchar* pChar; //定义一个用于指向字符型变量的指针pIntdouble* pDble; //定义一个用于指向双精度型变量的指针pInt 注意，int*p，int* p，int *p，int * p 是一个意思，但我个人倾向于写成 int* p 的形式，因为这样的定义反映了它的内涵和功能——定义一个用来指向整型变量的指针变量p 地址和值 指针既然是变量，那么它就一定有地址，也有值，指针变量毕竟是个变量，也需要安身之处，所以它有自己的地址，但它特殊就特殊在，它的值也是一个地址，并且它可以访问这个地址所存储的值。 社区人口普查员可以根据手上的登记簿，到自己社区内的人家里去查户口，同时人口普查员自己也住着出租屋，这里的人口普查员就是指针，出租屋就是指针的地址，登记簿就是指针的值，查户口就是根据自己的值（别人的地址）来访问别人地址存储的值。 我们可以运行以下代码测试一下 12345678int a = 3;int* p = &amp;a;printf(&quot;%d&quot;,a); //3 变量a的值printf(&quot;%d&quot;,&amp;a); //6422044 变量a的地址printf(&quot;%d&quot;,p); //6422044 指针变量p的值printf(&quot;%d&quot;,&amp;p); //6422032 指针变量p自己的地址printf(&quot;%d&quot;,*p); //3 指针变量p根据自己的值去访问a，得到a的值printf(&quot;%d&quot;,&amp;*p); //6422044 先取到a的值，再根据a的值取地址 综上所述，指针的本质是——具有访问功能的变量 指针的基本应用 1. 修改实参的值 我们都知道，当我们向函数传递普通变量参数（非数组）时，在函数中操作的实际上是实参的副本——也叫形参，也就是说，在函数中对参数作的改动，都是对形参的改动，不会作用到实参身上。 当我们需要对在函数内部对实参作出改动时，就需要用到指针。 例如常用的交换函数 1234567void Swap (int* a, int* b){ int temp; temp = *b; *b = *a; *a = temp;} 我们传进去的参数是两个地址值，需要注意的是，这与上文所说的并不冲突，传入的地址也被拷贝成副本作为形参，但是这并不影响我们的操作，因为我们不需要修改这两条地址，我们想要修改的，是这两条地址存储的值。 不妨把函数想象成一间只有窗口的小黑屋，里面住着一个刺客，有两个人走到窗口，A向里面喊，我家在北京路1号，B向里面喊，我家在北京路2号，这样一来，黑屋里的刺客会拿小本本记下A、B的地址，然后第二天夜里分别前往A、B的家中，月黑风高处，杀人好时机。这里的刺客就是函数的内容，A、B向屋里喊地址的过程就是“传递参数”，黑屋刺客小本本上的地址就是参数的副本（形参），刺客潜入他俩家中执行暗杀任务，就是根据地址值访问并修改地址存储的值。 2.作多返回值函数的出口参数 当函数需要多个返回值时，只能返回一个值的 return 功能就不够用了，我们可以多设置几个参数，用于接收函数的处理结果，这样的参数叫做函数的“出口参数”，一般来讲，出口参数需要能够修改到实参的值，所以需要一般使用指针变量作出口参数。 举个例子。 123456789101112131415void GetMaxScore (int score[], int length, int* pMaxScore, int* pMaxNumber){ /*Function：获取学生列表中的最高分，并返回最高分学生的学号*/ int max_num, max_score; for (int i = 0; i &lt; length; i++) { if (score[i] &gt;= max) { max_num = i; max_score = score[i]; } } /*函数结束，将结果赋给出口参数，修改实参的值*/ *pMaxScore = max_score; *pMaxNumber = max_num;} 指针和数组 数组的底层知识 1. 数组是一片连续的内存空间，且每个单位内存空间的大小是确定的 例如，定义一个长度为5的整型数组 int a[5] ，由于 int 型数据占4个字节，系统就会开辟一块连续的、占20个字节的内存空间，用于存放数组 a 2. 数组可以通过下标随机访问 与线性表不同，数组可以通过下标值在 O(1) 时间内访问到任何数组内部元素的值，这依赖于数组的内存空间是连续且等大的，这样一来，只要提供数组的首地址和下标值，就可以通过下面的计算，得到数组任意下标位置的地址值，从而在 O(1) 时间内访问到该元素 1234int arr[10];&amp;arr[i] = arr + i * sizeof(int);//arr是数组名，代表数组的首地址//此处的等号不是赋值运算，只为说明计算地址的方法 3. 二维数组的本质 二维数组虽然在逻辑上类似于一个矩阵，但在物理上，它仍然是一个一维数组，也就是由若干个等大单位内存空间组成的一片连续内存空间。 我们不妨把二维数组的每一行看成一个整体（一个一维数组），那么二维数组实际上也是一个一维数组，只不过这个一维数组的每个元素还是一维数组。 但话又说回来，一维数组要怎么“塞进去”呢？ 实际上，二维数组的每个元素值，实际上是对应子数组的地址值。 换句话说，系统开辟了另外的空间来存放子数组的具体值，而这个二维数组相当于是子数组的索引数组。 现在我们来讨论，为什么在声明二维数组时，第二维的长度不能省略？ 有了以上知识的铺垫，这个问题就转换成了一个等价子问题： 为什么在声明一维数组时，数组的长度不能省略？ 答案应该是显然的——否则系统根本不知道应该开辟多长一片连续内存空间来存放这个一维数组。 数组名 = 指针？ 指针和结构体","link":"/cjpark/2020/10/31/pivot_and_array/"},{"title":"数据结构 | 优先队列","text":"本文介绍数据结构——优先队列 代码实现 前置辅助函数 1234567891011121314151617181920212223242526272829303132private boolean less(int i, int j){ return pq[i].compareTo(pq[j]) &lt; 0;}private void exch (int i, int j){ int t = pq[i]; pq[i] = pq[j]; pq[j] = t;}private void swim(int k){ while (k &gt; 1 &amp;&amp; less(k/2,k)) { exch(k/2,k); k = k/2; }}private void sink(int k){ while (2*k &lt;= N) { int j = 2*k; if (j &lt; N &amp;&amp; less(j,j+1)) j++; if (!less(k,j)) break; exch(k,j); k = j; }} 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class MaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt;{ private Key[] pq; private int N = 0; //堆中元素个数 /*创建一个大小为maxN的堆*/ public MaxPQ(int maxN) { pq = (Key[]) neww Comparable[maxN+1]; } /*询问堆是否为空*/ public boolean isEmpty() { return N == 0; } /*询问堆的元素个数*/ public int size() { return N; } /*向堆插入值为val的元素并维护堆*/ public void insert(Key val) { pq[++N] = val; swim(N); } /*删除并返回堆顶元素，交换堆顶与尾部元素，并维护堆*/ public Key delMax() { Key max = pq[1]; exch(1,N); N--; pq[N+1] = null; //防止对象游离 sink(1); return max; }}","link":"/cjpark/2020/11/22/priority_queue/"},{"title":"LC 344 反转字符串","text":"题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-string 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 头尾双指针向中间移动，每移动一次，交换一次，直到指针碰面 代码 Java版 123456789class Solution { public void reverseString(char[] s) { for (int head = 0, tail = s.length-1; head &lt;= tail; head++, tail--) { char tmp = s[tail]; s[tail] = s[head]; s[head] = tmp; } }}","link":"/cjpark/2020/11/03/reverse_string/"},{"title":"《富爸爸穷爸爸》读书笔记","text":"Description: 一本改变底层财富思维的好书。 前置知识 收获 资产和负债 资产把钱放进你的口袋，负债将钱从你的口袋中取走。 富人用现金购置资产，再用资产产生的增值收入来消费。而穷人用现金购买负债，成为金钱的奴隶。 为什么应当把房子看作负债而非资产？ 把大部分钱都用在购置房产上，丢失了大量的现金和投资的机会及其带来的经验 伴随着购置房产而来的各种税收、管理费、物业费增加了大量的支出 房子一直在贬值 如何看待奢侈品？ 奢侈品是对懂得合理投资、积累真正资产的人的奖励 什么是真正的资产？ 不需要我到场就可以正常运作的业务，我拥有他们，但由别人经营和管理 股票 债券 能够产生收入的房地产（例如用于租赁） 票据（借据） 版税（如音乐、手稿、专利、知识产权） 其他任何有价值、可产生收入或有增值潜力的东西 个人的想法 “一无所有”的年轻人的资产项是什么？是精力、知识、业务能力、眼界，还有思维模式。在尚未进入社会工作获得稳定的收入之前，我们应将更多的现金（从父母那儿来的零花钱）用于购买资产，也就是投资自己，例如读书开阔眼界、健身、提升个人形象、发展业务能力、开拓人脉资源等等；将尽可能少的现金用于购买负债，如娱乐设备、不必要的食品、不必要的消费品和不能增值的玩具等等。 财务知识 我们需要丰富以下四个方面的财务知识，作为作出合理投资的基本知识储备。 会计：解读数字的额能力，评估生意的优势和劣势 投资：钱生钱的科学和策略 了解市场：供给与需求的科学 法律：利用合法手段避税，以及在诉讼中获得保护 克服困难 恐惧 不要选择逃避，即便逃避往往最省事 利用恐惧和压力使自己更强壮 愤世嫉俗 选择学会分析现实，而不是只会批评和抱怨 成功者在分析中看到机会，失败者在抱怨中度过一生 懒惰 避免用忙碌掩饰懒惰 贪婪一点儿 太多的贪心不是好事，但一点点贪心可以刺激你不断前行 改掉不良习惯 先支付给自己，再支付给他人，而不是反过来 采取行动 停下手头的活，对它们进行评估和分析 积极阅读和交谈，吸纳新的思想 邀请你想了解领域的专家共进午餐，获取信息 合理利用信息不对称与对方周旋（打电话给我的小猫） 学会到市场上宣传、营销、报价、谈判 经典语录 生活是一门课程，但这门课程并不会用语言来教你，它只是推着你转。在这个过程中，有些人会变得愤怒并把这些气发泄到他的老板或者他爱的人身上，而有些人却从中学会了很多东西，并欢迎生活来推动他们。 恐惧把你推出门外，欲望又开始召唤你。这就是陷阱。 更多的钱只会让你头脑中现金流的方式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。正所谓，“蠢人用蠢钱”。 记住黄金规则：有黄金的人制定规则。 雇员的工作只会使雇主或股东更加富有，而不能使他们自己富有。 人们耗尽一生去关注别人的事业并使他人致富。、 80% 的家庭的财务报表表现的是一份拼命工作、努力争先的图景，然而他们的努力都打了水漂，因为他们购买的是负债而非资产。 真正的奢侈品是对投资和积累真正资产的奖励。 雇员挣钱、纳税，并靠剩下的钱为生；企业挣钱、花钱，并只为剩下来的钱缴税。这是富人钻的最大的法律空子。 金钱不是真实的资产，它只是一种大家都认可的东西。 今天的问题是成千上万的人对自己的欲望或贪婪感到内疚，这是他们在少年时代就养成的陈旧思维。他们渴望拥有生活中那些更美好的东西，但大部分人却下意识地调整了自己的心态，并对自己说：“我不能拥有这个”，或者是“我可付不起”。 “我可付不起”禁锢了你的思想，使你无法进一步思考；“我怎样才能付得起”开启了你的头脑，迫使你去思考并寻求答案。 大部分人让那些债主把沙子踢到脸上，而我决定利用对债主的恐惧使自己变得更加强壮。 如果你知道自己在某一问题上有所欠缺，你就应该找一位本领域的专家或是一本相关的书，马上开始教育自己。 “我志在将每一次灾难转化成机会。”——洛克菲勒 愤世嫉俗者抱怨现实，而成功者分析现实。 我从未见过不曾打丢一球的高尔夫选手，也从未见过不曾伤心过的恋人，更未见过从不亏钱的富人。","link":"/cjpark/2020/12/18/rich_dad_poor_dad/"},{"title":"科学上网教程","text":"备注：我只是推荐一个个人认为价格便宜、稳定性和速度兼具、不需要复杂配置的梯子，没有任何商业挂钩行为，如果大家有更好梯子，欢迎推荐 一、注册账号 1.访问https://www.yahaha.co/ 2.注册账号并登录 **备注：**邀请码不用填，分子式一般按 CHONS 的顺序，如果写对了却没通过往往是元素顺序不规范，调整顺序试试 二、支付宝充值 1.登录进入主页后，找到充值区，点击进入 2.用支付宝扫码充值（这个网站不支持微信支付） **备注：**个人建议输入 16HKD（折合人民币大约13.8元），因为我下面会推荐我个人觉得很好用且正在用的流量套餐，价格为 16HKD/月 （这个网站提供多种不同的流量套餐，可以自主选择，我只是给出推荐） 三、购买套餐 点击左边导航栏的“套餐购买”，会跳转到套餐选择页面，我个人用的是图中圈出的 轻量-月限速 ，大家可以自己选择。 点击购买后弹出“输入优惠码”，不用理会，直接点取消即可。 四、使用方法 1.点击左边导航 用户中心 ，回到主页，向下滑动，找到 教程一览 2.选择 我用SSR ，按照下方步骤操作","link":"/cjpark/2020/11/05/scientific_web/"},{"title":"LC 941 有效的山脉数组","text":"题目 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1] 示例 1： 12输入：[2,1]输出：false 示例 2： 12输入：[3,5,5]输出：false 示例 3： 12输入：[0,3,2,1]输出：true 提示： 120 &lt;= A.length &lt;= 100000 &lt;= A[i] &lt;= 10000 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-mountain-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 先遍历一次数组找到最大元素位置，然后设置双指针，以山峰为起点，分别向左、右滑下，若两者都成功滑到山脚，说明数组是有效的山脉数组。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public boolean validMountainArray(int[] A) { int len = A.length; //特判，长度小于3的直接否定 if (len == 0 || len == 1 || len == 2) return false; int left = 0; //左指针 int right = 0; //右指针 int max_index = 0; //最大数索引 int max = -1; //遍历一次寻找最大元素位置 for (int i = 0; i &lt; len; i++) { if (A[i] &gt; max) { max = A[i]; max_index = i; } } //如果最大数在两侧，则不符合要求 if (max_index == 0 || max_index == len - 1) return false; //初始化左右指针 left = max_index; right = max_index; //左指针滑下山坡，若中途遇到坎，则退出 while (left &gt; 0) { if (A[left-1] &lt; A[left]) { left--; } else { break; } } //右指针滑下山坡，若中途遇到坎，则退出 while (right &lt; len-1) { if (A[right] &gt; A[right+1]) { right++; } else { break; } } //询问两指针位置，若分别在两侧山脚，说明成功滑下，路上没有障碍 if (left == 0 &amp;&amp; right == len-1) { return true; } else { return false; } }} 其他解法 同样设置左右指针，分别从两侧开始“向中间爬”，停在能爬上的最高处，最后判断左山峰和右山峰是否为同一个山峰。","link":"/cjpark/2020/11/03/valid_mountain_array/"},{"title":"安装Ubuntu_20.04时踩过的坑","text":"Here are the various problems I met after successfully installing Ubuntu on my laptop. Cannot Install Language Support The system said that it’s because of lack of dependencies, but actually it is related to my wrong source options. If you have set your sources correctly, the system can fix the problem itself (by sudo apt-get -f intstall) Cannot open software-center Solution: Launch the terminal and input: 1sudo apt install ubuntu-software I guess that in old-version-ubuntu, it is called software-center, but maybe in 20.04, it is called ubuntu-software? Have changed the wrong sources.list The source you choose must be suitable for your Ubuntu version, if the version matches wrong, then everything will go wrong, especially all kinds of error-remindings related to [lack of lib packages] Reference https://blog.csdn.net/YooLcx/article/details/104527734 Lack of many kinds of lib packages Go to 1 How to install flash for firefox install tar.gz from the Adobe unload it copy .co file to /usr/lib/mozilla/plugins/ restart firefox Reference： https://blog.csdn.net/weixin_40522162/article/details/80287296 Frequently-Used Commands sudo means Super User DO sudo gedit {directory/filename} sudo apt-get update sudo apt-get install {package_name} sudo apt-get remove {software_name} sudo cp {file_from_directory} {file_to_directory} sudo dpkg -i {deb_file_name} sudo apt-get -f install (Use it when met with installing problems) sudo apt --fix-broken install (Install the depending packages) cd {directory} sudo {software_name} (To open software directly by terminal) ::: tip When entering a name of a file or directory, you can just enter the necessary previos letters, then just press Tab, the shell will automatically complete the filename ::: Remove Thunderbird It is said that this operation is to solve the “Software Center Broken” Problem. Unable to input Chinese Install fcitx Download Sogoupinyin from its website, then install the .deb file by the terminal https://blog.csdn.net/jiangshuanshuan/article/details/95723237 Lack of libpng12.so.0 Reference： https://blog.csdn.net/weixin_43981229/article/details/106420012?utm_medium=distribute.pc_relevant_ask_down.none-task-blog-blogcommendfrombaidu-13.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_ask_down.none-task-blog-blogcommendfrombaidu-13.nonecas Ubuntu Software database is broken Reference: https://blog.csdn.net/u012406790/article/details/64442834","link":"/cjpark/2020/10/27/ubuntu_problems/"},{"title":"梦想的起点 | 深圳","text":"谨以此文，开启深圳追梦之旅 题记 2018年冬，深圳北站。 孤身一人来到陌生的城市，少年抬起头，看着一抹暖阳洒在“深圳北”的站牌上，稚嫩的脸庞上，写满了懵懂、好奇、憧憬与希望。 2020年9月，深圳南山西丽大学城。 经过3年的磨炼，略显成熟的少年，在他青涩的18岁，紧握着手里的通知书，来到了哈工大（深圳），他紧张地四处张望，寻找着计算机科学与技术学院的新生报到点。 2020年10月，深圳北站。 班级组织活动参观莲花山公园，回校的路上途径深圳北站换乘地铁，看着模样分毫未变的站台和熙熙攘攘的人群，一抹熟悉感涌上心头，想到终于有机会实现两年前与自己约定的梦想，他难以压抑内心的激动，瞬间泪湿了眼眶… 与深圳的初次邂逅 那是2018年的冬天。我还在读高一。背着电脑包，拖着行李箱，第一次一个人坐高铁、出远门，到达一个陌生的城市——深圳。 去深圳干什么？去参加一个冬令营。 依赖于身边OI大佬的指导，通过了大疆RM的笔试和面试，有幸通过选拔成为 2018大疆Robomaster高中生机器人冬令营 的一员。 那是我人生中第一次经历面试、笔试这样的筛选环节，那时候的我什么都不会，只在初中学过一点前端和C++，哪怕非常认真地做了准备，我仍然在电话面试时战战兢兢、一身冷汗。 当时面试官问的问题是： 请你简单讲一下指针。 请你简单介绍一下什么是最小堆、最大堆。 没有学过数据结构和算法的我，在那一刻无比的窘迫，只能老老实实说，我不会。 坦白讲，入营之后几天内，我受到了极大的打击和挫败。 每个队伍内的分工具体是算法、机械和嵌入式三个方向。算法队员负责针对具体题目建模、设计算法并用代码实现；机械队员负责设计和组装整台机器人的机械传动结构；嵌入式队员则负责程序端和机械端的衔接、沟通与嵌入。 队长问我你是什么方向？算法吗？什么是深搜、广搜、二叉树？我不会。机械吗？我连螺丝都拧不利索。我只能跟着队里主攻嵌入式的大佬，帮他看看代码和库函数，然后干一些做PPT、写日志报告的杂活。 当时我真的觉得自己很没用。队里要用Github管理代码，我连命令行都不会；机械老哥要我去拿个电机，我连电机型号都不知道在哪看…更别说什么3D打印、最短路算法设计、调开发板了。（现在回头看来，真的要感谢当时队长和队员们都非常包容我并且耐心地指导我，才让我不至于崩溃） 但话又说回来，正是这段近乎黑暗的经历，带给了我无穷无尽的收获，深刻地影响了我在那之后的选择和道路。 那时候的我， 看着来自五湖四海的大佬们，视觉识别、敏捷开发、机械结构、设计算法，各显神通； 看着表现优异的个别营员，接受各地顶尖大学的现场面试，拿到Offer或降分； 看着大疆RM基地里，各个岗位的工程师，满怀激情地工作； 看着我的队长用高水平的开发成果、惊艳全场的PPT和优秀的演讲表达能力在答辩时征服现场评委，拿到港科大Offer… 有一天干完活在一起吃烧烤，队长向我展示了他的经历——大疆社区优秀飞手、深圳各种科创比赛获奖者、个人网站开发者、魅族手机特约评测写作者…他吸了一口杯里的可乐，跟我说：“你以后想不想出来创业？我特别想创业，我才不想给别人打工。我有信心成为一名全栈工程师。” 那时连函数都还没学懂的我，背着电脑包走在深圳凌晨4点的夜里，看着夜空中的闪亮的星星，就像看到了我内心悄然腾跃而起的火种。 我要考上顶尖大学的计算机系。 我想成为像队长那样酷的开发者。 我要全面发展我的技能（英语、演讲、沟通表达、PPT…） 我想成为一名全栈工程师。 我渴望变强。 我的大学 从那次冬令营回来以后，我又经历了一次成绩排名的暴跌，在家人、学校、班级环境的重重压力下，从每天起早摸黑到中午不睡觉刷题，从周末留校自习到剪断羽毛球拍的拍线，那段时间里，我经历了前所未有的压力和困难，也实现了前所未有的自我突破…后来的两年里，我还算保持了相对自律的习惯，最终在高考取得还算满意的成绩。 在填报志愿的时候，我的原则是非计算机系不读，当时的备选项大概有：同济大学计算机系、华中科技大学计算机系、哈尔滨工业大学（深圳）计算机系、中山大学计算机系、北京理工大学计算机系… 最终我选择了哈尔滨工业大学（深圳），作出这个选择，除了考虑学校、专业、就业等方面之外，要说其中没有对深圳这个城市的活力和氛围的一点点感情的加分，那是不可能的。 重燃火种 入学大概一个多月后，计算机学院组织了一场由两个指定班级参加的校长班会（校长会到场发言和指导），辅导员让我上台作一次演讲，分享我选择计算机专业的初心和对未来的规划与期望。在写演讲稿的时候，我多次提到了那次大疆冬令营对我的启发和影响，我甚至觉得，短短9分钟的演讲，远远不足以表达我内心对此真实而热切的情感… 就在班会后的第二天，班里组织活动去参观莲花山公园，活动结束后，在坐地铁回学校的路上，需要到深圳北站换乘地铁，不变的站牌、依旧拥挤的站台、广播里反复播放的电脑合成女声… 一切都是那么的熟悉，仿佛又回到了两年前。 我还是我，我还背着电脑包。 看着随处可见的“深圳北站”提示牌，一遍又一遍听着站台的“深圳北”提示播音，我有些恍惚，更多的是感慨、激动和自豪。 现在的我，英语口语表达水平、PPT设计制作水平、演讲水平，也算是勉强达到了当初自己对自己的期望。 现在的我，面对当初的那几道算法题，即便不一定能全A，至少应该不至于完全没有思路。 现在的我，也能通过折腾和学习，学会实用Git和Github的基本功能，也能通过 Hexo + Gitee 搭建出属于自己的个人博客了。 现在的我，能够在一流学府的良好氛围中，学习专业知识，追逐自己的梦想了… 感谢一直坚持的自己，感谢我的爸妈和亲人给我的支持和鼓励，我才有机会走到这个平台上。 未来的期望 希望未来四年里，能够不断学习和积累，掌握更多专业的计算机工程技能，成为一名全栈工程师。 深圳，是梦开始的地方。 希望能在深圳，创造自己的未来！","link":"/cjpark/2020/10/27/thought_at_szb/"},{"title":"LC 26 删除排序数组中的重复项","text":"题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) { print(nums[i]);} 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 本题是典型的双指针题型中的快慢指针法，两个指示变量、O(1)额外空间、一次for循环就可以搞定。 慢指针 slow 只有在快指针 fast 遇到新朋友时，才会前进1个单位，同时将新朋友复制到 slow 的当前位置来。 不过，此题能这样做的前提是数组本身有序，有序保证了重复元素必然聚集在一起，而不是分散在各处。 如果重复元素散乱分布，那么判断 fast 当前所指元素是否在之前已经出现过就不仅仅是将 nums[slow] 与 nums[fast] 比较这么简单了。 代码 1234567891011121314151617181920212223242526272829303132class Solution { public int removeDuplicates(int[] nums) { //测试数据一定会有极端，特判和简单情况记得先写 if (nums.length == 0) return 0; if (nums.length == 1) return 1; if (nums.length == 2) { if (nums[0] == nums[1]) return 1; else return 2; } int len = nums.length; int slow = 0; int fast = 1; //此处while条件不能写等号，否则fast移动到末尾之后会进入死循环 while (fast &lt; len - 1) { if (nums[fast] == nums[slow]) { fast++; } else { slow++; nums[slow] = nums[fast]; } } //fast位于末尾时，额外写判断，因为while不处理最后边界情况 if (nums[slow] == nums[fast]) { return slow+1; } else { slow++; nums[slow] = nums[fast]; return slow+1; } //题目要求返回新数组长度而不是索引，所以加一 }}","link":"/cjpark/2020/11/20/remove_duplicates_in_sorted_array/"},{"title":"VuePress部署轻量级个人博客","text":"本文介绍笔者折腾 VuePress 的过程。 1. 安装node.js 到官网下载稳定版安装即可 2. 按照官网指示进行基本安装配置 创建目录 包管理器初始化（yarn, npm二选一） 安装vuepress为本地依赖 创建docs目录，并在下面手动创建README.md package.json添加两条scripts 用npm run docs:dev命令启动服务器 在localhost上初步预览 如果出现显示中文乱码问题，是cmd创建的md文件编码不对，删掉自己建一个即可 3. 创建官网推荐的目录结构（区分大小写） 注意：所有文件的相对路径都相对于docs目录 4. 了解默认路由地址 文件相对路径 页面路由地址 /README.md / /guide/README.md /guide/ /config.md /config.html 注意：如果是要指某目录下默认的README.md，注意目录最后也要加一个斜杠 5. 了解基本原理 md文件放到.docs目录下后，在根目录下执行npm run docs:dev命令，就会在指定的输入目录（默认在../dist目录下）以docs下的文件目录结构为参照，输出相同的目录结构，将对应目录下的.md文件生成html静态页面 6. 什么时候需要重新执行dev命令？ 注意：dev命令是包含了build命令在内的 凡是更改了配置文件/config.js或者其他配置文件的，必须重新执行一次npm run docs:dev，但如果是对已经存在的且已经build过的markdown文件进行更改，本地localhost是可以自动刷新的，不需要重新build或者dev（当然，如果vuepress部署在github或者虚拟主机，当然要重新上传） 每次build，相当于是将docs下的目录结构copy到dist下，再每个目录一一对应地，将md文件转换为静态html页面 7.如何部署到云？ 无论是放到虚拟主机、码云还是github上，都只需要将dist目录下的所有东西（也就是全部的静态页面）扔上去，就可以了，虚拟主机需要放到public_html文件夹下，如果是github需要放到对应的repository下","link":"/cjpark/2020/10/24/vuepress_configurating/"},{"title":"Win命令行常用语句","text":"操作文件和目录 切换到某个目录，用具体路径代替[directory_name] 1cd [directory_name] 在当前操作目录下新建文件夹 1mkdir [new_folder_name] 用Visual Studio Code打开当前文件夹作为工作区 1code . 在命令行中运行当前目录下.exe可执行文件 1.\\[file_name].exe 编译代码源文件 编译当前目录下的.c源码文件为可执行文件，文件名用[file_name]代替，第一个[file_name]为源码文件名，第二个[file_name]为生成的.exe文件的文件名 1gcc [file_name].c -o [file_name] 若要编译C++文件，同理 1g++ [file_name].c -o [file_name] Java源文件编译生成.class文件 1javac [file_name].java 运行java编译生成的.class文件，[class_name]代表主类名 1java [class_name]","link":"/cjpark/2020/10/20/win_powershell_commands/"},{"title":"LC 378 有效的完全平方数","text":"题目 给定一个正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 True ，否则返回 False 。 说明：不要使用任何内置的库函数，如 sqrt 。 示例 1： 12输入：16输出：True 示例 2： 12输入：14输出：False 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-perfect-square 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 二分查找 二分法查找序列 [2,3,...num/2]（如果输入1直接返回 true ），逐个计算当前数的平方，与 num 比较，如果能找到，说明是完全平方数，否则不是完全平方数。 牛顿迭代 相当于要查找 f(x)=x2−numf(x)=x^2-numf(x)=x2−num 的根，用牛顿迭代法。 迭代方程为 f(xk)−0xk−xk+1=f′(xk)\\frac{f(x_k)-0}{x_k-x_{k+1}} = f'(x_k) xk​−xk+1​f(xk​)−0​=f′(xk​) 化简得递推方程 xk+1=xk−f(xk)f′(xk)x_{k+1}=x_k-\\frac{f(x_k)}{f'(x_k)} xk+1​=xk​−f′(xk​)f(xk​)​ 也即 xk+1=(12xk−numxk)x_{k+1}=\\left( \\frac{1}{2}x_k-\\frac{num}{x_k} \\right) xk+1​=(21​xk​−xk​num​) 取 xk=numx_k = numxk​=num 作初始值，用递推式迭代，每次返回 x * x == num 等差数列求和 等差数列 $ a_n = 2n-1 $ 求和 Sn=(1+2n−1)n2=n2S_n = \\frac{(1+2n-1)n}{2}=n^2 Sn​=2(1+2n−1)n​=n2 也即 n2=1+3+5+7+...+(2n−1)n^2 = 1+3+5+7+...+(2n-1) n2=1+3+5+7+...+(2n−1) 利用该性质，从1开始，不断向 num 减去递增的奇数项，每减一次就执行一次判断，判断 num 是否为0，若出现 num 被减成0的情况，说明是完全平方数，否则不是。 代码 最优方法：数列求和法 1234567891011class Solution { public boolean isPerfectSquare(int num) { int i = 1; while (num &gt; 0) { num -= i; i += 2; } if (num == 0) return true; else return false; }}","link":"/cjpark/2020/11/19/valid_perfect_square/"},{"title":"LC 73 矩阵置零","text":"题目 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1: 123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2: 123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/set-matrix-zeroes 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析 (1) 最朴素的想法，遍历矩阵中的每一个元素，检查是否为0 (2) 若是0，则所在行与所在列的所有元素（除0外）全部标记为-99 (3) 标记完后重新遍历矩阵，将值为0或-99的全部设为0 (4) 这里要注意，为什么第2点说标记-99时要排除本身值为0的元素？因为如果一开始同一行或同一列有几个0，如果在找到第一个0时，就用-99标记所在行、列的所有元素，那么所在行列的其他0就会被覆盖掉，继续遍历的时候会被忽略，导致最后有些行列没有清零 代码 12345678910111213141516171819202122232425void setZeroes(int** matrix, int matrixSize, int* matrixColSize){ for (int row = 0; row &lt; matrixSize; row++) { for (int col = 0; col &lt; matrixColSize[0]; col++) { if (matrix[row][col] == 0) { for (int i = 0; i &lt; matrixColSize[0]; i++) { if (matrix[row][i] != 0) { matrix[row][i] = -99; } } for (int j = 0; j &lt; matrixSize; j++) { if (matrix[j][col] != 0) { matrix[j][col] = -99; } } } } } for (int row = 0; row &lt; matrixSize; row++) { for (int col = 0; col &lt; matrixColSize[0]; col++) { if (matrix[row][col] == -99 || matrix[row][col] == 0) { matrix[row][col] = 0; } } }} 改进的解法 (1) 利用首行和首列（姑且称之为“矩阵外围”）作为标记数组，来记录所指的行或列是否需要清零（相当于一个“表头”的作用） (2) 一开始先检查左上角的元素是否为0，决定外围是否需要全部清零（当然外围清零这个操作一定要留到最后） (3) 分别检查外围行和外围列（不包括左上角元素，否则会出现覆盖问题）是否存在0，一旦发现0，开个变量先记为1，意为在程序的最后需要对外围行(列)清零 (4) 遍历内矩阵（即去掉外围的矩阵），每次找到0，就将那个位置所对应的行列“表头”设为0 (5) 再次遍历内矩阵，每到一个位置，就检查该位置对应的表头是否为0，若是，则该位置设为0，一轮遍历下来，内矩阵已经清零完毕 (6) 最后处理外围，根据一开始的记录变量 if_Row0_Need 和 if_Col0_Need 来决定是否清零外围行或列，清零之后，流程结束。 (7) 虽然改该方法时间复杂度仍为O(n^2)，但其中的【表头记录】思想是值得学习的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void setZeroes(int** matrix, int matrixSize, int* matrixColSize){ int row = 0, col = 0; int if_Row0_Need = 0;//记录外围行在最后是否需要清零 int if_Col0_Need = 0;//记录外围列在最后是否需要清零 //对左上角元素先写特判，否则引发覆盖问题 if (matrix[0][0] == 0) { if_Col0_Need = 1; if_Row0_Need = 1; } //初始在第0行查找是否有0，先暂时记录，最后清理 //查找对象不包括左上角元素 for (int i = 1; i &lt; matrixColSize[0]; i++) { if (matrix[0][i] == 0) { if_Row0_Need = 1; } } //初始在第0列查找是否有0，先暂时记录，最后清理 //查找对象不包括左上角元素 for (int j = 1; j &lt; matrixSize; j++) { if (matrix[j][0] == 0) { if_Col0_Need = 1; } } //遍历内矩阵，用第0行与第0列（表头）来记录对应行或列是否需要清零 for (row = 1; row &lt; matrixSize; row++) { for (col = 1; col &lt; matrixColSize[0]; col++) { if (matrix[row][col] == 0) { matrix[0][col] = 0; matrix[row][0] = 0; } } } //再次遍历内矩阵，根据外围（表头）的标记对内矩阵清零 for (row = 1; row &lt; matrixSize; row++) { for (col = 1; col &lt; matrixColSize[0]; col++) { if (matrix[row][0] == 0 || matrix[0][col] == 0) { matrix[row][col] = 0; } } } //最后根据记录变量决定是否清零外围行和外围列 if (if_Row0_Need == 1) { for (col = 0; col &lt; matrixColSize[0]; col++) { matrix[0][col] = 0; } } if (if_Col0_Need == 1) { for (row = 0; row &lt; matrixSize; row++) { matrix[row][0] = 0; } }}","link":"/cjpark/2020/10/20/zero_matrix/"},{"title":"基础算法 | 差分","text":"Description: 差分是实现常数级时间内区间修改的处理手法。 概念 用数列观点来理解，SnS_nSn​ 是 ana_nan​ 的前缀和，而 ana_nan​ 是 SnS_nSn​ 的差分，两者互为逆运算. 构造方法如下 {a1=1ai=Si−Si−1(i≥2)\\begin{cases} a_1=1\\\\ a_i=S_i-S_{i-1}\\left( i\\ge 2 \\right)\\\\ \\end{cases} {a1​=1ai​=Si​−Si−1​(i≥2)​ 应用场景 现有序列 {Sn}\\{S_n\\}{Sn​} ，需要多次对区间 [l,r][l,r][l,r] 上的每个 SnS_nSn​ 加上常数 λ\\lambdaλ，若线性扫描需要 O(n)O(n)O(n)，若用差分只需要 O(1)O(1)O(1) 的时间复杂度. 具体流程 (1) 读入序列 {Sn}\\{S_n\\}{Sn​} (2) 读入完毕后，构造差分序列 {an}\\{a_n\\}{an​} (3) 当需要对区间 [l,r][l,r][l,r] 上的每个 SnS_nSn​ 加上常数 ccc 时，等价于执行 {al+=car+1−=c\\begin{cases} a_l+=c\\\\ a_{r+1}-=c\\\\ \\end{cases} {al​+=car+1​−=c​ (4) 大量执行上述操作的过程中，只修改 {an}\\{a_n\\}{an​} ，不修改 {Sn}\\{S_n\\}{Sn​} (5) 所有操作结束后，再对 {an}\\{a_n\\}{an​} 做一次前缀和，得到 {Sn}\\{S_n\\}{Sn​} 模板 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int MAXN = 1e6 + 10;int a[MAXN]; int difa[MAXN]; //a[i]的差分void diff(int l, int r, int c){ difa[l] += c; difa[r + 1] -= c;}int main(){ cin &gt;&gt; n; //原始序列长度 //读入原始序列 for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; //根据原始序列构造差分序列 for (int i = 1; i &lt;= n; i++) diff(i,i,a[i]); /* 此处执行一系列区间加减操作 */ //对最终修改完毕的差分序列做前缀和，得到原序列 for (int i = 1; i &lt;= n; i++) { a[i] = a[i - 1] + difa[i]; } return 0;} 题目 AcWing 101. 最高的牛 基本思路 h[i] 存放每头牛的最大高度，全部初始化为最大高度 HHH. 给出的每一对关系之间不可能存在交叉，只有可能是相互嵌套，否则可以推出矛盾. 相邻的牛之间可以相互看见，牛与自身也可以相互看见. 给出的关系可能存在重复，所以首先要对给出的所有关系去重，这里选择使用 set&lt;pair&lt;int,int&gt;&gt; 来存储不重复的有序对. 对于每一对给出的有序对，将位于他们之间的牛的高度全部减 1 常规写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;using namespace std;const int MAXN = 1e4 + 10;int N,P,H,M;int h[MAXN]; //用于记录每头牛的最大高度int main(){ cin &gt;&gt; N &gt;&gt; P &gt;&gt; H &gt;&gt; M; //每头牛最大高度都初始化为所给最大值 for (int i = 1; i &lt;= N; i++) h[i] = H; set&lt;pair&lt;int, int&gt;&gt; existed; for (int i = 1; i &lt;= M; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; //保证有序对左小右大，方便处理 if (a &gt; b) swap(a,b); if (existed.count({a,b}) == 0) { //集合里没有才添加 existed.insert({a,b}); //自己或者相邻，不处理 if (b - a == 1 || b - a == 0) {} else { for (int j = a + 1; j &lt;= b - 1; j++) { h[j] -= 1; } } } } for (int i = 1; i &lt;= N; i++) printf(&quot;%d\\n&quot;, h[i]); return 0;} 差分思路 在本题中，每头牛实际上有多高并没有太大的关系，牛与牛之间能否相互看见，取决于它们之间的高度差，抽象化之后，实际上就是对序列 hih_ihi​ 的某个区间 (l,r)(l,r)(l,r) 上每一个数都进行减去 1 的操作，所以考虑用差分优化. 另外，从差分的角度来说，本题的关键在于各头牛高度之间的相对值，所以，理解的思维也可以是相对的，我们可以反过来理解——每当给出一个关系, AAA 和 BBB 可以相互看见，视作保持 A,BA,BA,B 之间的所有牛高度不变，将这些高度不变的牛之外的所有牛，全部抬升一个高度。 差分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;set&gt;using namespace std;const int MAXN = 1e4 + 10;int N,P,H,M;int h[MAXN]; //用于记录每头牛的最大高度int difh[MAXN]; //高度的差分int main(){ cin &gt;&gt; N &gt;&gt; P &gt;&gt; H &gt;&gt; M; //每头牛最大高度都初始化为所给最大值 //只需要将差分第一个设为H即可 difh[1] = H; set&lt;pair&lt;int, int&gt;&gt; existed; for (int i = 1; i &lt;= M; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; //保证有序对左小右大，方便处理 if (a &gt; b) swap(a,b); if (existed.count({a,b}) == 0) { //集合里没有才添加 existed.insert({a,b}); //自己或者相邻，不处理 if (b - a == 1 || b - a == 0) {} else { //对差分端点操作，相当于原高度每个减去一 difh[a + 1] += -1; difh[b] -= -1; } } } //最后再做前缀和得出h[i] for (int i = 1; i &lt;= N; i++) { h[i] = h[i - 1] + difh[i]; } for (int i = 1; i &lt;= N; i++) printf(&quot;%d\\n&quot;, h[i]); return 0;}","link":"/cjpark/2021/03/04/differencing/"},{"title":"基础算法 | 前缀和","text":"Description: 前缀和是处理区间查询的快速手段。 基本概念 一维前缀和 用数列观点理解就是前 nnn 项和，原序列是 ana_nan​，它的前缀和就是 Sn=∑i=1naiS_n=\\sum_{i=1}^{n} a_i Sn​=i=1∑n​ai​ 对于序列 {an}\\{a_n\\}{an​} ，需要查询区间 [l,r][l,r][l,r] 上所有元素的和，一般做法是 O(n)O(n)O(n) 的线性扫描. 但如果需要频繁查询，那么一般先对序列 {an}\\{a_n\\}{an​} 做预处理，做出它的前缀和序列 {Sn}\\{S_n\\}{Sn​}. 当需要区间 [l,r][l,r][l,r] 上的和时，只需要计算 Sr−Sl−1S_r-S_{l-1}Sr​−Sl−1​ ，可在 O(1)O(1)O(1) 内完成. 二维前缀和 可用矩阵来理解（或者看成网格），a[i][j]a[i][j]a[i][j] 存储一个二维数据图，它的前缀和为 S[i][j]=∑i=1n∑j=1ma[i][j]S[i][j]=\\sum_{i=1}^{n} \\sum_{j=1}^{m}a_[i][j] S[i][j]=i=1∑n​j=1∑m​a[​i][j] 简单来说，二维前缀和 S[i][j]S[i][j]S[i][j] 表示矩阵前 iii 行、前 jjj 列的和. 根据原矩阵构造其对应二位前缀和的公式为 S[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j]S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j] S[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j] 构造完二维前缀和后，我们可以方便地求出任意子矩阵的和. 例如求从 (x1,y1)(x_1,y_1)(x1​,y1​) 到 (x2,y2)(x_2,y_2)(x2​,y2​) 的子矩阵和 sumsumsum.（类似容斥原理） sum=S[x2][y2]−S[x1−1][y2]−S[x2][y1−1]+S[x1−1][y1−1]sum=S[x_2][y_2]-S[x_1-1][y_2]-S[x_2][y_1-1]+S[x_1-1][y_1-1] sum=S[x2​][y2​]−S[x1​−1][y2​]−S[x2​][y1​−1]+S[x1​−1][y1​−1] Tips: 当空间非常紧张的时候，可以原地计算前缀和并覆盖原矩阵，即每计算出一个 S[i][j]S[i][j]S[i][j] ，就用它覆盖掉 a[i][j]a[i][j]a[i][j] ，可以省掉另外开一个 S[][]S[][]S[][] 数组的空间开销. 典型例题 P1387 最大正方形 先用二维前缀和预处理地图，然后三重循环，最外层从 min(m,n)min(m,n)min(m,n) 到 111 枚举正方形边长 rrr ，内层枚举坐标，从 (r,r)(r,r)(r,r) 到 (n,m)(n,m)(n,m)，一旦这个区域的前缀和 ans=r2ans = r^2ans=r2 ，直接 breakbreakbreak 并返回边长 rrr. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;const int MAXN = 101;short map[MAXN][MAXN];int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= m; j ++ ) { scanf(&quot;%d&quot;, &amp;map[i][j]); } } for (int i = 1; i &lt;= n; i ++ ) { for (int j = 1; j &lt;= m; j ++ ) { map[i][j] += map[i][j-1] + map[i-1][j] - map[i-1][j-1]; } } int ans; for (int r = min(m,n); r &gt;= 1; r -- ) { for (int i = r; i &lt;= n; i ++ ) { for (int j = r; j &lt;= m; j ++ ) { ans = map[i][j] - map[i-r][j] - map[i][j-r] + map[i-r][j-r]; if (ans == r * r) { printf(&quot;%d&quot;, r); exit(0); } } } } return 0;} [HNOI 2003] 激光炸弹 分析 本题将地图看成网格，点的价值看作矩阵元素的值，抽象之后即：给定一个 5000∗50005000*50005000∗5000 大小的矩阵，求 R∗RR*RR∗R 子矩阵元素和的最大值. 因为计算前缀和过程中会出现 [i−1][j−1][i-1][j-1][i−1][j−1]，为防止越界，地图数据从 (1,1)(1,1)(1,1) 开始记录. 输入矩阵后，预处理，做出二维前缀和，遍历前缀和，记录最大值即可. 注意 此题卡空间，空间最大限制 125 MB. 如果开两个 5000∗50005000*50005000∗5000 的 int 型二维数组（一个记录原地图，一个做前缀和），要用 191 MB. 如果开一个 5000∗50005000*50005000∗5000 的 int 型二维数组放前缀和，再开一个 5000∗50005000*50005000∗5000 的 short 型二维数组放原矩阵（因为原矩阵元素值不超过 1000 ，可用short），总共要用 143 MB. 上述方案都不行. 考虑只开一个 5000∗50005000*50005000∗5000 的 int 型二维数组，先输入原矩阵，然后一边计算前缀和一边覆盖，总共使用内存 95 MB，满足要求. 另外注意边界的处理，边界坐标之间加一减一的关系. 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5010;const int bd = 5001;int N, R;int map[MAXN][MAXN];int res;int main(){ cin &gt;&gt; N &gt;&gt; R; //Input the map (data = value) for (int i = 1; i &lt;= N; i++) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; map[x + 1][y + 1] = w; } //Make the prefix of the map for (int i = 1; i &lt;= bd; i++) { for (int j = 1; j &lt;= bd; j++) { map[i][j] += map[i-1][j] + map[i][j-1] - map[i-1][j-1]; } } //Iterate the prefix for (int i = 1; i &lt;= bd - R + 1; i++) { for (int j = 1; j &lt;= bd - R + 1; j++) { int temp; temp = map[i+R-1][j+R-1] - map[i-1][j+R-1] - map[i+R-1][j-1] + map[i-1][j-1]; res = max(res,temp); } } cout &lt;&lt; res; return 0;}","link":"/cjpark/2021/03/13/prefix_sum/"},{"title":"数据结构实现 | 双链表","text":"本文给出用C语言实现双链表的代码。 基本结构 12345678struct LNode { int data; LNode* l; LNode* r;};typedef struct LNode LNode;typedef struct LNode * LinkList； 操作实现 初始化链表 123456LinkList init_linklist() { LNode* head = (LNode*)malloc(sizeof(LNode)); head-&gt;l = NULL; head-&gt;r = NULL; return head;} 在给定节点后插入新节点 1234567891011//在节点p后插入值为x的节点bool insert_after(LNode* p, int x) { if (p == NULL) return false; LNode* tmp = (LNode*)malloc(sizeof(LNode)); tmp-&gt;data = x; tmp-&gt;l = p; tmp-&gt;r = p-&gt;r; if (p-&gt;r) p-&gt;r-&gt;l = tmp; p-&gt;r = tmp; return true;} 在给定节点前插入新节点 1234//在节点p前插入值为x的节点bool insert_before(LNode* p, int x) { return insert_after(p-&gt;l, x);} 头插节点 123456789//在链表头插入值为x的节点bool add_front(LinkList L, int x) { if (L) { insert_after(L, x); return true; } else { return false; }} 删除给定节点 12345678//删除给出的p节点bool delete_node(LNode* p) { if (!p) return false; if (p-&gt;r) p-&gt;r-&gt;l = p-&gt;l; p-&gt;l-&gt;r = p-&gt;r; free(p); return true;} 获取链表长度 1234567891011//返回链表长度（若只有头节点，长度为0）int get_length(LinkList L) { if (L == NULL || L-&gt;r == NULL) return 0; LNode* iterator = L-&gt;r; int len = 0; while (iterator) { len++; iterator = iterator-&gt;r; } return len;} 链表判空 12345//检查链表是否为空bool isEmpty(LinkList L) { if (L == NULL || L-&gt;r == NULL) return true; else return false;} 顺序打印链表 123456789//从头到尾打印整个链表void print_list(LinkList L) { if (!L) return; LNode* iterator = L-&gt;r; while (iterator) { cout &lt;&lt; iterator-&gt;data &lt;&lt; &quot; &quot;; iterator = iterator-&gt;r; }} 按值查找节点 1234567891011//从头到尾查找，返回第一个值为val的节点LNode* get_node_by_val(LinkList L, int val) { if (L == NULL || L-&gt;r == NULL) return NULL; LNode* t = L-&gt;r; while (t) { if (t-&gt;data == val) return t; t = t-&gt;r; } return NULL;} 参考测试代码 1234567891011121314151617181920212223242526272829303132int main() { LinkList test_list = init_linklist(); add_front(test_list, 30); add_front(test_list, 29); add_front(test_list, 28); LNode* tmp1 = get_node_by_val(test_list, 30); insert_after(tmp1, 100); insert_before(tmp1, -100); print_list(test_list); cout &lt;&lt; endl; cout &lt;&lt; get_length(test_list) &lt;&lt; endl; delete_node(tmp1); print_list(test_list); LNode* tmp2 = get_node_by_val(test_list, 28); delete_node(tmp2); print_list(test_list); return 0;}","link":"/cjpark/2021/03/26/doubly_linklist_cpp/"},{"title":"数据结构实现 | 单链表","text":"本文给出用C语言实现单链表的代码。 基本结构（带头节点） 12345678struct LNode{ int data; LNode* next;};typedef struct LNode LNode;typedef struct LNode* LinkList; 操作实现 初始化链表 123456//Initialize the list and return a pointer to the head_node of the listLinkList init_linklist() { LNode* head = (LNode*)malloc(sizeof(LNode)); head-&gt;next = NULL; return head;} 顺序打印链表 1234567891011//Print the list from head to tail//Time Complexity: O(n)void print_list(LinkList L) { if (L == NULL) printf(&quot;NULLPTR_ERROR&quot;); if (L-&gt;next == NULL) printf(&quot;EMPTY_LIST&quot;); LNode* cur = L-&gt;next; while (cur != NULL) { printf(&quot;%d &quot;,cur-&gt;data); cur = cur-&gt;next; }} 头插节点 12345678//Insert a node at the front of the list//Time Complexity: O(1)void add_front(LinkList L, int x) { LNode* p = (LNode*)malloc(sizeof(LNode)); p-&gt;data = x; p-&gt;next = L-&gt;next; L-&gt;next = p;} 按序号查找节点 123456789101112131415161718//Find the val of a node with certain number, if it exists.//The number given should starts from 1//Time Complexity: O(n)bool get_val_by_num(LinkList L, int num, int* res) { if (L == NULL || L-&gt;next == NULL) return false; if (num &lt;= 0 || res == NULL) return false; LNode* cur = L-&gt;next; int cnt = 0; while (cur != NULL) { cnt ++; if (cnt == num) { *res = cur-&gt;data; return true; } cur = cur-&gt;next; } return false;} 按值查找节点 123456789101112//Return the first node whose data equals val, or return NULL//Time Complexity: O(n)LNode* get_by_val(LinkList L, int val) { if (L == NULL) printf(&quot;NULLPTR_ERROR&quot;); if (L-&gt;next == NULL) printf(&quot;EMPTY_LIST&quot;); LNode* cur = L-&gt;next; while (cur != NULL) { if (cur-&gt;data == val) return cur; else cur = cur-&gt;next; } return NULL;} 在给定节点之后插入新节点 1234567891011//Insert a new node with certain val after the given node p//Then return a pointer pointed to the new node//Time Complexity: O(1)LNode* insert_after(LNode* p, int val) { if (p == NULL) return NULL; LNode* t = (LNode*)malloc(sizeof(LNode)); t-&gt;data = val; t-&gt;next = p-&gt;next; p-&gt;next = t; return t;} 在给定节点之前插入新节点 123456789//Insert a new node with certain val before the given node p//Then return a pointer pointed to the new node//Time Complexity: O(1)LNode* insert_before(LNode* p, int val) { if (p == NULL) return NULL; LNode* t = insert_after(p, val); swap(p-&gt;data, t-&gt;data); return p;} 删除给定节点 12345678910111213141516171819202122232425262728//Delete the given node in the list, if it does existbool delete_node(LinkList L, LNode* p) { if (L == NULL || L-&gt;next == NULL) return false; if (p == NULL) return false; //This indicates that p is not the last node //We can swap the data of p and the node t after it, then delete t if (p-&gt;next != NULL) { LNode* t = p-&gt;next; swap(p-&gt;data, t-&gt;data); p-&gt;next = t-&gt;next; free(t); return true; } else { //This indicates that p is the last node //We need to iterate the list to find the prior node of p LNode* pr = L; bool found = false; while (!found) { if (pr-&gt;next == p) { pr-&gt;next = NULL; free(p); found = true; } pr = pr-&gt;next; } return found; }} 获取链表长度 12345678910111213//Return the length of the list//If the list only has the head-node, its length gonna be 0int get_length(LinkList L) { int cnt = 0; if (L == NULL || L-&gt;next == NULL) return cnt; LNode* cur = L; while (cur-&gt;next != NULL) { cur = cur-&gt;next; cnt ++; } return cnt;} 参考测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int main() { /*---TESTING_CODE---*/ LinkList lst = init_linklist(); add_front(lst, 5); add_front(lst, 1); add_front(lst, 7); print_list(lst); LNode* t1 = get_by_val(lst, 8); if (t1 != NULL) printf(&quot;%d\\n&quot;,t1-&gt;data); else printf(&quot;t1_NULL\\n&quot;); LNode* t2 = get_by_val(lst, 5); if (t2 != NULL) printf(&quot;%d\\n&quot;,t2-&gt;data); else printf(&quot;t2_NULL\\n&quot;); int res1, res2, res3, res4; get_val_by_num(lst, 1, &amp;res1); get_val_by_num(lst, 2, &amp;res2); get_val_by_num(lst, 3, &amp;res3); get_val_by_num(lst, 4, &amp;res4); cout &lt;&lt; res1 &lt;&lt; &quot; &quot; &lt;&lt; res2 &lt;&lt; &quot; &quot; &lt;&lt; res3 &lt;&lt; &quot; &quot; &lt;&lt; res4 &lt;&lt; &quot; &quot; &lt;&lt; endl; LNode* tar = get_by_val(lst, 5); insert_after(tar, 999); insert_before(tar, 666); print_list(lst); printf(&quot;\\n&quot;); LNode* toDel = get_by_val(lst, 999); delete_node(lst, toDel); print_list(lst); cout &lt;&lt; endl; cout &lt;&lt; get_length(lst) &lt;&lt; endl; LinkList emptylst = init_linklist(); add_front(emptylst, 789); print_list(emptylst); cout &lt;&lt; get_length(emptylst) &lt;&lt; endl; /*---END---*/ return 0;}","link":"/cjpark/2021/03/20/singly_linklist_cpp/"},{"title":"数据结构实现 | 堆","text":"概述 堆是一棵完全二叉树，满足如下性质： 对于任意一个结点，其左、右子节点的值总是大于该节点的值（如果是最大堆则相反）. 一般用一维数组模拟堆，惯例下标从 1 开始，遵循此规范有如下结论： 若某节点索引为 iii，其左右儿子节点索引分别为 2i2i2i 与 (2i+1)(2i+1)(2i+1)，其父节点索引为 (i/2)(i/2)(i/2). 若堆中元素个数（堆的大小）为 hsizehsizehsize，则堆的最后一个内点的索引为 (hsize/2)(hsize/2)(hsize/2). 常见应用： 最小堆实现 HuffmanHuffmanHuffman 算法 堆排序的结构基础 第 kkk 大(小) 数问题 代码实现 存储 事先规定便捷记法如下 123#define ls(u) 2*u#define rs(u) 2*u+1#define fa(u) u/2 用一维数组 h[]h[]h[] 存储最小堆，hsizehsizehsize 记录堆中元素个数 123const int MAXN = 1e6 + 10;int h[MAXN], hsize; 下沉与上浮 对于一个节点，有“上浮”和“下沉”两种操作，用于维护最小堆的结构. 当一个节点对下不满足最小堆的性质时，就需要下沉；对上不满足性质时，就需要上浮. 注意，up(x)up(x)up(x) 与 down(x)down(x)down(x) 都是递归定义的，例如，若对一个节点 xxx 调用 down()down()down()，则节点 xxx 会一直下沉到正确的位置为止. 另外，若需要构建最大堆，只需要修改 up()up()up() 与 down()down()down() 中不等号的方向即可，其他函数都是通用的. 12345678910111213141516171819202122232425262728void down(int u) { //t是指向当前子树最小节点位置的指针 int t = u; //记得判左、右儿子是否存在 if (ls(u) &lt;= hsize &amp;&amp; h[ls(u)] &lt; h[t]) t = ls(u); if (rs(u) &lt;= hsize &amp;&amp; h[rs(u)] &lt; h[t]) t = rs(u); if (u != t) { swap(h[u], h[t]); down(t); //记得递归继续down }}//向上调整void up(int u) { int t = u; //记得判父亲下标不能小于1 if (fa(u) &gt;= 1 &amp;&amp; h[fa(u)] &gt; h[t]) t = fa(u); if (u != t) { swap(h[u], h[t]); up(t); }} 建堆 以下是建堆函数，给出一个乱序序列 {hn}\\{h_n\\}{hn​}，存到 h[n]h[n]h[n] 中，再对 h[n]h[n]h[n] 调用 build_heap()build\\_heap()build_heap()，即可建成堆的结构. 建堆的操作比较巧妙，从最后一个内点开始，自下往上逐层对每个结点调用 down()down()down() 函数，维护好每个内点负责的子树的结构，也就维护好了整个堆的结构. 注意，在对上层节点调用 down()down()down() 时，也会通过递归对下层的子树进行调整. 123void build_heap() { for (int i = hsize / 2; i &gt;= 1; i -- ) down(i);} 插入与删除 以下是插入和删除操作的实现，这两个函数有些类似。 因为对于一个堆来讲，比较容易改动的，一般是堆顶和堆尾. 当需要删除堆顶时，我们通常将堆顶和堆尾的值交换，然后对堆顶调用 down()down()down()，让换上去的元素下沉到合适的位置，同时删除堆尾，只需要让 hsizehsizehsize 减去 1 即可. 123456//删除堆顶元素void remove_min() { h[1] = h[hsize]; hsize --; down(1);} 当需要插入新元素时，直接插到堆尾，然后对新元素调用 up()up()up() 即可. 12345//插入新元素并维护void insert(int x) { h[ ++ hsize ] = x; up(hsize);} 取堆顶 返回序列的一号元素即可. 123int get_top() { return h[1];} C++ STL 优先队列 在 C++ 标准模板库中，堆被称为“优先队列”. 实际上看来，其实这个称呼更符合堆的特点： 便于改动的只有堆顶和堆尾，对应队头与队尾 队列中的元素遵循某种“优先级”，如最小堆中值越小的元素优先级越高 具体应用方式 12345678910#include&lt;queue&gt;using namespace std;priority_queue&lt;int&gt; heap; heap.push(int val); //插入元素，内部包含排序 heap.pop(); //删除堆顶 heap.size(); //获取堆的大小 heap.top(); //获取堆顶元素 heap.empty(); //判空 典例应用 堆排序 基本思路：将需要排序的序列建成堆，如果需要从小到大排列就建最小堆，需要从大到小排列就建最大堆，然后不断取堆顶元素并删除堆顶，直到堆空. 注意，C++ STL 提供的优先队列默认为最大堆 下面两种书写方式是等价的，建立的是最大堆 12priority_queue&lt;int&gt; heap;priority_queue&lt; int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap; 如果需要最小堆，则需要这样写 1priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap; 下面提供一个原地排序的 Demo 1234567891011121314151617181920212223#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;//从小到大排序，建立的是最小堆void heap_sort(int* arr, int len) { priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap; for (int i = 0; i &lt; len; i ++ ) { heap.push(arr[i]); } for (int i = 0; i &lt; len; i ++ ) { arr[i] = heap.top(); heap.pop(); }}int main() { int a[] = {5, 7, 7, 8, 3, 2, 1, 10, 11, 99}; heap_sort(a,10); for (int i = 0; i &lt; 10; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; //输出结果为： //1 2 3 5 7 7 8 10 11 99} 第 k 大数 基本思路：将所给序列建成最大堆，获取 kkk 次堆顶元素即可. 下面给出简易 Demo 123456789101112131415161718192021222324#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;//给出序列arr，返回序列中第k大的数，使用最大堆int kth_max(int* arr, int len, int k) { priority_queue&lt; int, vector&lt;int&gt;, less&lt;int&gt; &gt; heap; for (int i = 0; i &lt; len; i ++ ) { heap.push(arr[i]); } int res; while ( k -- ) { res = heap.top(); heap.pop(); } return res;}int main() { int a[] = {5, 7, 7, 8, 3, 2, 1, 10, 11, 99}; cout &lt;&lt; kth_max(a, 10, 3); //输出结果为： //10（第 3 大的数）} Huffman 算法 HuffmanHuffmanHuffman 算法通常用于求最优二叉树的问题. 什么是最优二叉树？ 定义一棵二叉树的权 W(T)W(T)W(T) 为所有叶子节点的权之和. 对于每个叶子节点 iii，它的权 Wi=Vi⋅hW_i=V_i\\cdot hWi​=Vi​⋅h，其中 ViV_iVi​ 是该点的值，hhh 为该点在二叉树中的深度.（注意，此处的深度定义为从根节点出发到该节点的路径所包含的边数） 给出 nnn 个节点，将它们作为叶子节点，构造出一棵具有特定结构的二叉树，使得 W(T)W(T)W(T) 最小，那么这棵树就叫做这 nnn 个节点所对应的最优二叉树. 哈夫曼算法 从给出的所有节点中，每次选取两个入度为 0 且值最小的节点，将他们合并成一棵二叉树，父亲节点的值为两个节点的值之和. 重复上述步骤，直到入度为 0 的顶点只有一个. 最后，树的所有内点的值之和就等于 W(T)W(T)W(T). 例题 以下是最优二叉树的典型例题. [NOIP 2004 提高组] 合并果子 原题链接：https://www.luogu.com.cn/problem/P1090 题意中的果子就是结点，果子的重量就是结点值，果子每被移动一次都会被多计算一次重量，可以抽象为结点在树中的深度，要求耗费体力最少，并求出该体力值，本质上就是求最优二叉树的权的问题. 如何利用堆实现哈夫曼算法？ 我们考虑将果子的耗费体力序列构建成一个最小堆，每次取出两个最小的元素（即取堆顶并移除堆顶 2 次），再将这两个元素的和作为一个新元素加入堆中，如此循环，直到堆中只剩下一个元素. 在每个步骤中，假设我们取出最小的两个数 aaa 和 bbb，然后把 (a+b)(a+b)(a+b) 加入堆中，上述行为导致最优二叉树中产生了一个值为 (a+b)(a+b)(a+b) 的内点，上面讲过，最优二叉树的权 W(T)W(T)W(T) 等于所有内点值之和，所以每产生一个内点，我们就应向答案 ansansans 中加入 (a+b)(a+b)(a+b). 如此重复到堆中只剩一个元素时，ansansans 就是所求答案. 参考代码 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int a[10001];int main() { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; heap; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) { scanf(&quot;%d&quot;, &amp;a[i]); heap.push(a[i]); } int ans = 0; while (heap.size() &gt; 1) { int a = heap.top(); heap.pop(); int b = heap.top(); heap.pop(); ans += (a + b); heap.push(a + b); } printf(&quot;%d&quot;, ans); return 0;}","link":"/cjpark/2021/03/29/heap/"},{"title":"刷题笔记 | 链表","text":"本文用于记录笔者刷链表类型题的笔记和题解. 力扣 206. 反转链表 https://leetcode-cn.com/problems/reverse-linked-list/ 三指针法 123456789101112131415161718192021struct ListNode* reverseList(struct ListNode* head){ //判空 if (head == NULL) return NULL; struct ListNode *pre, *cur, *ne; pre = NULL; cur = head; ne = head-&gt;next; while (ne) { cur-&gt;next = pre; pre = cur; cur = ne; ne = ne-&gt;next; } //最后节点指向还没改，补丁 cur-&gt;next = pre; return cur;} 递归写法 1234567struct ListNode* reverseList(struct ListNode* head){\\ if (head == NULL || head-&gt;next == NULL) return head; struct ListNode* tmp = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return tmp;} 力扣 141. 环形链表 https://leetcode-cn.com/problems/linked-list-cycle/ 判断链表是否有环，双指针. 1234567891011bool hasCycle(struct ListNode *head) { if (head == NULL) return false; struct ListNode* slow = head; struct ListNode* fast = head-&gt;next; while (fast &amp;&amp; fast-&gt;next) { fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) return true; } return false;} 力扣 160. 相交链表 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 判断两个链表是否相交，若相交，返回第一个相交节点的引用，否则返回 NULL 方法一 哈希表 unordered_mapunordered\\_mapunordered_map 先遍历链表 A，记录 A 的所有结点的地址到哈希表中，然后遍历 B，边遍历边检索哈希表，一旦发现某个结点地址被记录过，那么它必然是第一个相交结点，返回该节点即可. 12345678910111213141516171819202122class Solution {public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { if (headA == NULL || headB == NULL) return NULL; unordered_map&lt;ListNode*, bool&gt; recmap; ListNode* it = headA; while (it) { recmap.emplace(it, true); it = it-&gt;next; } it = headB; while (it) { if (recmap[it]) return it; it = it-&gt;next; } return NULL; }}; 方法二 双指针相遇法 初始时令双指针 itA,itBitA,itBitA,itB 分别指向 A,BA,BA,B 的头结点，然后同步前进，一旦其中任何一个指针（比如指针 AAA）到达 nullnullnull，就让它回到对方链表的头结点（如 AAA 回到 BBB 的头结点），然后继续两者同步前进. 如此循环，若链表有相交，两者必然会在某时刻相遇于第一个相交结点. 若链表不相交，两者必然相遇于 nullnullnull. 12345678910111213141516171819struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *itA, *itB; itA = headA; itB = headB; while (itA != itB) { //两者都不为null且不相等时，同步前进 while (itA &amp;&amp; itB &amp;&amp; itA != itB) { itA = itA-&gt;next; itB = itB-&gt;next; } //每次同步前进到有其中一个指针为null，则重定向该指针 if (itA == NULL &amp;&amp; itB != NULL) itA = headB; if (itB == NULL &amp;&amp; itA != NULL) itB = headA; } //itA与itB相等时退出while，判断itA或itB，null则不交，非null则交 return itA;} 力扣 1290. 二进制链表转整数 https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/ 辅助栈法 用辅助栈将链表数据反向取出，按转换算法转成十进制。 12345678910111213141516171819202122class Solution { public int getDecimalValue(ListNode head) { if (head.next == null) { return head.val; } //以下处理的链表长度大于1 int p = 0; int count = 0; Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x; for (x = head; x != null; x = x.next) { stk.push(x.val); count++; } int sum = 0; for (int i = 0; i &lt; count; i++) { sum += stk.pop() * Math.pow(2,p); p++; } return sum; }} 移位法 顺序遍历链表，每次将 sum 左移一位，再加上 x.val. 1234567891011class Solution { public int getDecimalValue(ListNode head) { if (head.next == null) return head.val; int sum = 0; ListNode x; for (x = head; x != null; x = x.next) { sum = (sum &lt;&lt; 1) + x.val; } return sum; }} 力扣 876. 链表的中间节点 https://leetcode-cn.com/problems/middle-of-the-linked-list/ 操作方法 此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。 代码实现 123456789101112131415class Solution { public ListNode middleNode(ListNode head) { if (head.next == null) return head; //单元素链表，返回自己 if (head.next.next == null) return head.next; //以下处理的链表长度至少为3 ListNode slow, fast; slow = head; fast = head; while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return slow; }} 拓展 如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。 剑指Offer 22. 返回链表倒数第k个节点 https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/ 两次遍历法 先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。 1234567891011121314151617class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode x; int count = 0; for (x = head; x.next != null; x = x.next) { count++; } x = head; for (int i = 0; i &lt;= count - k; i++) { x = x.next; } return x; }} 定距同步双指针 开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。 12345678910111213141516171819class Solution { public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; if (head.next == null) return head; ListNode p1; ListNode p2; p1 = head; p2 = head; for (int i = 0; i &lt; k; i++) { p2 = p2.next; } while (p2 != null) { p1 = p1.next; p2 = p2.next; } return p1; }} 力扣 237. 删除链表中的给定节点 https://leetcode-cn.com/problems/delete-node-in-a-linked-list/ 操作方法 此题传入参数为要删除的节点，这意味着我们无法访问之前的节点，也就无法通过修改前面节点的指向来实现删除。 对于链表这种不连续存储的数据结构来讲，我们只关心它存储的值，所以我们可以有如下操作。 不妨记传入的欲删除节点为 x ，它后面的两个节点依次为 y , z。 先将 y 的 val 赋给 x，再将 x 指向 z ，即可删除 y 。 代码实现 123456class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; }} 力扣 83. 删除排序链表中的重复元素 https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。 1234567891011121314151617181920212223242526272829303132333435class Solution { public ListNode deleteDuplicates(ListNode head) { //针对长度0、1、2的链表写特判 if (head == null) return head; if (head.next == null) return head; if (head.next.next == null) { if (head.val == head.next.val) { head.next = null; return head; } else { return head; } } //快慢指针 ListNode slow, fast; slow = head; fast = head; while (fast.next != null) { while (slow.val == fast.val &amp;&amp; fast.next != null) { fast = fast.next; } if (fast.next != null) { slow = slow.next; slow.val = fast.val; } } if (fast.val &gt; slow.val) { //注意，此处只有写大于号才能准确判定还有未出现的数需要前移 slow = slow.next; slow.val = fast.val; } slow.next = null; return head; }} 剑指Offer 06. 从尾到头打印链表 https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/ 使用辅助栈，遍历链表，全部压入再逐个弹出。 12345678910111213141516class Solution { public int[] reversePrint(ListNode head) { Stack&lt;Integer&gt; stk = new Stack&lt;Integer&gt;(); ListNode x; int len = 0; for (x = head; x != null; x = x.next) { stk.push(x.val); len++; } int[] rec = new int[len]; for (int i = 0; i &lt; len; i++) { rec[i] = stk.pop(); } return rec; }}","link":"/cjpark/2021/03/31/linklist_solutions/"}],"tags":[{"name":"高考","slug":"高考","link":"/cjpark/tags/%E9%AB%98%E8%80%83/"},{"name":"生物","slug":"生物","link":"/cjpark/tags/%E7%94%9F%E7%89%A9/"},{"name":"计算机网络","slug":"计算机网络","link":"/cjpark/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机基础","slug":"计算机基础","link":"/cjpark/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/cjpark/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","link":"/cjpark/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"题解","slug":"题解","link":"/cjpark/tags/%E9%A2%98%E8%A7%A3/"},{"name":"动态规划","slug":"动态规划","link":"/cjpark/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字符串","slug":"字符串","link":"/cjpark/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","link":"/cjpark/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"双指针","slug":"双指针","link":"/cjpark/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"工具","slug":"工具","link":"/cjpark/tags/%E5%B7%A5%E5%85%B7/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/cjpark/tags/C-C/"},{"name":"环境配置","slug":"环境配置","link":"/cjpark/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"VSCode","slug":"VSCode","link":"/cjpark/tags/VSCode/"},{"name":"排序","slug":"排序","link":"/cjpark/tags/%E6%8E%92%E5%BA%8F/"},{"name":"设计","slug":"设计","link":"/cjpark/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"PPT","slug":"PPT","link":"/cjpark/tags/PPT/"},{"name":"数组","slug":"数组","link":"/cjpark/tags/%E6%95%B0%E7%BB%84/"},{"name":"堆","slug":"堆","link":"/cjpark/tags/%E5%A0%86/"},{"name":"前端","slug":"前端","link":"/cjpark/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Python","slug":"Python","link":"/cjpark/tags/Python/"},{"name":"脚本","slug":"脚本","link":"/cjpark/tags/%E8%84%9A%E6%9C%AC/"},{"name":"项目","slug":"项目","link":"/cjpark/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"学习笔记","slug":"学习笔记","link":"/cjpark/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"离散数学","slug":"离散数学","link":"/cjpark/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","link":"/cjpark/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Java","slug":"Java","link":"/cjpark/tags/Java/"},{"name":"日志","slug":"日志","link":"/cjpark/tags/%E6%97%A5%E5%BF%97/"},{"name":"数据结构","slug":"数据结构","link":"/cjpark/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","link":"/cjpark/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数据库","slug":"数据库","link":"/cjpark/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/cjpark/tags/MySQL/"},{"name":"指针","slug":"指针","link":"/cjpark/tags/%E6%8C%87%E9%92%88/"},{"name":"笔记总结","slug":"笔记总结","link":"/cjpark/tags/%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"},{"name":"优先队列","slug":"优先队列","link":"/cjpark/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"技巧","slug":"技巧","link":"/cjpark/tags/%E6%8A%80%E5%B7%A7/"},{"name":"Linux","slug":"Linux","link":"/cjpark/tags/Linux/"},{"name":"博客","slug":"博客","link":"/cjpark/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"命令行","slug":"命令行","link":"/cjpark/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Windows","slug":"Windows","link":"/cjpark/tags/Windows/"},{"name":"矩阵","slug":"矩阵","link":"/cjpark/tags/%E7%9F%A9%E9%98%B5/"},{"name":"差分","slug":"差分","link":"/cjpark/tags/%E5%B7%AE%E5%88%86/"},{"name":"前缀和","slug":"前缀和","link":"/cjpark/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}],"categories":[{"name":"高考","slug":"高考","link":"/cjpark/categories/%E9%AB%98%E8%80%83/"},{"name":"计算机网络","slug":"计算机网络","link":"/cjpark/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"算法题解&#x2F;笔记","slug":"算法题解-笔记","link":"/cjpark/categories/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3-%E7%AC%94%E8%AE%B0/"},{"name":"C&#x2F;C++","slug":"C-C","link":"/cjpark/categories/C-C/"},{"name":"设计","slug":"设计","link":"/cjpark/categories/%E8%AE%BE%E8%AE%A1/"},{"name":"项目","slug":"项目","link":"/cjpark/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"离散数学","slug":"离散数学","link":"/cjpark/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"Java","slug":"Java","link":"/cjpark/categories/Java/"},{"name":"数据库","slug":"数据库","link":"/cjpark/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Python","slug":"Python","link":"/cjpark/categories/Python/"},{"name":"工具","slug":"工具","link":"/cjpark/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","link":"/cjpark/categories/Linux/"},{"name":"随笔","slug":"随笔","link":"/cjpark/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Windows","slug":"Windows","link":"/cjpark/categories/Windows/"}]}