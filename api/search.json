[{"id":"10b665f1e095b4ed3cf881e243904938","title":"暑假打卡日记","content":" 暑假打卡\n08/02\n\n[x] 肩部力量训练 (2.5kg 哑铃对)\n[x] 力扣每日一题 (设计循环队列)\n[ ] OSTEP 文件系统\n[ ] 教资科目二第1、2节网课\n\n08/01\n\n[x] 力扣每日一题 (生成每种字符都是奇数个的字符串)\n[x] Hexo 重新部署博客\n[x] 了解教资三个科目重点\n\n","slug":"summer_go_up","date":"2022-08-02T10:43:42.554Z","categories_index":"成长","tags_index":"健身,力扣","author_index":"菲尔普斯"},{"id":"60fb2254fd682498c39a67f2224cd21a","title":"深圳人","content":"深圳的地铁开到凌晨\n可是还是有很多赶不上的人\n\n\n这个城市好像从来不会停止转动\n有人刚下班\n有人刚上班\n为了生活和梦想奔波\n选择用勤奋弥补天分\n不管是在拥挤的地铁里\n还是在猪脚饭的餐桌上\n搞钱都是永恒的话题\n曾经的你为了什么来深圳\n如今的深圳\n是否也欠你一个梦想\n深圳湾的海鸥偶尔会停留片刻\n但终究还是要飞翔\n11号线地铁的窗外\n也依旧有海天一色的霞光\n我们拼命努力认真\n也许是相信下一站\n真的能翻身\n","slug":"sz_poem","date":"2022-08-01T02:17:28.434Z","categories_index":"随笔","tags_index":"摘抄","author_index":"菲尔普斯"},{"id":"1bf57baa637442b73fb295466338f782","title":"安装Ubuntu_20.04时踩过的坑","content":"Here are the various problems I met after successfully installing Ubuntu on my laptop.\n\n Cannot Install Language Support\nThe system said that it’s because of lack of dependencies, but actually it is related to my wrong source options. If you have set your sources correctly, the system can fix the problem itself (by sudo apt-get -f intstall)\n Cannot open software-center\n Solution:\nLaunch the terminal and input:\nsudo apt install ubuntu-software\n\n\n\n\n\n\n\n\n\nI guess that in old-version-ubuntu, it is called software-center, but maybe in 20.04, it is called ubuntu-software?\n Have changed the wrong sources.list\nThe source you choose must be suitable for your Ubuntu version, if the version matches wrong, then everything will go wrong, especially all kinds of error-remindings related to [lack of lib packages]\n Reference\nhttps://blog.csdn.net/YooLcx/article/details/104527734\n Lack of many kinds of lib packages\nGo to 1\n How to install flash for firefox\n\ninstall tar.gz from the Adobe\nunload it\ncopy .co file to /usr/lib/mozilla/plugins/\nrestart firefox\n\n Reference：\nhttps://blog.csdn.net/weixin_40522162/article/details/80287296\n Frequently-Used Commands\n\n\n\n\n\n\n\n\n\nsudo  means Super User DO\nsudo gedit &#123;directory/filename&#125;\nsudo apt-get update\nsudo apt-get install &#123;package_name&#125;\nsudo apt-get remove &#123;software_name&#125;\nsudo cp &#123;file_from_directory&#125; &#123;file_to_directory&#125;\nsudo dpkg -i &#123;deb_file_name&#125;\nsudo apt-get -f install (Use it when met with installing problems)\nsudo apt --fix-broken install (Install the depending packages)\ncd &#123;directory&#125;\nsudo &#123;software_name&#125; (To open software directly by terminal)\n::: tip\nWhen entering a name of a file or directory, you can just enter the necessary previos letters, then just press Tab, the shell will automatically complete the filename\n:::\n Remove Thunderbird\nIt is said that this operation is to solve the “Software Center Broken” Problem.\n Unable to input Chinese\n\nInstall fcitx\nDownload Sogoupinyin from its website, then install the .deb file by the terminal\nhttps://blog.csdn.net/jiangshuanshuan/article/details/95723237\n\n Lack of libpng12.so.0\n Reference：\nhttps://blog.csdn.net/weixin_43981229/article/details/106420012?utm_medium=distribute.pc_relevant_ask_down.none-task-blog-blogcommendfrombaidu-13.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_ask_down.none-task-blog-blogcommendfrombaidu-13.nonecas\n Ubuntu Software database is broken\n Reference:\nhttps://blog.csdn.net/u012406790/article/details/64442834\n","slug":"ubuntu_problems","date":"2022-08-01T01:16:28.151Z","categories_index":"Linux","tags_index":"Linux","author_index":"菲尔普斯"},{"id":"791254d594b7636005fb08a54038cd61","title":"5个月，我从一个完整项目学到了什么？","content":" 零、前言\n好久没写文章了，今天这期文章，想跟各位计算机专业的新手伙伴们聊一个老生常见的话题。\n为什么大家总说要通过做项目来学习？\n想想当初的我，也像各位小朋友一样，心里充满了问号：\n\n大家说的“开发”、“做项目”到底是在干啥？\n我到底需要学哪些东西、怎么学、学到什么程度，才能做成一个什么样的项目？\n什么框架、技术栈、设计模式，他们说的术语是什么，为什么我一个都听不懂？\n做开发是不是很 low？是不是只要有算法和科研才有技术含量？\n\n今天这一篇文章，先跟大家聊一下，从零开始，完成第一个项目，为我带来了什么收获？\n预计后面再写 1~2 篇，分享一些新手做项目的指南和有用的技巧\n\n\n\n\n\n\n\n\n\n注：由于我目前耕耘的领域是 Web 开发，所以今天我谈到的分享也好、心得也好，都只能保证适用于 Web 开发的领域\n\n从去年 7 月份开始（准确来说是 9 月份，因为 7 月和 8 月主要是在学习）到今年年底，大概 4 个月左右的时间，我都在参与学校某实验室的一个 Web 项目，准确来说是一个网站（目前还没正式投入使用）\n下面是项目的部分截图：\n\n\n\n我在其中，负责前端部分的工作，从启动项目到部署，前端绝大部分的工作和代码都是我负责的，于我自己而言，收获很大。\n其实在写到这里的时候，我在很努力地回忆，半年前的我，是什么样子的？\n我们都知道知识的诅咒——意思是指，一个已经掌握了知识的人，是很难去想像，那些没有掌握知识的人，他们脑子里的想法，是什么样子的。\n我尽可能地去回忆，翻相册，翻朋友圈，翻 GitHub 提交记录，希望能够想起半年前的我，一个零项目经验的新手开发者的想法和疑惑，顺便梳理一下这半年来的心路历程，供自己留一份回忆，如果有幸能够帮到读者，那就再好不过了。\n 一、我的项目是哪来的？\n我是 2020 年 9 月入的学，计算机系科班生，从 2020 年 9 月到 2021 年 5 月期间，也就是入学 8 个月左右吧，活动参与了不少，学业也有点忙，力扣也没少刷，乱七八糟的什么博客、公众号都折腾过，但是 8 个月的时间里，一个项目都没做过，项目经验为零。\n那时候的我，是什么水平呢？大伙听我慢慢讲：\n我那个时候，总是会听到大佬/学长们说，什么前端开发、后端开发、客户端开发，各种名词都听得耳熟能详，但是一个都不会，一个都没了解过，最多只会“报菜名”。\n啥叫“报菜名”呢？就是跟别人吹牛的时候，能说一两句\n“诶我知道那啥，后台开发一般用 Java 和 C++ 嘛…”\n“前端开发啊，不就是三大件嘛，HTML + CSS + JavaScript”\n除此之外，啥都不会。是的，你没看错，除了吹牛报菜名，啥都不会。\n菜得要命的我，每天都在想：\n怎么办呀？以后找工作也要项目经验呀…\n我啥时候能找个项目做啊？做点啥？要学啥才能做？不知道啊…\n后来，通过一些研究生学长得知，学校实验室一般时不时会有些项目，需要学生来当免费劳动力，我就厚着脸皮去找了一位教授，问他能不能给个机会我到实验室里干活，当时人家问我，你学分绩排名多少名？我说了下，可能没达到他的要求，教授说：“你先回去好好学习”\n哈哈，当时心态有点崩…\n后来，也许我在这位教授的实验课上表现比较好，他又找到我说：“咱现在有一个 xx 项目，大概需要这样这样的功能，你有兴趣参与不？”\n俺说好，于是教授给让他实验室的一位研一学长来负责带领和组织整个项目的开发\n\n\n\n\n\n\n\n\n\n这位学长是保研选手，曾在腾讯后端开发岗实习，是我入门开发的贵人和领路人，我一般都叫他“灿哥”，我写这篇文章的目的之一，咱就是说，也是希望，向灿哥表达一个大大的感谢 ♥\n当时这个项目分成了两个 team，分别负责前端和后端开发，各有 3~4 人，灿哥问我想做前端还是后端，我由于自己本来比较喜欢视觉设计，喜欢视图层的东西，就选择了前端开发。\n当时我特别兴奋，但同时也有些担心，担心自己无法完成项目的需求；其实现在回头来看，担心都是多余的，朋友们，做事不要畏畏缩缩，撸起袖子直接干就对了！\n 二、艰难的起步\n 学习清单\n6 月份的时候，灿哥很贴心地写了一份学习指南，告诉我们做项目需要学习哪些预备知识，以及给出了对应的学习资源链接。\n前端部分大概包括：\n\nHTML\nCSS\nJavaScript\nVue 基础\nElement UI 组件库\n\n后端部分包括：\n\nJava 基础\n数据库基础\nLinux 基础\nSpring 和 Spring Boot 框架\nMyBatis 框架\n\n基础工具和知识：\n\nXshell (用于控制远程服务器)\nXftp (用于向服务器上传文件)\nPostman (网络请求测试)\nGit (版本控制 + 协作开发)\n计算机网络 应用层 + 传输层\n\n前端小组的人需要掌握前端部分，后端小组的人掌握后端部分，而基础工具知识是大家都需要掌握的。\n当时我刚好结束考试月，时间比较充裕，就打算把前端、后端都一起学了。\n\n\n\n\n\n\n\n\n\n其实当时主要学习重心还是集中在后端，因为我大概知道前端三大件是在干啥，HTML 负责页面结构，CSS 负责样式，JS 负责逻辑和动效，心里有个概念，但是对于后端，了解程度几乎为零，所以希望多学习一些\n 学习过程\n这部分就比较艰难了，因为上面这份清单，对于当时的我来讲，需要接触和学习的新概念、新知识特别多，每天都有海量的概念和知识涌入。\n 后端部分\n先说说后端部分吧，咱的组长说，服务端应用一般跑在 Linux 系统上，于是我就费了很大劲去装了个 Ubuntu 20.04 系统，强迫自己在这个系统上做开发，以便熟悉它。\n\n这时候蛋疼的事情就来了：\n常用的软件你得安装吧？你上网搜索怎么安装，然后学了一大堆命令\n常用的文件操作，复制、创建、编辑，你得会吧？又学了一大堆命令\n有些软件要配环境变量吧？你得知道环境变量在哪配吧？于是你把 Linux 的系统目录结构学了一遍\n\n上面balabala折腾完了，大概知道这个系统怎么用了。下面轮到数据库了。\n我按照清单上的框架名搜了一下，MyBatis 是一个专门负责和数据库打交道的框架，反正我也不知道该从哪学起，就先去看 MyBatis 的教学视频——才看了两集，就被告知：学这个之前，需要有 JDBC 基础，以及需要在本地部署好 MySQL 服务\n经过一番折腾之后，我先在本地装好了 MySQL，启动了服务，然后马上跑去 B 站学 JDBC (Java Database Connectivity, Java 为连接数据库提供的一套 API)，呼啦呼啦学了一通，发现数据库是连接上了，但是操作数据库的过程中笨手笨脚，不得劲儿，为啥呢？\nSQL 语句不熟呗，然后我又跑去学 SQL 语句，学着学着，又发现，数据库表、关系、字段、联结，这些概念，我也不熟，然后又去搞了本电子书恶补了一下…\n\n数据库的基本东西学差不多了，接下来就开始学传说中的 Spring 框架，这里头的学问，可就多了。\n随便点开一些讲解 Spring 框架的文章或者视频，都会首先给你讲一堆概念\n其中最典型的当属 IoC (Inversion of Control, 控制反转) 和 AOP (Aspect Oriented Programming, 面向切面编程)\n先别说这些概念了，刚开始学没多久，我就发现我缺少了一些面向对象的知识（类，对象，接口，实现，封装，继承，多态），灰头土脸地跑回去恶补了一通\n回来之后，开始啃有关 IoC 的知识，当时看了好多个版本的讲解视频，反复翻了好多篇文章，记了很多笔记，终于理解了这个知识点（现在回头看看，这个概念对于没有开发经验的新手来讲，确实是非常难啃的）\n\n后续的学习还有 Spring MVC 和 Spring Boot，这部分因为当时时间有点紧，我跳过了很多东西，就不展开说了。\n 前端部分\n前端部分的学习倒没有那么曲折，当时我记得我是在一个叫 freeCodeCamp 的网站学的，这个网站里给你规划好了学习路线，课程分成了很多小节，边写边实践，稍微记下笔记，掌握得还是比较快的。\n\n 前后端整合\n按照原定的前端学习路线，在大致过了一遍 HTML、CSS、JavaScript 之后，我应该去学 Vue 框架，但当时我去看 Vue 的教学视频，看了几节之后就看不下去了，为啥呢？\n因为视频一上来，就教你 Vue 的常见指令的用法，各种 v-on，v-bind 什么的，我都不知道这些东西能用来干啥，学习过程味同嚼蜡，我就放弃了。\n其实主要是因为我心里一直有个疙瘩：\n前端、后端分别都学了那么久，学了那么多知识，但我至今不知道前后端是怎么连接在一起、怎么通信的，我连个像样的小东西都做不出来，实在是有点沮丧。\n直到我发现了一个叫做《4 小时上手 Spring Boot + Vue 前后端分离开发》的视频，视频 up 主没有任何废话，上来就带你分别创建 Spring Boot 项目和 Vue CLI 项目，在数据库简单建了个表，然后用 axios 直接开始收发 http 请求，打通前后端，启动了一个包含了基本增删改查操作和路由导航的项目。\n\n看完这里，我有一种感觉：\n\n\n\n\n\n\n\n\n\n闭关静修久矣，今君一指，吾任督二脉通也\n无论是前端、后端，之前学的所有零散的知识点，全都串起来了！\n当然，同时又发现自己还需要学习以下知识：\n\nHTTP 协议\nVue CLI 脚手架\nVue 框架用法\nVue Router 路由配置\nElement UI 组件库\n…\n\n 学习体会\n其实，通过前面的长篇流水账叙述，大家可以看到，我的学习过程非常的艰辛、曲折。\n那段时间 (暑假七八月份) 里，每天的日常就是电脑分成 2 个屏，左边写代码/看视频/看文章，右边记笔记，经常不知不觉学到凌晨 2 点、3 点，甚至有时候 4 点都还没睡。\n\n\n现在回头再看那段时间的学习过程，其实所学的东西和学习的路径大致可以用下面这张图来概括：\n\n在学 A 的过程中，发现自己 B 也不会，然后钻进去学习 B；\n学习 B 的时候，又发现还需要先学 C，又钻进去学 C…\n一层一层地往里钻，当觉得自己当前所在层学得差不多了，就回到上一层继续学\n如此反复，当回到最顶层的时候，说明这个板块掌握得差不多了\n用计算机的术语来讲，这个过程就像递归，当然，更恰当的说法是深度优先搜索。\n当然了，这个过程也可以理解为，对一棵多叉知识树的前序遍历。\n\n为什么会这样呢？\n因为我的学习方向不是自底向上，而是自顶向下的\n当我对将要学习的东西缺乏一个整体的认知\n或者说，我根本不知道我需要学习哪些东西的时候\n我会选择从最顶层开始学\n这样一来，我需要学习的知识就会在路上一个个浮现\n这时，学习路径就会整体呈现为一个向下的树状结构\n需要我一层一层往下潜，再一层一层往上浮起来\n辛苦归辛苦，也很考验人的耐心\n但只要坚持下来，收获还是很大的\n\n\n\n\n\n\n\n\n\n这一整个过程就是入门 Web 开发最艰难的过程，也是从 0 到 1 的过程，它之所以难，不是难在需要学习的知识点多而繁杂，而是难在我们根本不知道要学什么，这时候，这种目标驱动、自顶向下的方法，我认为是比较合适的。\n 三、登录认证模块——第二个瓶颈\n最艰难的一步，或者说，学习 Web 开发路上的第一个瓶颈，已经迈过去了。\n没过多久，我又迎来了第二个挑战——灿哥让我全权负责项目的登录认证模块的前端部分，并与一位负责后端的大三学长共同完成这个模块。\n其实这个模块无论是前端部分还是后端部分，都是有一定难度的，刚入门就担此大任，估计又免不了一番爆肝了…\n当然，这个模块有一个很明显的好处，那就是网上有很多现成的方案可以参考，在调研过程中，我主要做了以下几件事：\n\n搜索查询主流的解决方案\n了解/学习这些方案涉及到的技术、用到的框架和相关知识点\n找开源项目的有关示例，参考别人的设计思路\n\n记得为了补充需要的 HTTP 协议知识，我用了一天左右的时间刷完了《图解 HTTP》这本书，还看了《网络是怎样连接的》的其中一部分\n\n做登录模块，涉及到密码，肯定少不了加密，需要必要的密码学常识，为了搞清楚 MD5, SHA-256, RSA, AES 这些到底都是什么东西，它们之间有什么关系，我又用两三天时间过了一遍《图解密码技术》\n\n为了搞明白 Cookie, Session, Token, JWT 等各种各样的鉴权机制/工具，我翻了很多很多篇文章（其实网上很多地方写得都不太准确，后来找了一些英文资料才搞明白）\n\n搞明白鉴权的基本原理和方案之后，下一步就需要将它落地了。\n项目组里决定在后端集成 Spring Security 框架来做这个事情，我又特地去了解了一下这个框架相关的知识，然后找了一个叫 springboot-rbac-security 的 demo，结合前端这边做鉴权的思路，梳理出了一个总的方案，在当时的项目周会上做了登录认证授权模块的方案详解和分享。\n（当时还认真做了好多页 PPT，花了很长时间，画了一个总流程图）\n\n\n\n\n这一整个方案，从调研到确定到落地，无论是我还是后端的大兄弟，都踩了不少坑，最后才做出来。\n还有很多踩坑的细节，我就不一一展开了。\n我想说的是，在确定的需求面前，知识的扩充是自然而然的：\n当你的业务逻辑中需要加密，你就会去了解加密算法\n当你需要鉴权，你会去了解 Token 令牌\n当你需要在无状态协议下保存会话信息，你会去了解 Cookie, Session\n当你在想，服务端将会话信息存在什么地方合适，你会去了解 Redis\n当你的前端页面需要配合后端做鉴权，控制哪些页面用户能访问、哪些不能访问，你需要了解 Vue 路由拦截器和 Axios 响应拦截器\n当你需要在前端存储全局信息，你需要了解 状态管理库 Vuex\n…\n总而言之，在面临一个需求时，只要你认真调研，用心去做，在遇到不懂的概念时不要得过且过，花点时间补充必要知识，对自己的方案的代码负责，最终的收获一定不会少。\n 四、需求和学习的深入\n项目的基础框架和较难的模块都做好之后，在后续的项目进程中，日常开发流程都是下面这样：\n\n灿哥分配功能需求\n前端和后端一起讨论，设计方案\n前端负责页面设计 + 布局 + 交互逻辑 + 数据展示\n后端负责和数据库打交道，提供数据 API 接口\n前端、后端联调\n\n在这个过程中，陆陆续续做了这些模块/功能：\n\n用户头像上传/修改\n修改密码/忘记密码\n绑定邮箱\nMarkdown 文章编辑/展示\n评论模块\n点赞功能\n悬停自动搜索\n做题/判题模块\n…\n\n在代码量逐渐增大的过程中，增强可维护性的需求就会自然显现\n多处都用到的逻辑，需要抽离到公共的工具类中；\n一个UI/功能/逻辑完整的可复用单元，需要被封装成 Vue 组件；\n组件之间出现了父子/兄弟/祖孙关系，需要传递数据，就需要了解组件通信的各种方法，包括 props/emit, $refs, eventBus, provide/inject…\n要做 Markdown 编辑/渲染，要找稳定的开源的轮子/插件，比如字节的 @bytemd/vue；\n要做代码编辑器，找到开源的 mavonEditor 之后，还要踩一遍它布局 bug 的坑；\n要在用户切换页面之后保留之前编辑的内容，需要做路由组件缓存；\n要做头像上传功能，就要跟云存储商的 API 和 SDK 打交道，这个功能还因为云存储商的 CDN 延迟出过一点小问题，当时因为要向老大梳理和汇报这个事情，又写了一篇文章…\n\n\n以上都是日常开发过程中，边踩坑边学习的过程\n但是，下面这件事情，才让我真正地发现了新大陆：\n在数字逻辑考试那天，前端这边一个组员写出了一个莫名其妙的 bug，我将这个 bug 复现之后，在网上没有找到相关的资料\n我的直觉告诉我，这与 Vue 框架的响应式原理有关\n于是我抛下手头上正在复习的数字逻辑 PPT\n纵身一跃，跳进了 Vue 框架 2.6.14 版本的源码中寻找答案\n最终发现，答案就在这段代码中\n\n\n这次机缘巧合，让我对 Vue 的响应式原理有了更进一步的了解\n更重要的是，它开启了我阅读框架源码的不归路…\n\n 五、部署阶段——另一番风景\n前面吭哧吭哧做了那么久，项目做差不多了，就要考虑部署和上线的问题了\n因为我们是前后端分离开发，也就是说，前端和后端是分开部署的，最后可能分别在两台不同的服务器上，也有可能在一台服务器的两个不同端口上\n也就是说，我只要负责把前端部分部署好就行了\n第一次部署的我，天真无邪，编译打包之后，直接扔上了我自己的阿里云服务器\n结果发现，首次访问的时候，居然加载了 50 秒左右才进入主页！\n你能想像吗？打开一个网页需要“转圈圈”50秒才能进入！\n我被吓得不轻，急忙去 Chrome 控制台的网络面板看看到底传输了啥东西\n经过一番排查和 Google，发现其实是编译打包的时候，Webpack 打包的体积太大了，导致页面首次加载的时候需要在有限的网络带宽上传输大量臃肿的 js 文件，导致速度异常缓慢\n所以接下来的任务很简单，就是要想尽一切办法，减少 Webpack 的 bundle size：\n1.用 Webpack-Bundle-Analyzer 分析 bundle 结构\n\n2.将项目依赖的几个核心公共库和组件库改为 CDN 引入\n之前在开发环境下，这些核心库和组件库（如 Vue，Vuex，Vuetify）都是通过 npm 包安装的，所以它们最终全部都会被打包进 Webpack 的 bundle 里面，现在将它们从依赖列表中移除，全部改为 CDN 引入，相当于减轻了服务器的传输负担，从多路获取资源，原来的串行传输变为并行传输，速度快了不少\n3.路由组件全部改成异步加载\n异步加载也称为懒加载，使用懒加载之后，进入首屏只需要加载首页的路由组件，速度又快了不少\n4.关闭生产环境的 Source Map\nVue CLI 集成了代码压缩，编译打包时会压缩代码，而 Source Map 是一种存储映射信息的文件，能够将『压缩后代码』映射为『原代码』，它的功能主要是方便开发人员在线上环境直接调试，所以默认也会被打包进 bundle 里，我们只要去掉这些映射文件，就能够进一步减小打包体积\n\n其实上面几点我都是一步一步摸索过来的，并不是一口气完成的\n我的首屏加载时间慢慢从 50 秒优化到 49 秒\n从 49 秒 优化到 35 秒\n20 秒、9 秒、5 秒…\n最终达到一个正常情况下 1.5 ~ 3 秒左右的首屏加载时间\n\n最核心的访问速度问题解决了之后，还有一些比较杂碎的问题，这里也不展开了：\n\n某些涉及 ajax 请求的操作 / 会频繁触发的数据，视需要做防抖或节流处理\n配合后端排查接口响应问题\n排查潜在的网络安全问题（未完成）\n…\n\n 六、回顾 &amp; 致谢\n流水账写了这么长，也差不多了\n上面说的这些东西，大部分都是在 9~12 月份做的，其实本来也不用这么长时间，主要是因为在学校还需要处理日常的课业和学习任务（懂的同学自然都懂，概率论/近世代数/算法设计/数字逻辑，没一个是善茬）\n记得国庆放假期间，还有平时的无数个周末，都投入在了这个项目上\n一路走来，项目应该也差不多接近尾声了，才有了写这篇文章的想法，也算是一个阶段性的回顾和总结吧\n其实现在回头看\n这也就是一个平平无奇的 Web 项目罢了\n也没有什么特别出彩的地方\n但去年 6 月份到现在\n它帮助我\n从一个什么都不会的菜鸟\n变成了一个入门级菜鸟\n回头看\n会发现自己不知不觉走了很长的路\n向前看\n自己对这个行业和领域多了一点理解和认识\n会发现视野越来越开阔\n要学的东西还有很多\n数据可视化，Web 安全，服务端开发，工具链…\n希望继续努力探索\n扩充自己的知识面和技术栈\n最后\n我想特别感谢：\n\n\n来领我入门 Web 开发的：灿哥\n\n\n孜孜不倦为我这个菜鸟解惑的两位前端工程师：聪哥、威哥\n\n\n感谢前辈们的帮助和提携\n感谢项目组里一起努力的各位伙伴\n新的一年祝大家虎虎生威，心想事成 🐅🧨🧧\n\n","slug":"oj_proj","date":"2022-02-06T09:15:00.000Z","categories_index":"项目经验","tags_index":"前端开发,经验,随笔","author_index":"菲尔普斯"},{"id":"17c4a4a2974859ec97857b45c9cf78f2","title":"npm cheat sheet","content":"全局更新 npm：npm i npm -g\n强制清理缓存(高版本禁用)：npm cache clean --force\n安装 cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n 命令\n 版本\nnpm -v\n 初始化\nnpm init   //引导创建package.json\n 安装\nnpm install 模块名 -g           //全局安装\nnpm install 模块名              //本项目安装\nnpm install 模块名@latest       //最新版本安装\nnpm install 模块名@版本号        //指定版本\nnpm install 模块1 模块2 模块3    //一次性安装多个\nnpm install 模块名 --save-dev   //安装开发时依赖包(devDependencies)\nnpm install 模块名 --save       //安装运行时依赖包(dependencies)\nnpm uninstall 模块名            //卸载某个模块\n标注 --save-dev 的模块会被加入 package.json 中的 devDependencies\n标注 --save 的模块会被加入 package.json 中的 dependencies\n\n\n\n\n\n\n\n\n\nnpm install 可缩写为 npm i\n 更新\nnpm update 包名\n 查看各种信息\n查看已经安装的模块\nnpm list            //直接全部列出\nnpm list --depth=0  //限制层级深度\n查看模块安装位置\nnpm root      //查看本项目中模块安装位置\nnpm root -g   //查看全局模块安装位置\n以关键词搜索已经存在的 npm 包\nnpm search 关键词    //例如搜vue会出来一堆vue r\n查看 npm 源上某个包可用的所有版本号\nnpm view 包名 versions\n 缓存相关\nnpm cache clean            //清除缓存\nnpm cache clean --force    //强制清除缓存\n 执行脚本\nnpm run 任务名称\n任务名称指 package.json 里的 scripts 中配置的命令名\n&#123;\n  \"scripts\": &#123;\n    \"watch\": \"webpack --watch --progress --colors --config webpack.conf.js\",\n    \"dev\": \"webpack --progress --colors --config webpack.conf.js\",\n    \"prod\": \"NODE_ENV=production webpack -p --config webpack.conf.js\",\n  &#125;,\n&#125;\n 常见问题\n1.执行 npm install lodash 发生了什么？\nnpm 会下载 lodash 的最新的可用版本包，放到当前执行该命令的目录下的 node_modules 文件夹中；与此同时，会将安装的 lodash 及其版本号添加到 package.json 中的 dependencies (运行时依赖) 中\n2.package-lock.json 到底是干嘛的？\n3.npm update 干了什么？\n当运行 npm update 时，package-lock.json 文件中的依赖的版本会被更新\n 注意\n\n通常不建议 npm install -g，因为这样可能导致版本冲突问题，毕竟可能有些项目用的是 Webpack 4，有些是 Webpack 5\n\n\n","slug":"npm_cheat_sheet","date":"2022-01-07T12:45:00.000Z","categories_index":"前端开发","tags_index":"前端开发,npm","author_index":"菲尔普斯"},{"id":"9eb5ca10bff6be7f75941f8be934e3c2","title":"Vue 的组件通信总结","content":"\n\n 常用方案\n\n通过 props 传递\n$emit 触发自定义事件\n使用 $ref\n使用事件总线\n$parent 或 $root\nattrs 与 listeners\nprovide 与 inject\n通过 Vuex\n\n 具体场景\n 父传子\n父组件通过给 props 给子组件传值.\n通过一个简单例子来说明，场景如下：\n父组件是一个显示文章的页面视图，子组件叫 MarkdownContent，能将 Markdown 字符串渲染成 HTML 字符串，每次用户打开一篇文章，父组件都需要向服务端发请求，拿到 Markdown 字符串格式的文章，然后交给子组件渲染，所以产生了向子组件传值的需求.\n父组件中需要通过 v-bind:子组件属性名 传入数据，如下\n&lt;!--父组件中通过:attribute形式给子组件传值--&gt;\n\n&lt;template&gt;\n  &lt;MarkdownContent :markdownContent&#x3D;&quot;comment.content&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport MarkdownContent from &quot;.&#x2F;MarkdownContent&quot;;\nexport default &#123;\n  components: &#123;\n    MarkdownContent  \n  &#125;,\n  data() &#123;\n    return &#123;\n      comment: &#123;\n        author: &#39;&#39;,\n        content: &#39;&#39;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n子组件中需要设置相应的 props，并设置好数据绑定\n&lt;template&gt;\n  &lt;mavon-editor v-model&#x3D;&quot;markdownContent&quot;&gt;\n  &lt;&#x2F;mavon-editor&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  props: &#123;\n    markdownContent: &#123;\n      type: String,\n        default: &#39;&#39;,\n        required: true\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n 子传父\n子组件通过 this.$emit('向外暴露事件名'，携带数据) 来向父组件传值.\n举例说明，场景如下：\n父组件是一个评论区页面，子组件是一个简单的 Markdown 文本编辑框加上一个“提交”按钮，现在我们希望，当用户输入了评论并点击了子组件里的“提交”按钮时，父组件能够收到通知并拿到这份评论文本，通过 HTTP 请求发给服务端.\n我们可以这么做：\n给子组件的提交按钮绑定一个处理事件，在该事件中 emit\n&lt;template&gt;\n  &lt;mavon-editor v-model&#x3D;&quot;content&quot;&#x2F;&gt;\n  &lt;v-btn @click&#x3D;&quot;handleCommit&quot;&gt;\n    发表评论\n  &lt;&#x2F;v-btn&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      content: &#39;&#39;,\n    &#125;\n  &#125;\n  methods: &#123;\n    handleCommit() &#123;\n      this.$emit(&#39;onCommit&#39;, this.content)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n同时，在父组件中通过 v-on:子组件emit的函数名=&quot;父组件中某个处理函数(接收emit的数据参数)&quot;来感知\n&lt;template&gt;\n  &lt;Comments @onCommit&#x3D;&quot;commitToServer&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  methods: &#123;\n    commitToServer(contentOfComment) &#123;\n      HttpService(&#123;\n        url: &#39;...&#39;,\n        method: &#39;post&#39;,\n        data: &#123;\n          comment: contentOfComment\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n 父组件从子组件取数据\n如果并不需要“子组件触发某事件时父组件收到通知”的效果，而仅仅只需要让父组件取出子组件的数据，可以通过 this.$refs 来实现.\n例如，子组件是一个文本框，父组件希望点击按钮时，能够直接取出子组件文本框的内容\n如下，子组件做自己就好，不需要做任何特殊的准备\n&lt;!--子组件--&gt;\n&lt;template&gt;\n  &lt;v-text-field v-model&#x3D;&quot;text&quot;&gt;&lt;&#x2F;v-text-field&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ChildComponent&#39;,\n  data() &#123;\n    return &#123;\n      text: &#39;&#39;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n父组件中，需要给子组件加一个 ref 属性，也就是引用名，加上就可以取数据了\n&lt;!--父组件--&gt;\n&lt;template&gt;\n  &lt;ChildComponent ref&#x3D;&quot;myChild&quot;&#x2F;&gt;\n  &lt;v-btn @click&#x3D;&quot;getText&quot;&gt;&lt;&#x2F;v-btn&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport ChildComponent from &#39;...&#39;\nexport default &#123;\n  components: &#123;\n    ChildComponent\n  &#125;,\n  methods: &#123;\n    getText() &#123;\n      console.log(this.$refs.myChild.text);\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n 兄弟组件之间传\n EventBus\n使用事件总线，即创建一个空的 Vue 实例来充当 EventBus，具体例子待补充\n $parent 或 $root\n即通过共同祖先来通信\n兄弟 A 使用 this.$parent.emit('haha', someData)\n兄弟 B 使用 this.$parent.on('haha', callbackFunction)\n\n\n\n\n\n\n\n\n\n$parent 取的是上一级组件，$root 取的是根组件\n 祖先给子孙传\n 使用 provide 与 inject\n祖先组件中提供 provide()，返回一个数据对象，子孙组件使用 inject 来接受 ，具体如下\n祖先组件用 provide 提供一个返回对象的函数\nexport default &#123;\n  data() &#123;\n    return &#123;\n      myData: &#123;\n        name: &#39;abc&#39;,\n        sex: &#39;boy&#39;\n      &#125;\n    &#125;\n  &#125;,\n  provide() &#123;\n    return &#123;\n      providedData: this.myData\n    &#125;\n  &#125;\n&#125;\n子孙组件用 inject 接收\n&lt;template&gt;\n  &lt;div&gt;&#123;&#123; providedData.name &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  inject: [&quot;providedData&quot;]\n&#125;\n&lt;&#x2F;script&gt;\n需要特别注意的是，通过 provide 与 inject 传递的数据并不是响应式的，也就是说，祖先组件传值给子孙组件之后，如果祖先组件中那个值改变了，子孙组件无法被通知，也无法响应变化.\n但其实，如果传的是一个对象，那祖先组件和子孙组件的数据依然是同步的，这是因为传对象是引用传值，所以祖先和孙子读写的是同一个地址上的东西.\n而如果传的是基本数据类型，那就真没法响应式了.\n\n\n\n\n\n\n\n\n\n这种方式的缺点非常明显，即便传的是对象，数据能够同步，但假若一个祖先组件将同一份对象传给了很多个子孙，那么任何一个子孙对数据的修改都将影响全局.\n 使用 $attrs 与 $listeners\n待补充\n","slug":"vue_comp_commu","date":"2021-11-09T06:15:00.000Z","categories_index":"项目经验","tags_index":"前端开发,经验,随笔","author_index":"菲尔普斯"},{"id":"6db5ceff1cffdec592e2386e6fd66245","title":"刷题笔记 | 链表","content":"本文用于记录笔者刷链表类型题的笔记和题解.\n\n 力扣 206. 反转链表\nhttps://leetcode-cn.com/problems/reverse-linked-list/\n三指针法\nstruct ListNode* reverseList(struct ListNode* head)&#123;\n    //判空\n    if (head == NULL) return NULL;\n\n    struct ListNode *pre, *cur, *ne;\n    pre = NULL;\n    cur = head;\n    ne = head->next;\n\n    while (ne) &#123;\n        cur->next = pre;\n        pre = cur;\n        cur = ne;\n        ne = ne->next;\n    &#125;\n\n    //最后节点指向还没改，补丁\n    cur->next = pre;\n\n    return cur;\n&#125;\n递归写法\nstruct ListNode* reverseList(struct ListNode* head)&#123;\\\n    if (head == NULL || head->next == NULL) return head;\n    struct ListNode* tmp = reverseList(head->next);\n    head->next->next = head;\n    head->next = NULL;\n    return tmp;\n&#125;\n 力扣 141. 环形链表\nhttps://leetcode-cn.com/problems/linked-list-cycle/\n判断链表是否有环，双指针.\nbool hasCycle(struct ListNode *head) &#123;\n    if (head == NULL) return false;\n    struct ListNode* slow = head;\n    struct ListNode* fast = head->next;\n    while (fast &amp;&amp; fast->next) &#123;\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow) return true;\n    &#125;\n    return false;\n&#125;\n 力扣 160. 相交链表\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n判断两个链表是否相交，若相交，返回第一个相交节点的引用，否则返回 NULL\n方法一  哈希表 unordered_mapunordered\\_mapunordered_map\n先遍历链表 A，记录 A 的所有结点的地址到哈希表中，然后遍历 B，边遍历边检索哈希表，一旦发现某个结点地址被记录过，那么它必然是第一个相交结点，返回该节点即可.\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        if (headA == NULL || headB == NULL) return NULL;\n\n        unordered_map&lt;ListNode*, bool> recmap;\n\n        ListNode* it = headA;\n        while (it) &#123;\n            recmap.emplace(it, true);\n            it = it->next;\n        &#125;\n\n        it = headB;\n        while (it) &#123;\n            if (recmap[it]) return it;\n            it = it->next;\n        &#125;\n\n        return NULL;\n    &#125;\n&#125;;\n方法二  双指针相遇法\n初始时令双指针 itA,itBitA,itBitA,itB 分别指向 A,BA,BA,B 的头结点，然后同步前进，一旦其中任何一个指针（比如指针 AAA）到达 nullnullnull，就让它回到对方链表的头结点（如 AAA 回到 BBB 的头结点），然后继续两者同步前进.\n如此循环，若链表有相交，两者必然会在某时刻相遇于第一个相交结点.\n若链表不相交，两者必然相遇于 nullnullnull.\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;\n    struct ListNode *itA, *itB;\n    itA = headA;\n    itB = headB;\n\n\t\t\n    while (itA != itB) &#123;\n\t\t\t\t//两者都不为null且不相等时，同步前进\n        while (itA &amp;&amp; itB &amp;&amp; itA != itB) &#123;\n            itA = itA->next;\n            itB = itB->next;\n        &#125;\n\t\t\t\t//每次同步前进到有其中一个指针为null，则重定向该指针\n        if (itA == NULL &amp;&amp; itB != NULL) itA = headB;\n        if (itB == NULL &amp;&amp; itA != NULL) itB = headA;\n    &#125;\n\t\t//itA与itB相等时退出while，判断itA或itB，null则不交，非null则交\n    return itA;\n&#125;\n 力扣 1290. 二进制链表转整数\nhttps://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/\n辅助栈法\n用辅助栈将链表数据反向取出，按转换算法转成十进制。\nclass Solution &#123;\n    public int getDecimalValue(ListNode head) &#123;\n        if (head.next == null) &#123;\n            return head.val;\n        &#125;\n        //以下处理的链表长度大于1\n        int p = 0;\n        int count = 0;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n            count++;\n        &#125;\n        int sum = 0;\n        for (int i = 0; i &lt; count; i++) &#123;\n            sum += stk.pop() * Math.pow(2,p);\n            p++;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n移位法\n顺序遍历链表，每次将 sum 左移一位，再加上 x.val.\nclass Solution &#123;\n    public int getDecimalValue(ListNode head) &#123;\n        if (head.next == null) return head.val;\n        int sum = 0;\n        ListNode x;\n        for (x = head; x != null; x = x.next) &#123;\n            sum = (sum &lt;&lt; 1) + x.val;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n 力扣 876. 链表的中间节点\nhttps://leetcode-cn.com/problems/middle-of-the-linked-list/\n操作方法\n此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。\n代码实现\nclass Solution &#123;\n    public ListNode middleNode(ListNode head) &#123;\n        if (head.next == null) return head; //单元素链表，返回自己\n        if (head.next.next == null) return head.next;\n        //以下处理的链表长度至少为3\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast != null &amp;&amp; fast.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n拓展\n如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。\n 剑指Offer 22. 返回链表倒数第k个节点\nhttps://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\n两次遍历法\n先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode x;\n        int count = 0;\n        for (x = head; x.next != null; x = x.next) &#123;\n            count++;\n        &#125;\n        x = head;\n        for (int i = 0; i &lt;= count - k; i++) &#123;\n            x = x.next;\n        &#125;\n        return x;\n    &#125;\n&#125;\n定距同步双指针\n开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode p1;\n        ListNode p2;\n        p1 = head;\n        p2 = head;\n        for (int i = 0; i &lt; k; i++) &#123;\n            p2 = p2.next;\n        &#125;\n        while (p2 != null) &#123;\n            p1 = p1.next;\n            p2 = p2.next;\n        &#125;\n        return p1;\n    &#125;\n&#125;\n 力扣 237. 删除链表中的给定节点\nhttps://leetcode-cn.com/problems/delete-node-in-a-linked-list/\n操作方法\n此题传入参数为要删除的节点，这意味着我们无法访问之前的节点，也就无法通过修改前面节点的指向来实现删除。\n对于链表这种不连续存储的数据结构来讲，我们只关心它存储的值，所以我们可以有如下操作。\n不妨记传入的欲删除节点为 x ，它后面的两个节点依次为 y , z。\n先将 y 的 val 赋给 x，再将 x 指向 z ，即可删除 y 。\n代码实现\nclass Solution &#123;\n    public void deleteNode(ListNode node) &#123;\n        node.val = node.next.val;\n        node.next = node.next.next;\n    &#125;\n&#125;\n 力扣 83. 删除排序链表中的重复元素\nhttps://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\n快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。\nclass Solution &#123;\n    public ListNode deleteDuplicates(ListNode head) &#123;\n        //针对长度0、1、2的链表写特判\n        if (head == null) return head;\n        if (head.next == null) return head;\n        if (head.next.next == null) &#123;\n            if (head.val == head.next.val) &#123;\n                head.next = null;\n                return head;\n            &#125; else &#123;\n                return head;\n            &#125;\n        &#125;\n        //快慢指针\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast.next != null) &#123;\n            while (slow.val == fast.val &amp;&amp; fast.next != null) &#123;\n                fast = fast.next;\n            &#125;\n            if (fast.next != null) &#123;\n                slow = slow.next;\n                slow.val = fast.val;\n            &#125;\n        &#125;\n        if (fast.val > slow.val) &#123; \n            //注意，此处只有写大于号才能准确判定还有未出现的数需要前移\n            slow = slow.next;\n            slow.val = fast.val;\n        &#125;\n        slow.next = null;\n        return head;\n    &#125;\n&#125;\n 剑指Offer 06. 从尾到头打印链表\nhttps://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n使用辅助栈，遍历链表，全部压入再逐个弹出。\nclass Solution &#123;\n    public int[] reversePrint(ListNode head) &#123;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x;\n        int len = 0;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n            len++;\n        &#125;\n        int[] rec = new int[len];\n        for (int i = 0; i &lt; len; i++) &#123;\n            rec[i] = stk.pop();\n        &#125;\n        return rec;\n    &#125;\n&#125;\n","slug":"linklist_solutions","date":"2021-03-31T13:19:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,链表","author_index":"菲尔普斯"},{"id":"492f874b3f1df40af4ebb1f2f51478f5","title":"数据结构实现 | 堆","content":" 概述\n堆是一棵完全二叉树，满足如下性质：\n对于任意一个结点，其左、右子节点的值总是大于该节点的值（如果是最大堆则相反）.\n\n一般用一维数组模拟堆，惯例下标从 1 开始，遵循此规范有如下结论：\n若某节点索引为 iii，其左右儿子节点索引分别为 2i2i2i 与 (2i+1)(2i+1)(2i+1)，其父节点索引为 (i/2)(i/2)(i/2).\n若堆中元素个数（堆的大小）为 hsizehsizehsize，则堆的最后一个内点的索引为 (hsize/2)(hsize/2)(hsize/2).\n常见应用：\n\n最小堆实现 HuffmanHuffmanHuffman 算法\n堆排序的结构基础\n第 kkk 大(小) 数问题\n\n 代码实现\n 存储\n事先规定便捷记法如下\n#define ls(u) 2*u\n#define rs(u) 2*u+1\n#define fa(u) u/2\n用一维数组 h[]h[]h[] 存储最小堆，hsizehsizehsize 记录堆中元素个数\nconst int MAXN = 1e6 + 10;\n\nint h[MAXN], hsize;\n 下沉与上浮\n对于一个节点，有“上浮”和“下沉”两种操作，用于维护最小堆的结构.\n当一个节点对下不满足最小堆的性质时，就需要下沉；对上不满足性质时，就需要上浮.\n注意，up(x)up(x)up(x) 与 down(x)down(x)down(x) 都是递归定义的，例如，若对一个节点 xxx 调用 down()down()down()，则节点 xxx 会一直下沉到正确的位置为止.\n另外，若需要构建最大堆，只需要修改 up()up()up() 与 down()down()down() 中不等号的方向即可，其他函数都是通用的.\nvoid down(int u) &#123;\n\n\t//t是指向当前子树最小节点位置的指针\n    int t = u;\n\n\t//记得判左、右儿子是否存在\n    if (ls(u) &lt;= hsize &amp;&amp; h[ls(u)] &lt; h[t]) t = ls(u);\n    if (rs(u) &lt;= hsize &amp;&amp; h[rs(u)] &lt; h[t]) t = rs(u);\n\n    if (u != t) &#123;\n        swap(h[u], h[t]);\n        down(t); //记得递归继续down\n    &#125;\n&#125;\n\n//向上调整\nvoid up(int u) &#123;\n\n    int t = u;\n\t\n    //记得判父亲下标不能小于1\n    if (fa(u) >= 1 &amp;&amp; h[fa(u)] > h[t]) t = fa(u);\n\n    if (u != t) &#123;\n        swap(h[u], h[t]);\n        up(t);\n    &#125;\n&#125;\n 建堆\n以下是建堆函数，给出一个乱序序列 {hn}\\{h_n\\}{hn​}，存到 h[n]h[n]h[n] 中，再对 h[n]h[n]h[n] 调用 build_heap()build\\_heap()build_heap()，即可建成堆的结构.\n建堆的操作比较巧妙，从最后一个内点开始，自下往上逐层对每个结点调用 down()down()down() 函数，维护好每个内点负责的子树的结构，也就维护好了整个堆的结构.\n注意，在对上层节点调用 down()down()down() 时，也会通过递归对下层的子树进行调整.\nvoid build_heap() &#123;\n    for (int i = hsize / 2; i >= 1; i -- ) down(i);\n&#125;\n 插入与删除\n以下是插入和删除操作的实现，这两个函数有些类似。\n因为对于一个堆来讲，比较容易改动的，一般是堆顶和堆尾.\n当需要删除堆顶时，我们通常将堆顶和堆尾的值交换，然后对堆顶调用 down()down()down()，让换上去的元素下沉到合适的位置，同时删除堆尾，只需要让 hsizehsizehsize 减去 1 即可.\n//删除堆顶元素\nvoid remove_min() &#123;\n    h[1] = h[hsize];\n    hsize --;\n    down(1);\n&#125;\n当需要插入新元素时，直接插到堆尾，然后对新元素调用 up()up()up() 即可.\n//插入新元素并维护\nvoid insert(int x) &#123;\n    h[ ++ hsize ] = x;\n    up(hsize);\n&#125;\n 取堆顶\n返回序列的一号元素即可.\nint get_top() &#123;\n    return h[1];\n&#125;\n C++ STL 优先队列\n在 C++ 标准模板库中，堆被称为“优先队列”.\n实际上看来，其实这个称呼更符合堆的特点：\n\n便于改动的只有堆顶和堆尾，对应队头与队尾\n队列中的元素遵循某种“优先级”，如最小堆中值越小的元素优先级越高\n\n具体应用方式\n#include&lt;queue>\nusing namespace std;\n\npriority_queue&lt;int> heap;\n\n    heap.push(int val); //插入元素，内部包含排序\n    heap.pop();         //删除堆顶\n    heap.size();        //获取堆的大小\n    heap.top();         //获取堆顶元素\n    heap.empty();       //判空\n 典例应用\n 堆排序\n基本思路：将需要排序的序列建成堆，如果需要从小到大排列就建最小堆，需要从大到小排列就建最大堆，然后不断取堆顶元素并删除堆顶，直到堆空.\n注意，C++ STL 提供的优先队列默认为最大堆\n下面两种书写方式是等价的，建立的是最大堆\npriority_queue&lt;int> heap;\npriority_queue&lt; int, vector&lt;int>, less&lt;int> > heap;\n如果需要最小堆，则需要这样写\npriority_queue&lt; int, vector&lt;int>, greater&lt;int> > heap;\n下面提供一个原地排序的 Demo\n#include&lt;queue>\n#include&lt;iostream>\nusing namespace std;\n\n//从小到大排序，建立的是最小堆\nvoid heap_sort(int* arr, int len) &#123;\n    priority_queue&lt; int, vector&lt;int>, greater&lt;int> > heap;\n    for (int i = 0; i &lt; len; i ++ ) &#123;\n        heap.push(arr[i]);\n    &#125;\n    for (int i = 0; i &lt; len; i ++ ) &#123;\n        arr[i] = heap.top();\n        heap.pop();\n    &#125;\n&#125;\n\nint main() &#123;\n    int a[] = &#123;5, 7, 7, 8, 3, 2, 1, 10, 11, 99&#125;;\n    heap_sort(a,10);\n    for (int i = 0; i &lt; 10; i ++) cout &lt;&lt; a[i] &lt;&lt; \" \";\n    //输出结果为：\n    //1 2 3 5 7 7 8 10 11 99\n&#125;\n 第 k 大数\n基本思路：将所给序列建成最大堆，获取 kkk 次堆顶元素即可.\n下面给出简易 Demo\n#include&lt;queue>\n#include&lt;iostream>\nusing namespace std;\n\n//给出序列arr，返回序列中第k大的数，使用最大堆\nint kth_max(int* arr, int len, int k) &#123;\n    priority_queue&lt; int, vector&lt;int>, less&lt;int> > heap;\n    for (int i = 0; i &lt; len; i ++ ) &#123;\n        heap.push(arr[i]);\n    &#125;\n    int res;\n    while ( k -- ) &#123;\n        res = heap.top();\n        heap.pop();\n    &#125;\n    return res;\n&#125;\n\nint main() &#123;\n    int a[] = &#123;5, 7, 7, 8, 3, 2, 1, 10, 11, 99&#125;;\n    cout &lt;&lt; kth_max(a, 10, 3);\n    //输出结果为：\n    //10（第 3 大的数）\n&#125;\n Huffman 算法\nHuffmanHuffmanHuffman 算法通常用于求最优二叉树的问题.\n 什么是最优二叉树？\n定义一棵二叉树的权 W(T)W(T)W(T) 为所有叶子节点的权之和.\n对于每个叶子节点 iii，它的权 Wi=Vi⋅hW_i=V_i\\cdot hWi​=Vi​⋅h，其中 ViV_iVi​ 是该点的值，hhh 为该点在二叉树中的深度.（注意，此处的深度定义为从根节点出发到该节点的路径所包含的边数）\n给出 nnn 个节点，将它们作为叶子节点，构造出一棵具有特定结构的二叉树，使得 W(T)W(T)W(T) 最小，那么这棵树就叫做这 nnn 个节点所对应的最优二叉树.\n 哈夫曼算法\n从给出的所有节点中，每次选取两个入度为 0 且值最小的节点，将他们合并成一棵二叉树，父亲节点的值为两个节点的值之和.\n重复上述步骤，直到入度为 0 的顶点只有一个.\n最后，树的所有内点的值之和就等于 W(T)W(T)W(T).\n 例题\n以下是最优二叉树的典型例题.\n[NOIP 2004 提高组] 合并果子\n原题链接：https://www.luogu.com.cn/problem/P1090\n题意中的果子就是结点，果子的重量就是结点值，果子每被移动一次都会被多计算一次重量，可以抽象为结点在树中的深度，要求耗费体力最少，并求出该体力值，本质上就是求最优二叉树的权的问题.\n如何利用堆实现哈夫曼算法？\n我们考虑将果子的耗费体力序列构建成一个最小堆，每次取出两个最小的元素（即取堆顶并移除堆顶 2 次），再将这两个元素的和作为一个新元素加入堆中，如此循环，直到堆中只剩下一个元素.\n在每个步骤中，假设我们取出最小的两个数 aaa 和 bbb，然后把 (a+b)(a+b)(a+b) 加入堆中，上述行为导致最优二叉树中产生了一个值为 (a+b)(a+b)(a+b) 的内点，上面讲过，最优二叉树的权 W(T)W(T)W(T) 等于所有内点值之和，所以每产生一个内点，我们就应向答案 ansansans 中加入 (a+b)(a+b)(a+b). 如此重复到堆中只剩一个元素时，ansansans 就是所求答案.\n参考代码\n#include &lt;iostream>\n#include &lt;cstdio>\n#include &lt;algorithm>\n#include &lt;queue>\n#include &lt;vector>\n\nusing namespace std;\n\nint a[10001];\n\nint main() &#123;\n    priority_queue&lt;int, vector&lt;int>, greater&lt;int> > heap;\n\n    int n;\n    scanf(\"%d\", &amp;n);\n    for (int i = 1; i &lt;= n; i ++ ) &#123;\n        scanf(\"%d\", &amp;a[i]);\n        heap.push(a[i]);\n    &#125;\n    int ans = 0;\n    while (heap.size() > 1) &#123;\n        int a = heap.top();\n        heap.pop();\n        int b = heap.top();\n        heap.pop();\n        ans += (a + b);\n        heap.push(a + b);\n    &#125;\n    printf(\"%d\", ans);\n    return 0;\n&#125;","slug":"heap","date":"2021-03-29T08:26:00.000Z","categories_index":"算法题解/笔记","tags_index":"堆,数据结构","author_index":"菲尔普斯"},{"id":"787a127d9d6b0544e7ad2720504e8ca8","title":"数据结构实现 | 双链表","content":"本文给出用C语言实现双链表的代码。\n\n 基本结构\nstruct LNode &#123;\n    int data;\n    LNode* l;\n    LNode* r;\n&#125;;\n\ntypedef struct LNode LNode;\ntypedef struct LNode * LinkList；\n 操作实现\n 初始化链表\nLinkList init_linklist() &#123;\n    LNode* head = (LNode*)malloc(sizeof(LNode));\n    head->l = NULL;\n    head->r = NULL;\n    return head;\n&#125;\n 在给定节点后插入新节点\n//在节点p后插入值为x的节点\nbool insert_after(LNode* p, int x) &#123;\n    if (p == NULL) return false;\n    LNode* tmp = (LNode*)malloc(sizeof(LNode));\n    tmp->data = x;\n    tmp->l = p;\n    tmp->r = p->r;\n    if (p->r) p->r->l = tmp;\n    p->r = tmp;\n    return true;\n&#125;\n 在给定节点前插入新节点\n//在节点p前插入值为x的节点\nbool insert_before(LNode* p, int x) &#123;\n    return insert_after(p->l, x);\n&#125;\n 头插节点\n//在链表头插入值为x的节点\nbool add_front(LinkList L, int x) &#123;\n    if (L) &#123;\n        insert_after(L, x);\n        return true;\n    &#125; else &#123;\n        return false;\n    &#125;\n&#125;\n 删除给定节点\n//删除给出的p节点\nbool delete_node(LNode* p) &#123;\n    if (!p) return false;\n    if (p->r)  p->r->l = p->l;\n    p->l->r = p->r;\n    free(p);\n    return true;\n&#125; \n 获取链表长度\n//返回链表长度（若只有头节点，长度为0）\nint get_length(LinkList L) &#123;\n    if (L == NULL || L->r == NULL) return 0;\n    LNode* iterator = L->r;\n    int len = 0;\n    while (iterator) &#123;\n        len++;\n        iterator = iterator->r;\n    &#125;\n    return len;\n&#125;\n 链表判空\n//检查链表是否为空\nbool isEmpty(LinkList L) &#123;\n    if (L == NULL || L->r == NULL) return true;\n    else return false;\n&#125;\n 顺序打印链表\n//从头到尾打印整个链表\nvoid print_list(LinkList L) &#123;\n    if (!L) return;\n    LNode* iterator = L->r; \n    while (iterator) &#123;\n        cout &lt;&lt; iterator->data &lt;&lt; \" \";\n        iterator = iterator->r;\n    &#125;\n&#125;\n 按值查找节点\n//从头到尾查找，返回第一个值为val的节点\nLNode* get_node_by_val(LinkList L, int val) &#123;\n    if (L == NULL || L->r == NULL) return NULL;\n    LNode* t = L->r;\n    while (t) &#123;\n        if (t->data == val) return t;\n        t = t->r;\n    &#125;\n    return NULL;\n&#125;\n\n 参考测试代码\n\nint main() &#123;\n\n    LinkList test_list = init_linklist();\n\n    add_front(test_list, 30);\n    add_front(test_list, 29);\n    add_front(test_list, 28);\n\n    LNode* tmp1 = get_node_by_val(test_list, 30);\n\n    insert_after(tmp1, 100);\n    insert_before(tmp1, -100);\n\n    print_list(test_list);\n\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; get_length(test_list) &lt;&lt; endl;\n\n    delete_node(tmp1);\n\n    print_list(test_list);\n\n    LNode* tmp2 = get_node_by_val(test_list, 28);\n\n    delete_node(tmp2);\n\n    print_list(test_list);\n\n    return 0;\n&#125;","slug":"doubly_linklist_cpp","date":"2021-03-26T13:35:00.000Z","categories_index":"算法题解/笔记","tags_index":"数据结构,链表","author_index":"菲尔普斯"},{"id":"5eff4f497e442b4699b87d24ee757803","title":"数据结构实现 | 单链表","content":"本文给出用C语言实现单链表的代码。\n\n 基本结构（带头节点）\nstruct LNode\n&#123;\n    int data;\n    LNode* next;\n&#125;;\n\ntypedef struct LNode LNode;\ntypedef struct LNode* LinkList;\n 操作实现\n 初始化链表\n\n//Initialize the list and return a pointer to the head_node of the list\nLinkList init_linklist() &#123;\n    LNode* head = (LNode*)malloc(sizeof(LNode));\n    head->next = NULL;\n    return head;\n&#125;\n 顺序打印链表\n//Print the list from head to tail\n//Time Complexity: O(n)\nvoid print_list(LinkList L) &#123;\n    if (L == NULL) printf(\"NULLPTR_ERROR\");\n    if (L->next == NULL) printf(\"EMPTY_LIST\");\n    LNode* cur = L->next;\n    while (cur != NULL) &#123;\n        printf(\"%d \",cur->data);\n        cur = cur->next;\n    &#125;\n&#125;\n 头插节点\n//Insert a node at the front of the list\n//Time Complexity: O(1)\nvoid add_front(LinkList L, int x) &#123;\n    LNode* p = (LNode*)malloc(sizeof(LNode));\n    p->data = x;\n    p->next = L->next;\n    L->next = p;\n&#125;\n 按序号查找节点\n//Find the val of a node with certain number, if it exists.\n//The number given should starts from 1\n//Time Complexity: O(n)\nbool get_val_by_num(LinkList L, int num, int* res) &#123;\n    if (L == NULL || L->next == NULL) return false;\n    if (num &lt;= 0 || res == NULL) return false;\n    LNode* cur = L->next;\n    int cnt = 0;\n    while (cur != NULL) &#123;\n        cnt ++;\n        if (cnt == num) &#123;\n            *res = cur->data;\n            return true;\n        &#125;\n        cur = cur->next;\n    &#125;\n    return false;\n&#125;\n 按值查找节点\n//Return the first node whose data equals val, or return NULL\n//Time Complexity: O(n)\nLNode* get_by_val(LinkList L, int val) &#123;\n    if (L == NULL) printf(\"NULLPTR_ERROR\");\n    if (L->next == NULL) printf(\"EMPTY_LIST\");\n    LNode* cur = L->next;\n    while (cur != NULL) &#123;\n        if (cur->data == val) return cur;\n        else cur = cur->next;\n    &#125;\n    return NULL;\n&#125;\n 在给定节点之后插入新节点\n\n//Insert a new node with certain val after the given node p\n//Then return a pointer pointed to the new node\n//Time Complexity: O(1)\nLNode* insert_after(LNode* p, int val) &#123;\n    if (p == NULL) return NULL;\n    LNode* t = (LNode*)malloc(sizeof(LNode));\n    t->data = val;\n    t->next = p->next;\n    p->next = t;\n    return t;\n&#125;\n 在给定节点之前插入新节点\n\n//Insert a new node with certain val before the given node p\n//Then return a pointer pointed to the new node\n//Time Complexity: O(1)\nLNode* insert_before(LNode* p, int val) &#123;\n    if (p == NULL) return NULL;\n    LNode* t = insert_after(p, val);\n    swap(p->data, t->data);\n    return p;\n&#125;\n 删除给定节点\n//Delete the given node in the list, if it does exist\nbool delete_node(LinkList L, LNode* p) &#123;\n    if (L == NULL || L->next == NULL) return false;\n    if (p == NULL) return false;\n    //This indicates that p is not the last node\n    //We can swap the data of p and the node t after it, then delete t\n    if (p->next != NULL) &#123;\n        LNode* t = p->next;\n        swap(p->data, t->data);\n        p->next = t->next;\n        free(t);\n        return true;\n    &#125; else &#123;\n        //This indicates that p is the last node\n        //We need to iterate the list to find the prior node of p\n        LNode* pr = L;\n        bool found = false;\n        while (!found) &#123;\n            if (pr->next == p) &#123;\n                pr->next = NULL;\n                free(p);\n                found = true;\n            &#125;\n            pr = pr->next;\n        &#125;\n        return found;\n    &#125;\n&#125;\n 获取链表长度\n//Return the length of the list\n//If the list only has the head-node, its length gonna be 0\nint get_length(LinkList L) &#123;\n    int cnt = 0;\n    if (L == NULL || L->next == NULL) return cnt;\n    LNode* cur = L;\n    while (cur->next != NULL) &#123;\n        cur = cur->next;\n        cnt ++;\n    &#125;\n    return cnt;\n&#125;\n\n 参考测试代码\nint main() &#123;\n\n    /*---TESTING_CODE---*/\n\n    LinkList lst = init_linklist();\n    add_front(lst, 5);\n    add_front(lst, 1);\n    add_front(lst, 7);\n    print_list(lst);\n\n    LNode* t1 = get_by_val(lst, 8);\n    if (t1 != NULL) printf(\"%d\\n\",t1->data);\n    else printf(\"t1_NULL\\n\");\n\n    LNode* t2 = get_by_val(lst, 5);\n    if (t2 != NULL) printf(\"%d\\n\",t2->data);\n    else printf(\"t2_NULL\\n\");\n\n    int res1, res2, res3, res4;\n\n    get_val_by_num(lst, 1, &amp;res1);\n    get_val_by_num(lst, 2, &amp;res2);\n    get_val_by_num(lst, 3, &amp;res3);\n    get_val_by_num(lst, 4, &amp;res4);\n\n    cout &lt;&lt; res1 &lt;&lt; \" \" &lt;&lt; res2 &lt;&lt; \" \" &lt;&lt; res3 &lt;&lt; \" \" &lt;&lt; res4 &lt;&lt; \" \" &lt;&lt; endl;\n\n    LNode* tar = get_by_val(lst, 5);\n    insert_after(tar, 999);\n    insert_before(tar, 666);\n    print_list(lst);\n\n    printf(\"\\n\");\n\n    LNode* toDel = get_by_val(lst, 999);\n    delete_node(lst, toDel);\n    print_list(lst);\n\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; get_length(lst) &lt;&lt; endl;\n\n    LinkList emptylst = init_linklist();\n\n    add_front(emptylst, 789);\n\n    print_list(emptylst);\n\n    cout &lt;&lt; get_length(emptylst) &lt;&lt; endl;\n\n    /*---END---*/\n\n    return 0;\n&#125;","slug":"singly_linklist_cpp","date":"2021-03-20T14:25:00.000Z","categories_index":"算法题解/笔记","tags_index":"数据结构,链表","author_index":"菲尔普斯"},{"id":"52b22c68a76813c2ab065580311ca50e","title":"基础算法 | 前缀和","content":"Description: 前缀和是处理区间查询的快速手段。\n\n 基本概念\n 一维前缀和\n用数列观点理解就是前 nnn 项和，原序列是 ana_nan​，它的前缀和就是\nSn=∑i=1naiS_n=\\sum_{i=1}^{n} a_i\nSn​=i=1∑n​ai​\n对于序列 {an}\\{a_n\\}{an​} ，需要查询区间 [l,r][l,r][l,r] 上所有元素的和，一般做法是 O(n)O(n)O(n) 的线性扫描.\n但如果需要频繁查询，那么一般先对序列 {an}\\{a_n\\}{an​} 做预处理，做出它的前缀和序列 {Sn}\\{S_n\\}{Sn​}.\n当需要区间 [l,r][l,r][l,r] 上的和时，只需要计算 Sr−Sl−1S_r-S_{l-1}Sr​−Sl−1​ ，可在 O(1)O(1)O(1) 内完成.\n 二维前缀和\n可用矩阵来理解（或者看成网格），a[i][j]a[i][j]a[i][j] 存储一个二维数据图，它的前缀和为\nS[i][j]=∑i=1n∑j=1ma[i][j]S[i][j]=\\sum_{i=1}^{n} \\sum_{j=1}^{m}a_[i][j]\nS[i][j]=i=1∑n​j=1∑m​a[​i][j]\n简单来说，二维前缀和 S[i][j]S[i][j]S[i][j] 表示矩阵前 iii 行、前 jjj 列的和.\n根据原矩阵构造其对应二位前缀和的公式为\n\nS[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j]S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1]+a[i][j]\nS[i][j]=S[i−1][j]+S[i][j−1]−S[i−1][j−1]+a[i][j]\n构造完二维前缀和后，我们可以方便地求出任意子矩阵的和.\n例如求从 (x1,y1)(x_1,y_1)(x1​,y1​) 到 (x2,y2)(x_2,y_2)(x2​,y2​) 的子矩阵和 sumsumsum.（类似容斥原理）\nsum=S[x2][y2]−S[x1−1][y2]−S[x2][y1−1]+S[x1−1][y1−1]sum=S[x_2][y_2]-S[x_1-1][y_2]-S[x_2][y_1-1]+S[x_1-1][y_1-1]\nsum=S[x2​][y2​]−S[x1​−1][y2​]−S[x2​][y1​−1]+S[x1​−1][y1​−1]\nTips: 当空间非常紧张的时候，可以原地计算前缀和并覆盖原矩阵，即每计算出一个 S[i][j]S[i][j]S[i][j] ，就用它覆盖掉 a[i][j]a[i][j]a[i][j] ，可以省掉另外开一个 S[][]S[][]S[][] 数组的空间开销.\n 典型例题\n P1387 最大正方形\n\n先用二维前缀和预处理地图，然后三重循环，最外层从 min(m,n)min(m,n)min(m,n) 到 111 枚举正方形边长 rrr ，内层枚举坐标，从 (r,r)(r,r)(r,r) 到 (n,m)(n,m)(n,m)，一旦这个区域的前缀和 ans=r2ans = r^2ans=r2 ，直接 breakbreakbreak 并返回边长 rrr.\n#include &lt;iostream>\n#include &lt;cstdlib>\n#include &lt;cstdio>\n\nusing namespace std;\n\nconst int MAXN = 101;\n\nshort map[MAXN][MAXN];\n\nint main() &#123;\n    int n, m;\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for (int i = 1; i &lt;= n; i ++ ) &#123;\n        for (int j = 1; j &lt;= m; j ++ ) &#123;\n            scanf(\"%d\", &amp;map[i][j]);\n        &#125;\n    &#125;\n\n    for (int i = 1; i &lt;= n; i ++ ) &#123;\n        for (int j = 1; j &lt;= m; j ++ ) &#123;\n            map[i][j] += map[i][j-1] + map[i-1][j] - map[i-1][j-1];\n        &#125;\n    &#125;\n\n    int ans;\n\n    for (int r = min(m,n); r >= 1; r -- ) &#123;\n        for (int i = r; i &lt;= n; i ++ ) &#123;\n            for (int j = r; j &lt;= m; j ++ ) &#123;\n                ans = map[i][j] - map[i-r][j] - map[i][j-r] + map[i-r][j-r];\n                if (ans == r * r) &#123;\n                    printf(\"%d\", r);\n                    exit(0);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 0;\n&#125;\n [HNOI 2003] 激光炸弹\n 分析\n本题将地图看成网格，点的价值看作矩阵元素的值，抽象之后即：给定一个 5000∗50005000*50005000∗5000 大小的矩阵，求 R∗RR*RR∗R 子矩阵元素和的最大值.\n因为计算前缀和过程中会出现 [i−1][j−1][i-1][j-1][i−1][j−1]，为防止越界，地图数据从 (1,1)(1,1)(1,1) 开始记录.\n输入矩阵后，预处理，做出二维前缀和，遍历前缀和，记录最大值即可.\n 注意\n此题卡空间，空间最大限制 125 MB.\n如果开两个 5000∗50005000*50005000∗5000 的 int 型二维数组（一个记录原地图，一个做前缀和），要用 191 MB.\n如果开一个  5000∗50005000*50005000∗5000 的 int 型二维数组放前缀和，再开一个  5000∗50005000*50005000∗5000 的 short 型二维数组放原矩阵（因为原矩阵元素值不超过 1000 ，可用short），总共要用 143 MB.\n上述方案都不行.\n考虑只开一个   5000∗50005000*50005000∗5000 的 int 型二维数组，先输入原矩阵，然后一边计算前缀和一边覆盖，总共使用内存 95 MB，满足要求.\n另外注意边界的处理，边界坐标之间加一减一的关系.\n 代码\n#include &lt;iostream>\n#include &lt;algorithm>\n\nusing namespace std;\n\nconst int MAXN = 5010;\nconst int bd = 5001;\n\nint N, R;\nint map[MAXN][MAXN];\nint res;\n\nint main()\n&#123;\n    cin >> N >> R;\n    \n    //Input the map (data = value)\n    for (int i = 1; i &lt;= N; i++)\n    &#123;\n        int x, y, w;\n        cin >> x >> y >> w;\n        map[x + 1][y + 1] = w;\n    &#125;\n    \n    //Make the prefix of the map\n    for (int i = 1; i &lt;= bd; i++)\n    &#123;\n        for (int j = 1; j &lt;= bd; j++)\n        &#123;\n            map[i][j] += map[i-1][j] + map[i][j-1] - map[i-1][j-1];\n        &#125;\n    &#125;\n    \n    //Iterate the prefix\n    for (int i = 1; i &lt;= bd - R + 1; i++)\n    &#123;\n        for (int j = 1; j &lt;= bd - R + 1; j++)\n        &#123;\n            int temp;\n            temp = map[i+R-1][j+R-1] - map[i-1][j+R-1] - map[i+R-1][j-1] + map[i-1][j-1];\n            res = max(res,temp);\n        &#125;\n    &#125;\n    \n    cout &lt;&lt; res;\n    \n    return 0;\n&#125;","slug":"prefix_sum","date":"2021-03-13T12:30:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,前缀和","author_index":"菲尔普斯"},{"id":"e445da7add089c24366d851e311436a7","title":"《富爸爸穷爸爸》读书笔记","content":"Description: 一本改变底层财富思维的好书。\n\n 前置知识\n 收获\n 资产和负债\n资产把钱放进你的口袋，负债将钱从你的口袋中取走。\n富人用现金购置资产，再用资产产生的增值收入来消费。而穷人用现金购买负债，成为金钱的奴隶。\n为什么应当把房子看作负债而非资产？\n\n把大部分钱都用在购置房产上，丢失了大量的现金和投资的机会及其带来的经验\n伴随着购置房产而来的各种税收、管理费、物业费增加了大量的支出\n房子一直在贬值\n\n如何看待奢侈品？\n\n奢侈品是对懂得合理投资、积累真正资产的人的奖励\n\n什么是真正的资产？\n\n不需要我到场就可以正常运作的业务，我拥有他们，但由别人经营和管理\n股票\n债券\n能够产生收入的房地产（例如用于租赁）\n票据（借据）\n版税（如音乐、手稿、专利、知识产权）\n其他任何有价值、可产生收入或有增值潜力的东西\n\n个人的想法\n“一无所有”的年轻人的资产项是什么？是精力、知识、业务能力、眼界，还有思维模式。在尚未进入社会工作获得稳定的收入之前，我们应将更多的现金（从父母那儿来的零花钱）用于购买资产，也就是投资自己，例如读书开阔眼界、健身、提升个人形象、发展业务能力、开拓人脉资源等等；将尽可能少的现金用于购买负债，如娱乐设备、不必要的食品、不必要的消费品和不能增值的玩具等等。\n 财务知识\n我们需要丰富以下四个方面的财务知识，作为作出合理投资的基本知识储备。\n会计：解读数字的额能力，评估生意的优势和劣势\n投资：钱生钱的科学和策略\n了解市场：供给与需求的科学\n法律：利用合法手段避税，以及在诉讼中获得保护\n 克服困难\n\n恐惧\n\n不要选择逃避，即便逃避往往最省事\n利用恐惧和压力使自己更强壮\n\n\n愤世嫉俗\n\n选择学会分析现实，而不是只会批评和抱怨\n成功者在分析中看到机会，失败者在抱怨中度过一生\n\n\n懒惰\n\n避免用忙碌掩饰懒惰\n贪婪一点儿\n太多的贪心不是好事，但一点点贪心可以刺激你不断前行\n\n\n改掉不良习惯\n\n先支付给自己，再支付给他人，而不是反过来\n\n\n\n 采取行动\n\n停下手头的活，对它们进行评估和分析\n积极阅读和交谈，吸纳新的思想\n邀请你想了解领域的专家共进午餐，获取信息\n合理利用信息不对称与对方周旋（打电话给我的小猫）\n学会到市场上宣传、营销、报价、谈判\n\n 经典语录\n生活是一门课程，但这门课程并不会用语言来教你，它只是推着你转。在这个过程中，有些人会变得愤怒并把这些气发泄到他的老板或者他爱的人身上，而有些人却从中学会了很多东西，并欢迎生活来推动他们。\n恐惧把你推出门外，欲望又开始召唤你。这就是陷阱。\n更多的钱只会让你头脑中现金流的方式更加明显，如果你的模式是把收入都花掉，那么最可能的结果是在增加收入的同时也增加支出。正所谓，“蠢人用蠢钱”。\n记住黄金规则：有黄金的人制定规则。\n雇员的工作只会使雇主或股东更加富有，而不能使他们自己富有。\n人们耗尽一生去关注别人的事业并使他人致富。、\n80% 的家庭的财务报表表现的是一份拼命工作、努力争先的图景，然而他们的努力都打了水漂，因为他们购买的是负债而非资产。\n真正的奢侈品是对投资和积累真正资产的奖励。\n雇员挣钱、纳税，并靠剩下的钱为生；企业挣钱、花钱，并只为剩下来的钱缴税。这是富人钻的最大的法律空子。\n金钱不是真实的资产，它只是一种大家都认可的东西。\n今天的问题是成千上万的人对自己的欲望或贪婪感到内疚，这是他们在少年时代就养成的陈旧思维。他们渴望拥有生活中那些更美好的东西，但大部分人却下意识地调整了自己的心态，并对自己说：“我不能拥有这个”，或者是“我可付不起”。\n“我可付不起”禁锢了你的思想，使你无法进一步思考；“我怎样才能付得起”开启了你的头脑，迫使你去思考并寻求答案。\n大部分人让那些债主把沙子踢到脸上，而我决定利用对债主的恐惧使自己变得更加强壮。\n如果你知道自己在某一问题上有所欠缺，你就应该找一位本领域的专家或是一本相关的书，马上开始教育自己。\n“我志在将每一次灾难转化成机会。”——洛克菲勒\n愤世嫉俗者抱怨现实，而成功者分析现实。\n我从未见过不曾打丢一球的高尔夫选手，也从未见过不曾伤心过的恋人，更未见过从不亏钱的富人。\n","slug":"rich_dad_poor_dad","date":"2020-12-17T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"菲尔普斯"},{"id":"f474005b89a7d8e14b470713255edb89","title":"MySQL 学习笔记","content":"本文记录笔者学习 MySQL 的过程和笔记\n\n 下载和安装\nCommunity Server 免费\nhttps://dev.mysql.com/downloads\n 术语\n\n\n\nTerm\nDescription\nRemarks\n\n\n\n\nDB\nDatabase\n\n\n\nDBMS\nDatabase Management System\n如 MySQL\n\n\nRDBMS\nRelational Database Management System\n关系型数据库管理系统\n\n\nDBA\nDatabase Administrator\n\n\n\nSQL\nStructure Query Language\n\n\n\nDDL\nData Definition Language\n如 CREATE，ALTER，DROP\n\n\nDML\nData Manipulation Language\n如 SELECT，INSERT\n\n\nDCL\nData Control Language\n\n\n\n\n 命令\n 检查安装状态\nmysql --version\n 服务启动与停止\n启动服务\nnet start mysql0130  # your sql service name\n停止服务\nnet stop mysql0130\n 登录\n命令行\nmysql -h 主机名 -P 端口号 -u root -p\n 基本操作\n# 查看所有数据库\nSHOW DATABASES\n\n# 打开指定数据库\nUSE 数据库名\n\n# 查看当前数据库的所有表\nSHOW TABLES\n\n# 查看非当前库的所有表\nSHOW TABLES FROM 数据库名\n\n# 查看表结构\nDESC 表名\n\n# 在当前库中创建表\nCREATE TABLE 表名\n(\n    列名 数据类型,\n    列名 数据类型,\n    ...\n)\n 常用数据类型\n\n\n\nDataType\nExpression\n\n\n\n\n整型\nint\n\n\n字符串\nvarchar(max_size)\n\n\n\n SELECT 语句\n# 选择所有\nSELECT * FROM 表名\n\n# 选择指定列\nSELECT 列名1,列名2... FROM 表名\n\n# 选择所有互不相同的值\nSELECT DISTINCT 列名 FROM 表名\n\n# 选择某字段满足一定条件的行\nSELECT * FROM 表名 WHERE 与字段相关的条件表达式\n\n# 多条件选择\nSELECT * FROM 表名 WHERE (条件1 AND 条件2) OR 条件三\n\n# 枚举范围内选择\nSELECT * FROM 表名 WHERE 字段 IN (值1, 值2, ...)\n\n# 区间范围内选择\nSELECT * FROM 表名 WHERE 字段 BETWEEN 值1 AND 值2\n\n# 模糊选择\nSELECT * FROM 表名 WHERE 条件 LIKE 带通配符的表达式\nSELECT * FROM 表名 WHERE 条件 NOT LIKE 带通配符的表达式\n\n# 限制选择的条目数\nSELECT * FROM 表名 WHERE 条件 LIMIT 最多显示记录条数\n\n# 查询常量/表达式\nSELECT 常量/表达式\n\n# 给查询字段起别名\nSELECT 字段1 AS 字段1别名, 字段2 AS 字段2别名 ... FROM 表名 WHERE 条件\n INSERT 语句\n# 在指定表中插入完整新行\nINSERT INTO 表名 VALUES(值1,值2...)\n\n# 在指定表中插入新行并指定某些列的数据\nINSERT INTO 表名 (列1,列2...) VALUES(值1,值2...)\n UPDATE 语句\n# 更新指定位置数据\nUPDATE 表名 SET 字段名 = 新值 WHERE 条件表达式\n DELETE 语句\n# 删除指定行\nDELETE FROM 表名 WHERE 条件表达式\n\n# 删除所有行\nDELETE * FROM 表名\n 其他语句\n# 查看 MySQL 版本\nSELECT VERSION()\n 通配符\n% 代替一串任意长度的字符\n_ 代替一个字符\n[ABC] 代替“A或B或C”\n[!ABC] 上述结果取反\n\n\n\n\n\n\n\n\n\n[charlist] 通配符在 MySQL 中不适用，若需要则必须使用正则表达式\n 关于 + 号\n\n不像 Java 中那样，SQL 表达式中的 + 只充当运算符，没有连接符功能\n两个操作数都是数值型，则做加法运算\n若操作数中有字符型，则将字符型转换为数值，若转换不成功，就当作 0\n一旦操作数中有 null 则运算结果必定为 null\n\n 常用函数\n# 连接若干个字符串\nCOMCAT(字符串A, 字符串B, ...)\n\n/*\n * 例如，将 first_name 和 last_name 字段合并，中间加空格\n * SELECT COMCAT(first_name, ' ', last_name) FROM mytable\n */\n 细节规范\n\nSQL 对大小写不敏感，但建议关键字大写，具体数据名小写\n字符串由单引号包围\n单行注释用 #，多行注释与 java 相同\nSQL 中不区分字符和字符串\n\n","slug":"mysql_note","date":"2020-12-03T03:24:00.000Z","categories_index":"数据库","tags_index":"数据库,MySQL","author_index":"菲尔普斯"},{"id":"754f99333c5dda7ed7c4177b7a031b14","title":"Java 学习日记","content":"记录 Java 学习之路的点点滴滴\n\n2020/12/06\n\n面向对象基础 6\n\n多态性\n\n父类的引用指向子类的对象\n该对象的方法列表与父类相同\n当该对象调用它的某个方法时，若该方法被子类重写过，则实际执行的是子类的方法\n多态是方法的多态，与属性无关\n\n\n\n\n\n2020/12/05\n\n是的，今天太nm忙了，没学💔\n\n2020/12/04\n\n面向对象基础 5\n\n方法的重写\n\n子类继承父类之后，可以重写父类的同名同参方法\n重写方法的权限修饰符不允许降级\n父类中的私有方法不允许子类重写\n假设被重写方法的返回值为 A 类型，则重写方法的返回值类型只能是 A 或 A 的子类（若是基本数据类型则必须严格相同）\n重写方法抛出的异常类型不大于被重写方法的抛出异常类型\n静态方法不可以被重写\n@Override 注解\n\n\nsuper 与 this 关键字\n\n父类和子类的属性可以同名（没有覆盖之说）\n用 this 调属性时，先从本类找起，找不到再逐步往上去父类找\n用 super 调属性时，跳过本类，从直接父类开始往上找，直到找到为止\nsuper() 表示直接调用父类构造器\n\n\n\n\n\n2020/12/03\n\nJDBC\n\nClient / Server 和 Browser / Server 架构的对比\nJavaWeb 知识框架概览\n\n\n数据库\n\nMySQL 安装与基本配置\nSQL 的基本查询语句学习\n\n\n\n2020/12/02\n\n面向对象基础 4\n\n继承性\n\nextends 关键字\n父类 (SuperClass) 与子类 (SubClass)\n直接父类与间接父类\n继承内容包括父类的属性和方法\nJava 只支持单继承和多层继承（即子类的父类最多只能有一个，与人类社会规则相似）\n自定义类默认继承于 java.lang.Object 类\nIDEA 中快捷键 Ctrl + H 可调出 Hierarchy 视图查看继承树\n\n\n项目二 客户信息管理系统\n\nMVC 模式简单实践\nCustomer 类封装数据对象\nCustomerList 类负责对象管理与增删改查等逻辑\nCustomerView 类负责视图界面与用户响应\n\n\n\n\n\n2020/12/01\n\n面向对象基础 3\n\n\nimport static 关键字\n\n用于导入某个包下的静态结构\n例如 import static java.lang.Math.* 之后可以不用再写 Math.\n\n\n\nimport 关键字\n\n用于导入某个包下的指定类/接口（不包括子包中的结构）\n写在导包语句的后面\n使用 .* 代表导入包内的所有类/接口\njava.lang 包的导入默认省略\n若要使用不同包下的同名类，则在类名前面加包名即可\n\n\n\npackage 关键字\n\n使用包管理类\n声明在每个下属类文件的首行\n命名中 . 代表文件目录层级\n同一包下的类和接口不允许出现同名\nJDK 提供的常用包\n\n\n\nPackage Name\nClasses Included\n\n\n\n\njava.lang\nString，System，Math，Object 等核心类\n\n\njava.util\n日期日历、集合框架等实用工具类\n\n\njava.io\n输入/输出功能类\n\n\njava.net\n与网络有关的操作接口\n\n\njava.sql\n进行 JDBC 数据库编程的有关类和接口\n\n\njava.awt\n用于构建 GUI 的有关类\n\n\njava.text\n格式化相关类\n\n\n\n\n\n\n\nthis() 调用构造器\n\n高级构造器调用低级构造器，减少代码冗余\n若要调用必须写在第一行\n\n\n\nthis 关键字\n\n在方法内部使用，表示方法所属对象的引用\n在构造器内部使用，表示正在构造的对象\n\n\n\nUML 类图\n\n\nJavaBean（符合以下标准的类）\n\n类是公共的\n有一个空参的构造器\n有属性以及对应的访问器和设置器\n\n\n\n构造器 Constructor\n\n未自定义构造器时，系统默认提供空参构造器，一旦自定义，那么系统不会再提供，空参构造器也要自己写\n不应理解为特殊的方法\n可以设置权限\n可重载，用于创建对象、初始化属性\n\n\n\n类的属性的封装\n\n权限\n\n设置为 private 不允许直接访问和修改\n\n\n访问器\n\n提供公共的 getVal 方法获取值\n\n\n设置器\n\n相比直接调属性赋值，设置器可以提供检查输入规范的入口，防止出现非法数据赋值\n\n\nIDEA 右键空白处 Generate 可以一键生成 Getter and Setter\n\n\n\n权限修饰符\n\n\n\n\n类的内部\n同一个包下\n不同包的子类\n同一个工程\n\n\n\n\nprivate\n√\n\n\n\n\n\n(default)\n√\n√\n\n\n\n\nprotected\n√\n√\n√\n\n\n\npublic\n√\n√\n√\n√\n\n\n\n\n\n\n\n\n\n\n\n\nClass 只能被 public 或 (default) 修饰，(default) 类跨包不可用\n总结：跨包仅 public 可见，包内 (default) 与 public 可见.\n\n\n\n\n2020/11/30\n\n面向对象基础 2\n\n构造器 Setter\n\n类要写在主类外面才能用 this\n\n\n访问器 Getter\n对象数组的内存解析\n\n栈空间存数组首地址，堆空间存数组内容\n数组元素的值为对象的地址（地址中包含了对象的类型）\n\n\n匿名对象\n\n直接调用仅限一次\n常用于方法传参\n\n\n自定义工具类\n\n将自己常用的函数封装到自己的类库中\n只要在同一个 package 下就可以调用\n调用前需要先 new 一个 工具类对象\n\n\n方法的重载\n\n同名方法，参数类型/个数不同\n可变个数的形参\n\npublic void method(String ... strs) &#123;&#125;\n可变个数指的是 0 个 ~ 多个\n一个方法最多传一个可变形参\n必须放在参数列表最后一个\n会与数组传参的方式冲突（两者不构成重载）\n在函数内需要遍历时直接当作数组来操作\n\n\n\n\n引用和传参\n\n参数传递都是值传递\n基本数据类型传数据值，引用数据类型传地址值\n对象之间赋值，只是赋地址，指向堆空间中同一个对象\n\n\n\n\n关于 println() 方法\n\n传入参数为非 char 数组名时，打印出来的是首地址值\n传入 char[] 数组名时，由于 PrintStream 库中 println() 方法单独对字符数组做了重载，打印出来的结果是整个字符数组的所有元素连在一起组成的字符串\n\n\n\n2020/11/29\n\n\n面向对象基础 1\n\n与面向过程的区别\n\n面向过程注重事件和函数\n面向对象注重类和对象的抽象设计\n\n\n类和对象\n属性和方法\n对象的引用\n对象的内存解析\n\n栈空间存放引用和地址\n堆空间存放数据块\n\n\n成员变量和局部变量\n\n局部变量没有权限修饰符\n局部变量没有默认初始化值\n非 static 属性加载到堆空间，局部变量加载到栈空间\n\n\n\n\n\n常见数组异常\n\nArraysIndexOutOfBoundsException 下标越界\nNullPointerException 空指针异常\n\n\n\n常用数组方法\n\nArrays.equals(int[] a, int[] b) 判断两数组是否相同\nArrays.fill(int[] arr, int val) 以指定值填充数组\nArrays.toString(int[] a) 转换为便于输出的字符串\nArrays.sort(int[] a) 底层为快排\nArrays.binarySearch(int[] a) 二分查找\n\n\n\n一维、二维数组的内存解析\n\n栈空间放地址\n堆空间放内容\n二维数组声明时第一维长度不能省略\n二维数组内容为地址\n垃圾回收机制检测没有指针指向的内存进行回收\n\n\n\n2020/11/28\n\nInteliJ IDEA 2020 安装与基本配置\nIDEA Key Map\n常用 IDEA Templates\n自定义 Templates\nIDEA 连接 Github 进行 Clone、Push、Share\nIDEA Debugger 断点调试 Step 与变量监视 Evaluate\n\n笔记： 尚硅谷_宋红康_IntelliJIDEA的安装、配置与使用.pdf\n","slug":"java_learning_log","date":"2020-11-27T16:00:00.000Z","categories_index":"Java","tags_index":"Java,日志","author_index":"菲尔普斯"},{"id":"badbb3e5dd9e6f65834da5c97268e39f","title":"数据结构 | 优先队列","content":"本文介绍数据结构——优先队列\n\n 代码实现\n前置辅助函数\nprivate boolean less(int i, int j)\n&#123;\n    return pq[i].compareTo(pq[j]) &lt; 0;\n&#125;\n\nprivate void exch (int i, int j)\n&#123;\n    int t = pq[i];\n    pq[i] = pq[j];\n    pq[j] = t;\n&#125;\n\nprivate void swim(int k)\n&#123;\n    while (k > 1 &amp;&amp; less(k/2,k))\n    &#123;\n        exch(k/2,k);\n        k = k/2;\n    &#125;\n&#125;\n\nprivate void sink(int k)\n&#123;\n    while (2*k &lt;= N)\n    &#123;\n        int j = 2*k;\n        if (j &lt; N &amp;&amp; less(j,j+1)) j++;\n        if (!less(k,j)) break;\n        exch(k,j);\n        k = j;\n    &#125;\n&#125;\n核心代码\npublic class MaxPQ&lt;Key extends Comparable&lt;Key>>\n&#123;\n    private Key[] pq;\n    private int N = 0; //堆中元素个数\n\n    /*创建一个大小为maxN的堆*/\n    public MaxPQ(int maxN)\n    &#123;\n        pq = (Key[]) neww Comparable[maxN+1];\n    &#125;\n\n    /*询问堆是否为空*/\n    public boolean isEmpty()\n    &#123;\n        return N == 0;\n    &#125;\n\n    /*询问堆的元素个数*/\n    public int size()\n    &#123;\n        return N;\n    &#125;\n\n    /*向堆插入值为val的元素并维护堆*/\n    public void insert(Key val)\n    &#123;\n        pq[++N] = val;\n        swim(N);\n    &#125;\n\n    /*删除并返回堆顶元素，交换堆顶与尾部元素，并维护堆*/\n    public Key delMax()\n    &#123;\n        Key max = pq[1];\n        exch(1,N);\n        N--;\n        pq[N+1] = null; //防止对象游离\n        sink(1);\n        return max;\n    &#125;\n&#125;","slug":"priority_queue","date":"2020-11-22T02:15:00.000Z","categories_index":"算法题解/笔记","tags_index":"排序,堆,数据结构,优先队列","author_index":"菲尔普斯"},{"id":"25a96685fe17a48f8d20d0ff79f5d30e","title":"买卖股票的最佳时机 I","content":"\n\n 题目\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。\n注意：你不能在买入股票前卖出股票。\n示例 1:\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n示例 2:\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 解法\n 暴力扫描\n使用双重嵌套循环，外层循环从头到尾遍历 prices[]，内层循环遍历从 prices[i] 到 prices[len-1]，寻找位于 i 之后的 j 使得 prices[j] 与 prices[i] 差值最大。\n时间复杂度 O(n2)O(n^2)O(n2) ，扫描次数为 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 次，不使用额外空间。\nclass Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        /*Special Judge*/\n        if (prices.length == 0 || prices.length == 1) return 0;\n        if (prices.length == 2) &#123;\n            if (prices[1] - prices[0] > 0) &#123;\n                return prices[1] - prices[0];\n            &#125; else &#123;\n                return 0;\n            &#125;\n        &#125;\n        int now = 0;\n        int max_price = 0;\n        int max_profit = 0;\n        int len = prices.length;\n        for (int i = 0; i &lt; len; i++) &#123;\n            //在第i天买入\n            for (int j = i+1; j &lt; len; j++) &#123;\n                //寻找利润最高的第j天，当天卖出\n                if (prices[j] > max_price &amp;&amp; prices[j] > prices[i]) &#123;\n                    max_price = prices[j];\n                &#125;\n            &#125;\n            if (max_price - prices[i] > max_profit) &#123;\n                max_profit = max_price - prices[i];\n            &#125;\n            max_price = 0;\n        &#125;\n        return max_profit;\n    &#125;\n&#125;\n 优化做法\n我们需要的结果是后面减前面的最大利润差。\n假设我们现在处于第 i 天，我们可以认为，我们有穿越到过去的能力，能够穿越到第 i 天之前的历史最低点买入股票，再穿越回来，把股票卖掉，这样一来，未来的变数我们虽然不知道，但我们得到了第 i 天当天内的最优解。\n这样一来，在 i 从头遍历到尾的过程中，我们只要用一个变量 max_profit 记录并更新我们曾经见过的最大利润差，在遍历完成后，返回 max_profit 即可。\n由于只要扫描一次，时间复杂度 O(n)O(n)O(n) ，空间复杂度 O(1)O(1)O(1).\nclass Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        /*Corner Case*/\n        if (prices.length == 0 || prices.length == 1) return 0;\n        if (prices.length == 2) &#123;\n            if (prices[1] - prices[0] > 0) &#123;\n                return prices[1] - prices[0];\n            &#125; else &#123;\n                return 0;\n            &#125;\n        &#125;\n        /*以下处理的价格数组长度至少为3*/\n        int len = prices.length;\n        int history_low = 10000000; //今天之前的历史最低价格，初始值要很大，保证一开始就能被覆盖\n        int now_profit = 0;  //如果今天卖出，能赚的利润\n        int max_profit = 0;  //到今天位置，曾出现的最大利润差\n        for (int i = 1; i &lt; len; i++) &#123;\n\n            //每天参考昨天的价格，更新历史最低价或者不更新\n            history_low = Math.min(prices[i-1], history_low);\n\n            //如果能卖，计算今天卖出与历史最低价的利润差\n            if (prices[i] > history_low) &#123;\n                now_profit = prices[i] - history_low;\n                //更新最大利润差\n                max_profit = Math.max(now_profit, max_profit);\n            &#125;\n            \n            //清空缓存的“当天利润差”，进入下一天\n            now_profit = 0;\n        &#125;\n        return max_profit;\n    &#125;\n&#125;\n 一维动态规划\n设 dp[i] 表示在第 i 天卖出手里股票得到的最大利润，history_low 表示截止第 i-1 天的历史最低股价。\n状态转移方程为\ndp[i]=max(dp[i−1], prices[i]−history_low)dp[i] = max \\left( dp[i-1], \\  prices[i] - history\\_low \\right)\ndp[i]=max(dp[i−1], prices[i]−history_low)\n代码如下\nclass Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        /*Corner Case*/\n        if (prices.length == 0 || prices.length == 1) return 0;\n        if (prices.length == 2) &#123;\n            if (prices[1] - prices[0] > 0) &#123;\n                return prices[1] - prices[0];\n            &#125; else &#123;\n                return 0;\n            &#125;\n        &#125;\n        /*以下处理的价格数组长度至少为3*/\n        int len = prices.length;\n        int history_low = 10000000; //今天之前的历史最低价格，初始值要很大，保证一开始就能被覆盖\n        int[] dp = new int[len];\n        dp[0] = 0;\n        for (int i = 1; i &lt; len; i++) &#123;\n            //每天参考昨天的价格，更新历史最低价或者不更新\n            history_low = Math.min(prices[i-1], history_low);\n            if (prices[i] > history_low) &#123;\n                //如果能卖，计算今天卖出与历史最低价的利润差\n                dp[i] = Math.max(dp[i-1], prices[i] - history_low);\n            &#125; else &#123;\n                //如果不能卖，则最大利润差不变，直接复制上一个dp的值\n                dp[i] = dp[i-1];\n            &#125;\n        &#125;\n        return dp[len-1];\n    &#125;\n&#125;\n 比较与分析\n暴力扫描法最容易想到，但时间复杂度实在太高，不讨论。\n一维动态规划的做法，性能上其实不如第二种做法，因为它使用了一个长度为 prices.length 的数组 dp[] 来存储每天计算出的最大利润差，而本质上，dp[i] 的值只与 dp[i-1] 和其他常数个辅助变量有关，所以没必要浪费存储空间，只需要使用2个变量，分别是 now_profit 和 max_profit 来记录当天利润差和历史最大利润差就可以了。\n但是，动态规划胜在思路更加清晰易得，容易分析和入手，以后可以考虑先用DP思想思考问题，解决完之后，再考虑空间存储上的优化问题。\n","slug":"best_time_to_buy_and_sell_stock","date":"2020-11-21T06:28:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,动态规划","author_index":"菲尔普斯"},{"id":"46ae5e42bd44ebce1177f4935501ecb2","title":"算法技巧 | 双指针","content":"\n\n 一、快慢指针\n No.26 删除排序数组中的重复项\n图解（搬运）\n\n代码实现\nclass Solution &#123;\n    public int removeDuplicates(int[] nums) &#123;\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return 1;\n        if (nums.length == 2) &#123;\n            if (nums[0] == nums[1]) return 1;\n            else return 2;\n        &#125;\n        int len = nums.length;\n        int slow = 0;\n        int fast = 1;\n        while (fast &lt; len - 1) &#123;\n            if (nums[fast] == nums[slow]) &#123;\n                fast++;\n            &#125; else &#123;\n                slow++;\n                nums[slow] = nums[fast];\n            &#125;\n        &#125;\n        //fast位于末尾时，额外写判断，因为while不处理最后边界情况\n        if (nums[slow] == nums[fast]) &#123;\n            return slow+1;\n        &#125; else &#123;\n            slow++;\n            nums[slow] = nums[fast];\n            return slow+1;\n        &#125;\n    &#125;\n&#125;\n No.83 删除排序链表中的重复元素\n快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。\nclass Solution &#123;\n    public ListNode deleteDuplicates(ListNode head) &#123;\n        //针对长度0、1、2的链表写特判\n        if (head == null) return head;\n        if (head.next == null) return head;\n        if (head.next.next == null) &#123;\n            if (head.val == head.next.val) &#123;\n                head.next = null;\n                return head;\n            &#125; else &#123;\n                return head;\n            &#125;\n        &#125;\n        //快慢指针\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast.next != null) &#123;\n            while (slow.val == fast.val &amp;&amp; fast.next != null) &#123;\n                fast = fast.next;\n            &#125;\n            if (fast.next != null) &#123;\n                slow = slow.next;\n                slow.val = fast.val;\n            &#125;\n        &#125;\n        if (fast.val > slow.val) &#123; \n            //注意，此处只有写大于号才能准确判定还有未出现的数需要前移\n            slow = slow.next;\n            slow.val = fast.val;\n        &#125;\n        slow.next = null;\n        return head;\n    &#125;\n&#125;\n No.876 链表的中间节点\n操作方法\n此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。\n代码实现\nclass Solution &#123;\n    public ListNode middleNode(ListNode head) &#123;\n        if (head.next == null) return head; //单元素链表，返回自己\n        if (head.next.next == null) return head.next;\n        //以下处理的链表长度至少为3\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast != null &amp;&amp; fast.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n拓展\n如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。\n 二、同步双指针\n 剑指Offer 22. 返回链表倒数第k个节点\n两次遍历法\n先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode x;\n        int count = 0;\n        for (x = head; x.next != null; x = x.next) &#123;\n            count++;\n        &#125;\n        x = head;\n        for (int i = 0; i &lt;= count - k; i++) &#123;\n            x = x.next;\n        &#125;\n        return x;\n    &#125;\n&#125;\n定距同步双指针\n开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode p1;\n        ListNode p2;\n        p1 = head;\n        p2 = head;\n        for (int i = 0; i &lt; k; i++) &#123;\n            p2 = p2.next;\n        &#125;\n        while (p2 != null) &#123;\n            p1 = p1.next;\n            p2 = p2.next;\n        &#125;\n        return p1;\n    &#125;\n&#125;\n 剑指Offer 24. 反转链表\n\n辅助栈法\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x,y;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n        &#125;\n        for (y = head; y != null; y = y.next) &#123;\n            y.val = stk.pop();\n        &#125;\n        return head;\n    &#125;\n&#125;\n原地反转（三指针法）\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        /*使用三根指针是为了在改变next过程中保证衔接*/\n        \n        if (head == null) return null;\n        if (head.next == null) return head;\n        //以上特判已经排除链表长度小于2的情况\n\n        //三指针同步向前移动\n        ListNode pre, cur, fu;\n        pre = null;\n        cur = head;\n        fu = head.next;\n        while (fu != null) &#123;\n            cur.next = pre;\n            pre = cur;\n            cur = fu;\n            fu = fu.next;\n        &#125; //while结束后，最后一个节点尚未反转\n\n        //反转尾节点\n        cur.next = pre;\n        return cur;\n    &#125;\n&#125;\n","slug":"double_cursor","date":"2020-11-20T07:31:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,双指针","author_index":"菲尔普斯"},{"id":"54c60bbbb328f6fecc301009ec40ba1d","title":"数据结构 | 链表","content":"Description: 本文介绍链表的常见操作和题型。\n\n 基本操作\n以下为下文中提到的链表定义\n/*Definition for singly-linked list.*/\npublic class ListNode &#123;\n    int val;\n    ListNode next;\n    ListNode(int x) &#123; val = x; &#125;\n&#125;\n 一、遍历\n链表遍历模板\nListNode head;\nListNode x;\nfor (x = head; x != null; x = x.next) &#123;\n    /*Operations*/\n&#125;\n No.1290 二进制链表转整数\n辅助栈法\n用辅助栈将链表数据反向取出，按转换算法转成十进制。\nclass Solution &#123;\n    public int getDecimalValue(ListNode head) &#123;\n        if (head.next == null) &#123;\n            return head.val;\n        &#125;\n        //以下处理的链表长度大于1\n        int p = 0;\n        int count = 0;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n            count++;\n        &#125;\n        int sum = 0;\n        for (int i = 0; i &lt; count; i++) &#123;\n            sum += stk.pop() * Math.pow(2,p);\n            p++;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n移位法\n顺序遍历链表，每次将 sum 左移一位，再加上 x.val.\nclass Solution &#123;\n    public int getDecimalValue(ListNode head) &#123;\n        if (head.next == null) return head.val;\n        int sum = 0;\n        ListNode x;\n        for (x = head; x != null; x = x.next) &#123;\n            sum = (sum &lt;&lt; 1) + x.val;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n No.876 链表的中间节点\n操作方法\n此题是典型的快慢指针题，快指针 fast 和慢指针 slow 从同一起点出发，fast 每次走2步，slow 每次走1步，当 fast 走到链表尾时，slow 正好处于链表中点，剩余的细节用 corner case 微调即可。\n代码实现\nclass Solution &#123;\n    public ListNode middleNode(ListNode head) &#123;\n        if (head.next == null) return head; //单元素链表，返回自己\n        if (head.next.next == null) return head.next;\n        //以下处理的链表长度至少为3\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast != null &amp;&amp; fast.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n拓展\n如果对快慢指针步长的倍数关系进行调整，应该还能够实现返回链表的几分之一位置的节点，具体实现待补充。\n 剑指Offer 22. 返回链表倒数第k个节点\n两次遍历法\n先扫描整个链表获取长度 count ，重新扫描一次到 count - k 位置即可获取倒数第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode x;\n        int count = 0;\n        for (x = head; x.next != null; x = x.next) &#123;\n            count++;\n        &#125;\n        x = head;\n        for (int i = 0; i &lt;= count - k; i++) &#123;\n            x = x.next;\n        &#125;\n        return x;\n    &#125;\n&#125;\n定距同步双指针\n开局先定义两个指针 p1 和 p2，都指向 head ，然后控制它们起始距离为 k，然后同步前进，当领先的指针走到表尾时，后面的指针恰好到达第k个节点。\nclass Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n\n        ListNode p1;\n        ListNode p2;\n        p1 = head;\n        p2 = head;\n        for (int i = 0; i &lt; k; i++) &#123;\n            p2 = p2.next;\n        &#125;\n        while (p2 != null) &#123;\n            p1 = p1.next;\n            p2 = p2.next;\n        &#125;\n        return p1;\n    &#125;\n&#125;\n 二、插入\n\n\n 三、删除\n No.237 删除链表中的给定节点\n操作方法\n此题传入参数为要删除的节点，这意味着我们无法访问之前的节点，也就无法通过修改前面节点的指向来实现删除。\n对于链表这种不连续存储的数据结构来讲，我们只关心它存储的值，所以我们可以有如下操作。\n不妨记传入的欲删除节点为 x ，它后面的两个节点依次为 y , z。\n先将 y 的 val 赋给 x，再将 x 指向 z ，即可删除 y 。\n代码实现\nclass Solution &#123;\n    public void deleteNode(ListNode node) &#123;\n        node.val = node.next.val;\n        node.next = node.next.next;\n    &#125;\n&#125;\n No.83 删除排序链表中的重复元素\n快慢指针，与一维数组的快慢指针操作非常相似，只需要在处理完之后，将 slow 所指节点的 next 设为 null ，将后面的多余部分链表丢弃即可。\nclass Solution &#123;\n    public ListNode deleteDuplicates(ListNode head) &#123;\n        //针对长度0、1、2的链表写特判\n        if (head == null) return head;\n        if (head.next == null) return head;\n        if (head.next.next == null) &#123;\n            if (head.val == head.next.val) &#123;\n                head.next = null;\n                return head;\n            &#125; else &#123;\n                return head;\n            &#125;\n        &#125;\n        //快慢指针\n        ListNode slow, fast;\n        slow = head;\n        fast = head;\n        while (fast.next != null) &#123;\n            while (slow.val == fast.val &amp;&amp; fast.next != null) &#123;\n                fast = fast.next;\n            &#125;\n            if (fast.next != null) &#123;\n                slow = slow.next;\n                slow.val = fast.val;\n            &#125;\n        &#125;\n        if (fast.val > slow.val) &#123; \n            //注意，此处只有写大于号才能准确判定还有未出现的数需要前移\n            slow = slow.next;\n            slow.val = fast.val;\n        &#125;\n        slow.next = null;\n        return head;\n    &#125;\n&#125;\n 四、反转\n 剑指Offer 06. 从尾到头打印链表\n使用辅助栈，遍历链表，全部压入再逐个弹出。\nclass Solution &#123;\n    public int[] reversePrint(ListNode head) &#123;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x;\n        int len = 0;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n            len++;\n        &#125;\n        int[] rec = new int[len];\n        for (int i = 0; i &lt; len; i++) &#123;\n            rec[i] = stk.pop();\n        &#125;\n        return rec;\n    &#125;\n&#125;\n 剑指Offer 24. 反转链表\n\n辅助栈法\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        if (head == null) return null;\n        if (head.next == null) return head;\n        Stack&lt;Integer> stk = new Stack&lt;Integer>();\n        ListNode x,y;\n        for (x = head; x != null; x = x.next) &#123;\n            stk.push(x.val);\n        &#125;\n        for (y = head; y != null; y = y.next) &#123;\n            y.val = stk.pop();\n        &#125;\n        return head;\n    &#125;\n&#125;\n原地反转（三指针法）\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        /*使用三根指针是为了在改变next过程中保证衔接*/\n        \n        if (head == null) return null;\n        if (head.next == null) return head;\n        //以上特判已经排除链表长度小于2的情况\n\n        //三指针同步向前移动\n        ListNode pre, cur, fu;\n        pre = null;\n        cur = head;\n        fu = head.next;\n        while (fu != null) &#123;\n            cur.next = pre;\n            pre = cur;\n            cur = fu;\n            fu = fu.next;\n        &#125; //while结束后，最后一个节点尚未反转\n\n        //反转尾节点\n        cur.next = pre;\n        return cur;\n    &#125;\n&#125;\n","slug":"linked_list","date":"2020-11-20T01:23:00.000Z","categories_index":"算法题解/笔记","tags_index":"数据结构,链表","author_index":"菲尔普斯"},{"id":"73e8a6d436c7d2e8181ea6bdbf6ed786","title":"LC 26 删除排序数组中的重复项","content":" 题目\n给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。\n\n示例 1:\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n示例 2:\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i &lt; len; i++) &#123;\n    print(nums[i]);\n&#125;\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n本题是典型的双指针题型中的快慢指针法，两个指示变量、O(1)额外空间、一次for循环就可以搞定。\n慢指针 slow 只有在快指针 fast 遇到新朋友时，才会前进1个单位，同时将新朋友复制到 slow 的当前位置来。\n不过，此题能这样做的前提是数组本身有序，有序保证了重复元素必然聚集在一起，而不是分散在各处。\n如果重复元素散乱分布，那么判断 fast 当前所指元素是否在之前已经出现过就不仅仅是将 nums[slow] 与 nums[fast] 比较这么简单了。\n 代码\nclass Solution &#123;\n    public int removeDuplicates(int[] nums) &#123;\n        //测试数据一定会有极端，特判和简单情况记得先写\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return 1;\n        if (nums.length == 2) &#123;\n            if (nums[0] == nums[1]) return 1;\n            else return 2;\n        &#125;\n        int len = nums.length;\n        int slow = 0;\n        int fast = 1;\n        //此处while条件不能写等号，否则fast移动到末尾之后会进入死循环\n        while (fast &lt; len - 1) &#123;\n            if (nums[fast] == nums[slow]) &#123;\n                fast++;\n            &#125; else &#123;\n                slow++;\n                nums[slow] = nums[fast];\n            &#125;\n        &#125;\n        //fast位于末尾时，额外写判断，因为while不处理最后边界情况\n        if (nums[slow] == nums[fast]) &#123;\n            return slow+1;\n        &#125; else &#123;\n            slow++;\n            nums[slow] = nums[fast];\n            return slow+1;\n        &#125;\n        //题目要求返回新数组长度而不是索引，所以加一\n    &#125;\n&#125;","slug":"remove_duplicates_in_sorted_array","date":"2020-11-20T00:15:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,双指针","author_index":"菲尔普斯"},{"id":"49d9ab5fe10d0180f622045a55f67fdd","title":"算法 | 二分查找","content":"本文整理 LeetCode 上二分查找的相关题型。\n\n 基本知识\n时间复杂度：O(logn)O(logn)O(logn)\n空间复杂度：O(1)O(1)O(1)\n 递归实现\npublic static int rank(int key, int[] a, int lo, int hi)\n&#123;\n    if (lo > hi) return -1;\n    int mid = lo + (hi-lo) / 2;\n    if      (key &lt; a[mid]) return rank(key, a, lo, mid-1);\n    else if (key > a[mid]) return rank(key, a, mid, hi);\n    else                   return mid;\n&#125;\n 非递归实现\npublic static int BinarySearch(int[] nums, int target)\n&#123;\n    if (nums == NULL || nums.length == 0) return -1;\n    int left = 0;\n    int right = nums.length - 1; //要减1，搜索区间左闭右闭\n    while (left &lt;= right) &#123; //小于等于\n        int mid = left + (right-left) / 2; //防溢出\n        if (nums[mid] &lt; target) &#123;\n            left = mid + 1;\n        &#125; else if (nums[mid] > target) &#123;\n            right = mid - 1;\n        &#125; else if (nums[mid] == target) &#123;\n            return mid;\n        &#125;\n    &#125;\n    return -1;\n&#125;\n 常见注意事项\n\n是否需要保证搜索区间大于某个长度？（在 while 处修改循环条件）\n\n LeetCode相关题目\n 一、模板题\nNo.704 二分查找\nNo.374 猜数字大小\nNo.35 搜索插入位置\nNo.278 第一个错误版本\nNo.275 H指数 II\n 二、数列求和问题\nNo.367 有效的完全平方数\nNo.69 x的平方根\nNo.441 排列硬币\n 三、查找重复数的左右边界\nNo.34 在排序数组中查找元素的第一个和最后一个位置（Medium）\n整体思路\n二分查找整体框架不变，主要改动在于找到 target 之后的操作。\nmid 命中目标之后，从目标位置出发，向左右扩展（最多扩展至 left 和 right ），分别用 l_bound 和 r_bound 表示扩展器的左、右边界，最后返回 l_bound 和 r_bound 即可。\n注意细节\n\nl_bound 和 r_bound 最后会多移动一步，需要增加一个判断，判断边界是否计入。\n一定要小心边界是否取等，目的是防止数组访问越界。\n\n代码实现\nclass Solution &#123;\n    public int[] searchRange(int[] nums, int target) &#123;\n        int left = 0;\n        int right = nums.length - 1;\n        int mid;\n        int l_bound;\n        int r_bound;\n        int[] result = new int[2];\n        while (left &lt;= right) &#123;\n            mid = left + (right - left) / 2;\n            if (nums[mid] &lt; target) left = mid + 1;\n            else if (nums[mid] > target) right = mid - 1;\n            else if (nums[mid] == target) &#123;\n                l_bound = mid;\n                r_bound = mid;\n                while (nums[l_bound] == target &amp;&amp; l_bound > left) &#123;\n                    l_bound--;\n                &#125;\n                if (nums[l_bound] != target) l_bound++; //边界检查\n                while (nums[r_bound] == target &amp;&amp; r_bound &lt; right) &#123;\n                    r_bound++;\n                &#125;\n                if (nums[r_bound] != target) r_bound--; //边界检查\n                result[0] = l_bound;\n                result[1] = r_bound;\n                return result;\n            &#125;\n        &#125;\n        result[0] = -1;\n        result[1] = -1;\n        return result;\n    &#125;\n&#125;\n 四、与奇偶有关的二分\nNo.540 有序数组中的单一元素\n思路分析\n整体框架依然是二分查找。\n每次检查 nums[mid] 与它左侧或右侧的元素是否相同，去除掉这对相同元素后，分别计算左、右两侧剩余数字的个数——如果是偶数，说明里面的数都是成对的；如果是奇数，说明我们要找的“落单数”就在里面。\n然后我们将搜索区间转移到奇数侧，继续搜索。\n由于操作时用到了 nums[mid-1] 与 nums[mid+1] ，所以为了防止数组访问越界，我们需要保证当前搜索区间的长度大于等于3，所以 while 处的循环条件需要稍微改一下。\n最后 while 循环完成后，判断一下剩下的区间长度是1还是3（不可能是2），然后分别做出相应的处理即可。\n代码实现\nclass Solution &#123;\n    public int singleNonDuplicate(int[] nums) &#123;\n        if (nums.length == 1) return nums[0];\n            int left = 0;\n            int right = nums.length - 1;\n            int mid;\n            while (right - left > 2) &#123;\n                mid = left + (right - left) / 2;\n                if (nums[mid] == nums[mid-1]) &#123;\n                    if ((mid+1) % 2 == 1) &#123; //奇数个\n                        right = mid - 2;\n                    &#125; else &#123; //偶数个，不在这\n                        left = mid + 1;\n                    &#125;\n                &#125; else if (nums[mid] == nums[mid+1])&#123;\n                    if ((mid+2) % 2 == 1) &#123;\n                        right = mid - 1;\n                    &#125; else &#123;\n                        left = mid + 2;\n                    &#125;\n                &#125; else &#123;\n                    return nums[mid];\n                &#125;\n            &#125;\n            if (right - left == 0) return nums[left];\n            if (right - left == 2) &#123;\n                if (nums[left] == nums[left+1]) return nums[right];\n                if (nums[right] == nums[right-1]) return nums[left];\n            &#125;\n            return 0;\n    &#125;\n&#125;\n 五、与动态规划结合\n待补充\n 六、与树相关的问题\n面试题 04.02 最小高度树\n给定一个有序数组 nums[] ，要求构建一棵高度最小的二叉树。\n树的高度要尽可能小，意味着两边的数据分布尽可能均匀，可以构建二叉搜索树。\n任何一棵子树，父节点的值必大于左儿子，且小于右儿子。\n可以利用二分法构建，给定一个序列，选取 mid 作为根节点，由 mid 左边的子序列构建左子树，由 mid 右边的子序列构建右子树，如此递归。当序列左右边界错位（序列为空）时，递归出口，返回 null 。\n/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public TreeNode sortedArrayToBST(int[] nums) &#123;\n        return helper(nums, 0, nums.length - 1);\n    &#125;\n\n    public TreeNode helper (int[] num, int left, int right) &#123;\n        /*递归出口*/\n        if (right &lt; left) return null;\n\n        int mid = left + (right - left) / 2;\n        TreeNode root = new TreeNode(num[mid]);\n        root.left = helper(num,left,mid-1);\n        root.right = helper(num,mid+1,right);\n        return root;\n    &#125;\n&#125;","slug":"binary_search","date":"2020-11-19T12:34:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,二分查找","author_index":"菲尔普斯"},{"id":"a3ba6c10f076994138a9054fc0850b9a","title":"LC 378 有效的完全平方数","content":" 题目\n给定一个正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 True ，否则返回 False 。\n说明：不要使用任何内置的库函数，如 sqrt 。\n\n示例 1：\n输入：16\n输出：True\n示例 2：\n输入：14\n输出：False\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-perfect-square\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n 二分查找\n二分法查找序列 [2,3,...num/2]（如果输入1直接返回 true ），逐个计算当前数的平方，与 num 比较，如果能找到，说明是完全平方数，否则不是完全平方数。\n 牛顿迭代\n相当于要查找 f(x)=x2−numf(x)=x^2-numf(x)=x2−num 的根，用牛顿迭代法。\n迭代方程为\nf(xk)−0xk−xk+1=f′(xk)\\frac{f(x_k)-0}{x_k-x_{k+1}} = f&#x27;(x_k)\nxk​−xk+1​f(xk​)−0​=f′(xk​)\n化简得递推方程\nxk+1=xk−f(xk)f′(xk)x_{k+1}=x_k-\\frac{f(x_k)}{f&#x27;(x_k)}\nxk+1​=xk​−f′(xk​)f(xk​)​\n也即\nxk+1=(12xk−numxk)x_{k+1}=\\left( \\frac{1}{2}x_k-\\frac{num}{x_k} \\right)\nxk+1​=(21​xk​−xk​num​)\n取 xk=numx_k = numxk​=num 作初始值，用递推式迭代，每次返回 x * x == num\n 等差数列求和\n等差数列 $ a_n = 2n-1 $ 求和\nSn=(1+2n−1)n2=n2S_n = \\frac{(1+2n-1)n}{2}=n^2\nSn​=2(1+2n−1)n​=n2\n也即\nn2=1+3+5+7+...+(2n−1)n^2 = 1+3+5+7+...+(2n-1)\nn2=1+3+5+7+...+(2n−1)\n利用该性质，从1开始，不断向 num 减去递增的奇数项，每减一次就执行一次判断，判断 num 是否为0，若出现 num 被减成0的情况，说明是完全平方数，否则不是。\n 代码\n最优方法：数列求和法\nclass Solution &#123;\n    public boolean isPerfectSquare(int num) &#123;\n        int i = 1;\n        while (num > 0) &#123;\n            num -= i;\n            i += 2; \n        &#125;\n        if (num == 0) return true;\n        else return false;\n    &#125;\n&#125;","slug":"valid_perfect_square","date":"2020-11-19T06:53:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,二分查找","author_index":"菲尔普斯"},{"id":"7b9ffc72b5a7cb190c30b47bbc422642","title":"搞设计必备的工具/资源/网站","content":"给看官们推荐一下笔者常用的设计资源和网站\n\n Dribbble—灵感之源\n\n\nDribbble 是全球最大的在线设计交流网站，来自世界各地的顶尖设计师经常在该站上发布自己的作品。\n笔者平时会经常上去观摩大师的设计，获取配色灵感，提高审美标准，同时get到设计界的最新潮流。\n笔者坚信，多欣赏优秀的设计作品是提高设计感觉的重要方式。\n什么是设计感觉？\n当你拿到一组内容时，脑子里浮现出的东西——如何排版布局？间距应该宽松还是紧凑？这样的内容使用什么风格更有表现力和冲击力？是 Material 还是 圆角弥散阴影风 ？使用 衬线字体 还是 无衬线字体 ？\n以上都属于 设计感觉 的范畴。\n该网站上展示的设计作品种类很多——各种风格的插画、App UI设计图、网页设计图、图标设计集、LOGO设计集等等…\n这里截取 Dribbble 上的几幅 Shots 供大家欣赏。\n\n\n\n\n\n\n iSlide—万能插件\n讲到设计，就不得不讲到我们的老朋友 Power Point.\n熟悉笔者的朋友都知道，平时笔者大部分的设计都是使用我们最熟悉的软件 Microsoft Power Point 来完成的。\n比如，下面的 展示页面 或 Banner 都是我用PPT完成的。\n思政课课堂展示封面\n\n\n微信公众号卡片内容呈现\n\n\n公众号推文首图\n\n\n会议PPT封面\n\n\n清华大学录取名单卡片\n\n\n言归正传，Power Point 之所以能成为我快速实现设计想法的得力助手，离不开 iSlide 这款PPT插件的功劳。\n\n\n\niSlide是集强大的排版布局功能、内容丰富的素材库于一身的一款PPT设计辅助插件。\n在笔者看来，这款插件最有价值的功能当属其即拿即用的素材库——包含大量的图标素材、图片素材和矢量插画。\n\n\n\n\n有了上述的辅助，再搭配简单的阴影和渐变，做出下面的Banner图简直不要太轻松~~\n\n\n\n关于iSlide插件的介绍就先到这里，实话实说，笔者对其强大功能仍知之甚少，还需要不断地实践与探索，欢迎读者与笔者分享你的使用心得~\n ICONFONT—图标资源\n笔者有一个习惯——在做PPT展示或页面设计时，遇到具有 并列关系 的内容需要 分点罗列 时，笔者会在每个内容条目前加上一个与内容相关的小图标，而不是选择使用干巴巴的 项目符号 。\n\n\n\n因为笔者相信，形象化的表达比干涩的文字更有感染力，图标就是它的灵魂。\n那么如何方便快捷地寻找我们需要的图标呢？\n这里笔者推荐阿里巴巴的图标站：https://www.iconfont.cn\n在搜索栏键入关键字就能找到有关的大量图标。\n如下图搜索 Folder 便可以找到与“文件夹”有关的图标。\n\n\n\n点击图标弹出下载界面，可以自定义图标的颜色，在线生成 .svg ，.ai ，.png 等格式的图标，非常便捷。一般来说，在设计PPT时，下载 PNG 格式即可，其清晰度足以满足设计需要。\n\n\n\n WebGradients—渐变配色灵感\nWebGradients是一个专注于提供渐变配色方案的网站，进入主页即可看到很多以圆形填充展示的渐变色搭配。\n每种配色方案都提供两端的16进制色码，还可以直接复制 CSS 样式代码，也可以下载 PNG 或者 Sketch 格式的文件。\n\n\n\n网址：https://webgradients.com/\n另外，若需要将16进制色码转换为 RGB 或 HSL 色码，可到以下网站。\nhttps://www.sioe.cn/yingyong/yanse-rgb-16/\n Eagle—素材管理\n\n\nEagle是笔者最近才开始使用的一款设计素材管理软件，当初听说它一群设计师使用 Electron 开发的，顿时让笔者产生了极大的兴趣。\n上手试用一番后，产品的整体使用体验非常棒。Eagle客户端支持包括图片、PPTX、AI、PS、字体等设计素材的管理。\n主要管理方式有：文件夹分类管理，标签Tags分类管理，主色调分类管理。\n\n\n\n\n还支持根据主色调、文件类型、图片形状等属性快速筛选图片素材，爱了爱了。\n\n\n\n Procreate—手绘插画\n\n\nProcreate这款App相比不需要笔者过多介绍了，强烈建议手持 iPad + Apple Pencil 的朋友入手，软件操作非常简单，极易上手。笔者在平时空闲时也喜欢画画人像，权当学习之余的放松方式，还是非常好的。（虽然入学以后就没画过了…）\n\n\n\n\n今天关于设计的分享就到这里，以后笔者会不定期回来补充~\n","slug":"design_tools","date":"2020-11-06T16:00:00.000Z","categories_index":"设计","tags_index":"工具,设计,PPT","author_index":"菲尔普斯"},{"id":"046faba7a426676dc1392c6c7d530460","title":"科学上网教程","content":"备注：我只是推荐一个个人认为价格便宜、稳定性和速度兼具、不需要复杂配置的梯子，没有任何商业挂钩行为，如果大家有更好梯子，欢迎推荐\n\n 一、注册账号\n 1.访问https://www.yahaha.co/\n\n 2.注册账号并登录\n**备注：**邀请码不用填，分子式一般按 CHONS 的顺序，如果写对了却没通过往往是元素顺序不规范，调整顺序试试\n\n 二、支付宝充值\n 1.登录进入主页后，找到充值区，点击进入\n\n 2.用支付宝扫码充值（这个网站不支持微信支付）\n**备注：**个人建议输入 16HKD（折合人民币大约13.8元），因为我下面会推荐我个人觉得很好用且正在用的流量套餐，价格为 16HKD/月 （这个网站提供多种不同的流量套餐，可以自主选择，我只是给出推荐）\n\n 三、购买套餐\n点击左边导航栏的“套餐购买”，会跳转到套餐选择页面，我个人用的是图中圈出的 轻量-月限速 ，大家可以自己选择。\n点击购买后弹出“输入优惠码”，不用理会，直接点取消即可。\n\n 四、使用方法\n1.点击左边导航 用户中心 ，回到主页，向下滑动，找到 教程一览\n\n2.选择 我用SSR ，按照下方步骤操作\n\n","slug":"scientific_web","date":"2020-11-05T11:30:00.000Z","categories_index":"工具","tags_index":"工具,技巧","author_index":"菲尔普斯"},{"id":"bfed4d6aac2d701f6b1f0bbff9221463","title":"LC 771 宝石与石头","content":" 题目\n给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n\nJ 中的字母不重复，J 和 S 中的所有字符都是字母。字母区分大小写，因此 &quot;a&quot; 和 &quot;A&quot; 是不同类型的石头。\n示例 1:\n输入: J = \"aA\", S = \"aAAbbbb\"\n输出: 3\n示例 2:\n输入: J = \"z\", S = \"ZZ\"\n输出: 0\n注意:\nS 和 J 最多含有50个字母。\n J 中的字符不重复。\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/jewels-and-stones\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n传统方法的时间复杂度必然来源于遍历 S 的同时需要不断对 J 进行时间复杂度为O(n)的线性查找，使用哈希表来储存 J 即可提高查找速度。\n 代码\nclass Solution &#123;\n    public int numJewelsInStones(String J, String S) &#123;\n        if (J.length() == 0) return 0;\n        if (S.length() == 0) return 0;\n        int diamond_nums = 0;\n        HashMap&lt;Character, Integer> diamond = new HashMap&lt;Character, Integer>();\n        for (int i = 0; i &lt; J.length(); i++) &#123;\n            diamond.put(J.charAt(i), 0);\n        &#125;\n        for (int i = 0; i &lt; S.length(); i++) &#123;\n            if (diamond.containsKey(S.charAt(i))) &#123;\n                diamond_nums++;\n            &#125;\n        &#125;\n        return diamond_nums;\n    &#125;\n&#125;","slug":"diamond_and_stone","date":"2020-11-04T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,哈希表","author_index":"菲尔普斯"},{"id":"e88270f658837dea31f745921ef2fb60","title":"Python脚本实现自动登录校园网","content":"\n\n 准备工作\n 1.下载chromedriver\n如果没有安装Chrome浏览器，请先安装。\n打开Chrome -&gt; 帮助 -&gt; 关于 ，查看Chrome版本号。\n\n\n\n\n\n\n\n\n\nTips：版本号是类似于 86.0.4240.183 这样的一串数字\n下载与上述版本号相同版本的 chromedriver\n下载地址：https://npm.taobao.org/mirrors/chromedriver\n版本号最后三位数字可以不同，例如我的Chrome版本为 86.0.4240.183 ，我下载的chromedriver版本为 86.0.4240.22 。\n下载完成后解压得到 chromedriver.exe ，将其复制到Chrome目录和Python目录下。\n以下是我个人电脑上的Chrome目录与Python3.9的目录，供参考。\nChrome --- C:/Program Files/Google/Chrome/Application\nPython --- C:/Users/你的用户名/AppData/Local/Programs/Python/Python39\n 2.安装pywin32库\n打开终端（命令行），输入\npip install pywin32\n等待安装成功即可。\n\n\n\n\n\n\n\n\n\npywin32是一个包含了大量WindowsAPI的Python库\n 3.安装pyinstaller打包器\n打开终端（命令行），输入\npip install pyinstaller\n等待安装成功即可。\n\n\n\n\n\n\n\n\n\npyinstaller用于将 .py 源文件打包编译成 .exe 可执行文件\n 代码\nfrom selenium import webdriver\nfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilities\nimport time\n\ndef openChrome():\n    option = webdriver.ChromeOptions()\n    option.add_argument('disable-infobars')\n    driver = webdriver.Chrome(chrome_options=option)\n    return driver\n\n\ndef operationAuth(driver):\n    url = \"http://10.248.98.2\"\n    driver.get(url)\n    \n    elem1 = driver.find_element_by_id(\"username\")\n    elem1.send_keys(\"1234567\") #Enter your id\n\n    elem1 = driver.find_element_by_id(\"password\")\n    elem1.send_keys(\"ilovehit\") #Enter your password\n \n    driver.find_element_by_id(\"login\").click()\n\n    print(\"Success!\")\n\nif __name__ == '__main__':\n    driver = openChrome()\n    operationAuth(driver)\n 后续\n可以在Windows任务计划程序添加编译好的可执行文件，选择“每次开启启动时运行”。\n解放双手！Python万岁！\n","slug":"hit_lan_auto_login","date":"2020-11-04T15:39:00.000Z","categories_index":"项目","tags_index":"工具,Python,脚本,项目","author_index":"菲尔普斯"},{"id":"0ab63aeb665f5c401d814f05425f0b13","title":"VSCode配置Python环境","content":"本文介绍 VS Code 上配置 Python 环境的方法。\n\n 主要步骤\n 安装Python\n到官网下载最新版Python并安装。\n最后一步请点击 Disable path length limit。\n安装完成后可到终端验证，输入\npython --version\n\n\n\n\n\n\n\n\n\n出现“用户取消了安装”，则取消勾选“为所有用户安装Python”\n 安装VSCode插件\n到插件商店中安装Python插件。\n 建立VSCode工作区\n建立一个文件夹用作Python的WorkSpace。\n用VSCode打开该目录，在该目录下新建一个名为 .vscode 的文件夹。\n进入该文件夹中，新建 settings.json 空白配置文件。\n 选择解释器\nVSCode打开刚刚建立的WorkSpace目录后，按 Ctrl + Shift + P ，在弹出的输入框中输入 Python:Select Interpreter 并回车，然后选择刚安装的Python版本即可。\n 编译运行程序\n在 WorkSpace 目录下新建 hello.py 输入\nprint(\"Hello\")\n右键点击编辑器空白处选择“在控制台运行Python程序”，即可在VSCode自带的终端看到运行结果。\n 参考\n可以参考VSCode的官方英文文档，里面给出了配置Python环境的详细指引。\nhttps://code.visualstudio.com/docs/python/python-tutorial\n","slug":"python_for_vscode","date":"2020-11-04T14:00:00.000Z","categories_index":"Python","tags_index":"环境配置,VSCode,Python","author_index":"菲尔普斯"},{"id":"60b0137d332652961f2e3aab7916571c","title":"LC 941 有效的山脉数组","content":" 题目\n给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。\n\n让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：\n\nA.length &gt;= 3\n在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：\nA[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]\nA[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]\n\n\n示例 1：\n输入：[2,1]\n输出：false\n示例 2：\n输入：[3,5,5]\n输出：false\n示例 3：\n输入：[0,3,2,1]\n输出：true\n提示：\n0 &lt;= A.length &lt;= 10000\n0 &lt;= A[i] &lt;= 10000 \n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-mountain-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n先遍历一次数组找到最大元素位置，然后设置双指针，以山峰为起点，分别向左、右滑下，若两者都成功滑到山脚，说明数组是有效的山脉数组。\n 代码\nclass Solution &#123;\n    public boolean validMountainArray(int[] A) &#123;\n        int len = A.length;\n\n        //特判，长度小于3的直接否定\n        if (len == 0 || len == 1 || len == 2) return false;\n\n        int left = 0;  //左指针\n        int right = 0; //右指针\n        int max_index = 0;  //最大数索引\n        int max = -1;\n        \n        //遍历一次寻找最大元素位置\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (A[i] > max) &#123;\n                max = A[i];\n                max_index = i;\n            &#125;\n        &#125;\n\n        //如果最大数在两侧，则不符合要求\n        if (max_index == 0 || max_index == len - 1) return false;\n\n        //初始化左右指针\n        left = max_index;\n        right = max_index;\n\n        //左指针滑下山坡，若中途遇到坎，则退出\n        while (left > 0) &#123;\n            if (A[left-1] &lt; A[left]) &#123;\n                left--;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //右指针滑下山坡，若中途遇到坎，则退出\n        while (right &lt; len-1) &#123;\n            if (A[right] > A[right+1]) &#123;\n                right++;\n            &#125; else &#123;\n                break;\n            &#125;\n        &#125;\n        //询问两指针位置，若分别在两侧山脚，说明成功滑下，路上没有障碍\n        if (left == 0 &amp;&amp; right == len-1) &#123;\n            return true;\n        &#125; else &#123;\n            return false;\n        &#125;\n\n    &#125;\n&#125;\n 其他解法\n同样设置左右指针，分别从两侧开始“向中间爬”，停在能爬上的最高处，最后判断左山峰和右山峰是否为同一个山峰。\n","slug":"valid_mountain_array","date":"2020-11-03T15:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,数组","author_index":"菲尔普斯"},{"id":"3076ed3c59a77dfacbad03456d33f93c","title":"LC 217 存在重复元素","content":" 题目\n给定一个整数数组，判断是否存在重复元素。\n如果任意一值在数组中出现至少两次，函数返回 true\n如果数组中每个元素都不相同，则返回 false\n\n示例 1:\n输入: [1,2,3,1]\n输出: true\n示例 2:\n输入: [1,2,3,4]\n输出: false\n示例 3:\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/contains-duplicate\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n 方法一 哈希表\n一般来讲，这种涉及到统计有限长度数组中元素出现次数的题目，最容易想到的做法应该是哈希表法——即先进行一次数组遍历，将元素和出现次数统计到哈希表中，然后再遍历一次数组，同时在哈希表中进行快速搜索和查找。\n为什么最容易想到哈希表？个人理解是：与普通数组O(n)复杂度额查找相比，哈希表的突出特点就在于具备快速查找访问的能力，所以比较适合这种需要多次用到查找的题目。\n时间复杂度O(n)，空间复杂度O(n)，因哈希表占用空间。\n当然由于哈希表本身的维护耗时，它在此题中表现并不突出，时间性能仅击败了 14% 的Java提交者，空间性能也不突出。\n 方法二  排序 + 并排指针\n先对数组进行排序预处理，若存在重复元素，那么这几个重复元素必然相邻，用双指针并排前进，一旦检测到相邻项相同，说明存在重复元素。\n时间复杂度O(nlogn)，空间复杂度O(1)，n为数组长度。\n思路很简单，由于采用 Arrays.sort(arr) 进行排序预处理耗时较少，时间和空间性能都较好，击败了 99% 的Java提交者。\n 代码\n Java 哈希表\nclass Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        HashMap&lt;Integer, Integer> record = new HashMap&lt;Integer, Integer>();\n        int len = nums.length;\n        for (int i = 0; i &lt; len; i++) &#123;\n            record.put(nums[i], record.getOrDefault(nums[i],0) + 1);\n        &#125;\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (record.get(nums[i]) >= 2) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n Java 排序 + 双指针\nclass Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        int a = 0;\n        int len = nums.length;\n        int b = 1;\n\n        if (len == 0 || len == 1) return false;\n\n        Arrays.sort(nums);\n\n        while (b &lt; len) &#123;\n            if (nums[a] == nums[b]) &#123;\n                return true;\n            &#125; else &#123;\n                a++;\n                b++;\n            &#125;\n        &#125;\n        if (b == len - 1) &#123;\n            return false;\n        &#125;\n        return false;\n    &#125;\n&#125;","slug":"contains_duplicate","date":"2020-11-03T13:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串,哈希表,双指针","author_index":"菲尔普斯"},{"id":"ca28cca6d1e63b8c011c6f8240779c16","title":"LC 387 第一个唯一字符","content":" 题目\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n示例：\ns = \"leetcode\"\n返回 0\n\ns = \"loveleetcode\"\n返回 2\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n用Java自带的 HashMap 容器，建立一个 &lt;Character, Integer&gt; 的哈希表。\n第一次遍历字符串时，在表中记录出现的每个字母及出现的次数。\n第二次遍历字符串，以串中的每个字母为 Key ，逐个到哈希表中查找对应 Value ，即它在串中的出现次数，一旦发现 Value 为1，则马上返回该字母在串中的索引。\n只需要遍历两次字符串，时间复杂度O(n).\n 收获\n第一次使用Java的 HashMap 容器，有点爽…\n/*建立一个哈希表*/\nHashMap&lt;KeyType, ValueType> MyMap = new HashMap&lt;KeyType, ValueType>();\n\n/*给哈希表添加键值对*/\nMyMap.put(KeyType key, ValueType value);\n\n/*在哈希表中传入key，返回value值*/\nMyMap.getOrDefault(KeyType key, ValueType defaultValue); //提供了找不到key时的返回值\nMyMap.get(KeyType key); //未提供default值\n学到的Java的String类方法\nString str;\nstr.charAt(int index); //提供索引，返回串索引处字符\nstr.length();          //获取串长度\n 代码\nJava\nclass Solution &#123;\n    public int firstUniqChar(String s) &#123;\n        HashMap&lt;Character,Integer> record = new HashMap&lt;Character,Integer>();\n        int len = s.length();\n        for (int i = 0; i &lt; len; i++) &#123;\n            char tmp = s.charAt(i);\n            record.put(tmp, record.getOrDefault(tmp,0)+1);\n        &#125;\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (record.get(s.charAt(i)) == 1) &#123;\n                return i;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;","slug":"first_unique_character_in_string","date":"2020-11-03T08:30:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串,哈希表","author_index":"菲尔普斯"},{"id":"781f960ea9b66678a41daf934b2a2a29","title":"LC 344 反转字符串","content":" 题目\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n示例 1：\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n示例 2：\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n头尾双指针向中间移动，每移动一次，交换一次，直到指针碰面\n 代码\nJava版\nclass Solution &#123;\n    public void reverseString(char[] s) &#123;\n        for (int head = 0, tail = s.length-1; head &lt;= tail; head++, tail--) &#123;\n            char tmp = s[tail];\n            s[tail] = s[head];\n            s[head] = tmp;\n        &#125;\n    &#125;\n&#125;","slug":"reverse_string","date":"2020-11-03T05:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串,双指针","author_index":"菲尔普斯"},{"id":"d86afd4df1294e5c09b8411c6186d560","title":"LC 14 最长公共前缀","content":" 题目\n编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 &quot;&quot; 。\n\n示例 1:\n输入: [\"flower\",\"flow\",\"flight\"]\n输出: \"fl\"\n示例 2:\n输入: [\"dog\",\"racecar\",\"car\"]\n输出: \"\"\n解释: 输入不存在公共前缀。\n说明:\n所有输入只包含小写字母 a-z 。\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-common-prefix\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n 整体思路框架\n采用逐个串扫描（横向扫描）的方法，先扫描第一个与第二个串，获取它们的公共前缀，再将此公共前缀串与第三个串比较，更新公共前缀，然后与第四个，第五个比较…\n\n 小优化\n同样是逐串扫描，但不额外开辟空间来存放串与串比较得到的公共前缀串，而是使用一个整型变量 max_len 来记录和更新公共前缀的长度。\n开局初始化 max_len 为第一个串的长度，然后与第二个串比较，更新 max_len ，然后比较第二、三个串（比较过程中只比较前 max_len 长度的部分，后面不理会）更新 max_len ，以此类推。\n如此一来，max_len 必然越来越小，一般情况下可以大量减少位于后面的串的扫描次数，提高效率。\n 性能\n时间复杂度 O(mn) ，m为字符串平均长度，n为字符串个数。\n空间复杂度 O(1) ，使用的辅助空间不随数据规模改变。\nLeetcode提交记录\n用时 0ms，击败 100% 的 C语言 选手\n空间 5.3MB , 击败 17% 的 C语言 选手\n 收获\n\nchar**strs 实际上是 (char*)* strs ，也就是说，一维数组 strs 是字符指针数组，它的每个元素都是一个字符指针——在本题中是一个字符串的首地址。\n提供字符串指针（不允许改动），要求获取字符串长度——可以复制一个指针副本，移动指针副本来遍历字符串，再加一个计数变量，即可获取串长。\n学会将问题分解成子问题，将子问题写成独立的函数，简化整体函数书写时的思维负担。\n一定要注意函数异常出口的书写\n\n 代码\nint max_len = 0;       //记录扫描到目前为止所允许的最大前缀长度\nint asis_max_len = 0;  //辅助变量，记录每次比较两串时得到的公共前缀长度\n\n/*传入两个串的首地址，返回两串的最大公共前缀长度*/\nint GetSamePrefix(char* a, char* b)&#123;\n    int same_len = 0;\n    \n    //异常出口，给空串则返回空串\n    if (*a == '\\0' || *b == '\\0') &#123;\n        return 0;\n    &#125;\n\n    //a,b串都没到末尾，且扫描长度不可以超过之前记录的max_len\n    while (*a != '\\0' &amp;&amp; *b != '\\0' &amp;&amp; same_len &lt;= max_len) &#123;\n        if (*a == *b) &#123;\n            same_len++;\n            a++;\n            b++;\n        &#125; else &#123;\n            return same_len;\n        &#125;\n    &#125;\n    return same_len;\n&#125;\n\n//传入串地址，获取串长度，在主函数里用于初始化max_len\nint GetStrlen(char* str)&#123;\n    char* str_copy;\n    str_copy = str;  //避免对原指针造成改动\n    int len = 0;\n    while (*str_copy != '\\0') &#123;\n        len++;\n        str_copy++;\n    &#125;\n    return len;\n&#125;\n\n\nchar * longestCommonPrefix(char ** strs, int strsSize)&#123;\n    char** asis;\n    asis = strs + 1;   //辅助指针，与提供的指针并排前进（快一步）\n    \n    char* result;     //后面用于存放前缀串地址，作返回值\n\n    //临界情况函数出口，给空串返回空串，只给一个串就返回该串\n    if (strsSize == 0) &#123;\n        return \"\";\n    &#125;\n    if (strsSize == 1) &#123;\n        return *strs;\n    &#125;\n\n    max_len = GetStrlen(*strs); //初始化max_len为第一个串的长度，否则max_len一开始就是0，比较两串的子函数就无法执行\n\n    for (int i = 0; i &lt; strsSize-1; i++) &#123;\n        //用辅助变量记录每一次比较两串的得到的最大公共前缀长度\n        asis_max_len = GetSamePrefix(*strs,*asis);\n        //比较max_len与辅助变量，若更小则赋给max_len，因为max_len只能越来越小\n        //容易犯的错误是：没有使用辅助变量，max_len更新被覆盖，可能会变大\n        if (max_len >= asis_max_len) &#123;\n            max_len = asis_max_len;\n        &#125;\n\n        //若到了某个位置获取的max_len为零，说明出现了一个老鼠屎，毁了一锅字符串\n        if (max_len == 0) &#123;\n            return \"\";\n        &#125; else if (i == strsSize-2) &#123; //如果坚持到了最后两个串，就该出结果了\n            //题目说要返回最大前缀串的地址，这里没有开新的串，而是利用max_len截取最后一个串的前缀，拷贝到倒数第二个串（因为倒数第二个串长度肯定大于等于前缀，不会越界），再末尾加上结束符，相当于临时用倒数第二个串“接住”了前缀，再利用strncpy()来返回它的地址即可。\n            result = strncpy(*strs,*asis,max_len);\n            *(*strs+max_len) = '\\0';\n            return result;\n        &#125; else &#123; //如果还有机会(max_len不为0)，又还没到最后，就继续移动\n            asis++;\n            strs++;\n        &#125;\n    &#125;\n    return \"\"; //这个出口不可能达到，但是如果不写，测试会报错，随便写一个\n&#125;\n 其他解法\n 纵向扫描\n先看第一个字符，将所有串的第一个字符全部扫描一遍并比较，看是否完全相同，若完全相同则进入下一个字符，以此类推。时间复杂度和空间复杂度均与横向扫描相同。（引用Leetcode的图解）\n\n 分治+递归\n待补充\n 二分查找\n待补充\n","slug":"longest_common_prefix","date":"2020-11-01T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串","author_index":"菲尔普斯"},{"id":"b513457641c5d77aabc90d59ad7c2b99","title":"LC 434 字符串中的单词个数","content":" 题目\nYou are given a string s , return the number of segments in the string.\nA segment is defined to be a contiguous sequence of non-space characters.\n\nExample 1:\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\nExample 2:\nInput: s = \"Hello\"\nOutput: 1\nExample 3:\nInput: s = \"love live! mu'sic forever\"\nOutput: 4\nExample 4:\nInput: s = \"\"\nOutput: 0\nConstraints:\n\n0 &lt;= s.length &lt;= 300\ns consists of lower-case and upper-case English letters, digits or one of the following characters &quot;!@#$%^&amp;*()_+-=',.:&quot;.\nThe only space character in s is ' '.\n\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/number-of-segments-in-a-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n既然题目说只要不是空格的都算字符，那此题本质上等价于：提供一个只有 0 和 1 两种元素的字符串（数组），找出连续的 1 串的个数。\n将串以【字符段】和【空格段】分成若干片段，为这两种片段分别设置不同的入口，分别处理。在【字符段】切换到【空格段】的时候给计数器加一。\n最后额外处理临界情况——字符串以【字符段】结束的情况。\n由于只遍历字符串一次，因此时间复杂度O(n)，空间复杂度O(1)\nLeetcode提交\n时间性能击败 100% 的 C 提交者\n空间性能击败 11% 的 C 提交者\n 代码\nint countSegments(char * s)&#123;\n    int count = 0; //统计单词个数\n    \n    //特殊情况出口\n    if (*s == '\\0') &#123;\n        return 0;\n    &#125;\n    \n    //外层循环推进整体扫描\n    while (*s != '\\0') &#123;\n        //内层循环对[字符段]-[空格段]交替处理\n        //while处理字符段\n        while (*s != ' ' &amp;&amp; *s != '\\0') &#123;\n            //只要遇到字符就推进\n            s++;\n            //字符推进被空格截断则更新统计\n            if (*s == ' ') &#123;  \n                count++;\n                break;\n                //更新完跳出循环，切换到对空格段的推进\n            &#125;\n        &#125;\n        //if处理空格段\n        if (*s == ' ') &#123;\n            s++;\n        &#125;\n    &#125;\n    //整体扫描完成后，将指向结束符的指针回退一格\n    s--;\n    \n    //若串的最后以字符结束，需要特殊处理\n    if (*s != ' ') &#123;\n        count++;\n    &#125; \n    return count;\n&#125;\n 其他解法\n待补充\n","slug":"num_of_segments_in_string","date":"2020-11-01T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串","author_index":"菲尔普斯"},{"id":"a9678d67ca5c601b58ad6876d5f2a753","title":"LC 520 检测大写字母","content":" 题目\n给定一个单词，你需要判断单词的大写使用是否正确。\n我们定义，在以下情况时，单词的大写用法是正确的：\n全部字母都是大写，比如&quot;USA&quot;。\n单词中所有字母都不是大写，比如&quot;leetcode&quot;。\n如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。\n否则，我们定义这个单词没有正确使用大写字母。\n\n示例 1:\n输入: \"USA\"\n输出: True\n示例 2:\n示例 2:\n输入: \"FlaG\"\n输出: False\n注意: 输入是由大写和小写拉丁字母组成的非空单词。\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/detect-capital\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n\n属于字符数组的遍历问题。\n单词正确的情况分为3种：USA型，Google型，flag型。\n先检测首字母和第二位字母来确定类型，然后分别给 type 变量赋值1、2、3来标记上述三种类型。\n三种类型遍历时，采用略微不同的检测方法即可。\n注意逻辑闭合，递归出口不漏补缺。\n不需要知道大小写字母的ASCII码范围，直接比较字符即可。\n\n 代码\nbool detectCapitalUse(char * word)&#123;\n    int type = 0;\n    //1为全大写，2为第一个大写，3为全小写\n\n    //检查第一个\n    if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n        word++;\n        //检查第二个\n        if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n            type = 1;\n        &#125; else &#123;\n            type = 2;\n        &#125;\n    &#125; else &#123;\n        type = 3;\n    &#125;\n    switch (type)\n    &#123;\n        case 1:\n            for (; *word != '\\0'; word++) &#123;\n                if (!(*word >= 'A' &amp;&amp; *word &lt;= 'Z')) &#123;\n                    return false;\n                &#125;\n            &#125;\n            return true;\n        case 2:\n            for (; *word != '\\0'; word++) &#123;\n                if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n                    return false;\n                &#125;\n            &#125;\n            return true;\n        case 3:\n            for (; *word != '\\0'; word++) &#123;\n                if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n                    return false;\n                &#125;\n            &#125;\n            return true;\n        default: return false;\n    &#125;\n&#125;\n 其他解法\n先遍历字符串，获取字符串长度 length ，同时统计大写字母出现的次数。\n当且仅当符合以下情况时，返回 true\n\n字符串长度与大写字母个数相等\n大写字母个数为1，且第一个字母大写\n大写字母个数为0\n\n其余情况返回 false 即可。\n这种解法更快，因为只涉及遍历和计数，而且遍历是一气呵成，不需要受条件判断的阻滞。\nbool detectCapitalUse(char * word)&#123;\n    int length = 0;\n    int caps = 0;\n    bool isHeadCap = false;\n    if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n        isHeadCap = true;\n    &#125;\n    while (*word != '\\0') &#123;\n        length++;\n        if (*word >= 'A' &amp;&amp; *word &lt;= 'Z') &#123;\n            caps++;\n        &#125;\n        word++;\n    &#125;\n    if (length == caps) &#123;\n        return true;\n    &#125; else if (caps == 1 &amp;&amp; isHeadCap) &#123;\n        return true;\n    &#125; else if (caps == 0) &#123;\n        return true;\n    &#125; else &#123;\n        return false;\n    &#125;\n&#125;","slug":"check_capital_letter","date":"2020-10-31T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串","author_index":"菲尔普斯"},{"id":"1905b17da4d915d445f9b18f99561b69","title":"LC 125 验证回文串","content":" 题目\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n示例 1:\n\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n示例 2:\n输入: \"race a car\"\n输出: false\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/valid-palindrome\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n 整体思路框架\n头尾双指针向中间移动，凡是遇到非法字符就跳过，判断所有 有效字符对 是否符合要求，若直到两指针碰面都没有退出函数，说明所给串是回文串。\n 对大小写字母的处理\n在最开始写代码的时候，我通过判断两字符差的绝对值是否为32来实现判断大小写字母是否成对，这样问题是非常大的，当我遇到测试用例 &quot;0P&quot; 时，才意识到，这样判断不出差错的前提是已知这两个字符都是英文字母，否则只要在ASCII码表中随意隔32抽两个字符都可以通过判断。\n由上述可知，应该首先判断两个字符都为英文字母，再判断两者差的绝对值为32，才可判定它们是“大小对”。\n但实际上有更简单的处理方法，因为我用的“头尾指针法”在一开始就需要将串遍历一次，所以不妨利用这次遍历，顺便将所有英文字母统一成大写字母或者小写字母，这样一来在后续判断中只需要单纯判断两字符是否相等，即可涵盖数字和字母两种情况了。\n另外还需要注意的是，ASCII码表中，A~Z 是位于 a~z 之前的，而且很重要的一点是，他们是分开的两个连续块，换句话说，Z 与 a 之间还有若干个非英文字母字符，特别注意！\n\n 双指针的思想\n个人感觉在字符串处理中经常用到的“双指针法”的思想根源来自于快速排序算法，这种双指针遍历的方法应该是融会贯通于其中的，以后需要多联想和归纳类似的题目。\n 代码\nbool isPalindrome(char * s)&#123;\n    //初始检测，若是空串，直接返回true\n    if (*s == '\\0') &#123;\n        return true;\n    &#125;\n\n    //定义辅助指针作头指针\n    char* headAsis; \n    headAsis = s;\n\n    //原指针移动到末尾，作尾指针\n    //扫描过程中顺便将所有大写字母转换为小写字母，免去后续比较的麻烦\n    while (*s != '\\0') &#123;\n        if (*s >= 'A' &amp;&amp; *s &lt;= 'Z') &#123;\n            *s += 32;\n        &#125;\n        s++;\n    &#125;\n    s--; //将指向了结束符的尾指针回退1位\n\n    while (headAsis &lt; s) &#123;\n        //头尾指针分别检测所指值，若既不是小写字母也不是数字，则继续向中间移动\n        //移动过程也要注意限制，不能让头指针超过尾指针\n        while (headAsis &lt; s &amp;&amp; (*headAsis &lt; 'a' || *headAsis > 'z') &amp;&amp; (*headAsis &lt; '0' || *headAsis > '9')) &#123;\n            headAsis++;\n        &#125;\n        while (headAsis &lt; s &amp;&amp; (*s &lt; 'a' || *s > 'z') &amp;&amp; (*s &lt;'0' || *s > '9')) &#123;\n            s--;\n        &#125;\n        //若有效字符对符合要求，各自移动一格，重复循环\n        if (*headAsis == *s) &#123;\n            headAsis++;\n            s--;\n            continue;\n        &#125; else &#123;\n            //一旦出现不符合要求的字符对，退出\n            return false;\n        &#125;\n    &#125;\n    //整个循环都没出问题，则为回文串\n    return true;\n&#125;\n 其他解法\n 使用辅助空间\n另开一个辅助字符数组，开始时先遍历原串，将合法字符（数字和字母）复制到辅助串中，复制完毕后，只需判断辅助串是否为简单的回文串即可，优点是简便，缺点是空间复杂度为O(|s|)\n","slug":"is_palindrome","date":"2020-10-31T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,字符串","author_index":"菲尔普斯"},{"id":"65abd3d32b27895ac3ec803fdc1b4589","title":"归纳总结 | 指针","content":"本文介绍 C 语言中的指针和数组相关知识。\n\n 基础知识\n 变量\n一个变量具有三项属性：\n\n\n\n属性\n解释\n\n\n\n\n数据类型 (Element Type)\n如 int ，char\n\n\n地址 (Memory Address)\n对于64位计算机来讲，一条内存地址值占8个字节\n\n\n值 (Value)\n变量的“内容”\n\n\n\n 运算符\n&amp;：取地址运算符，可根据值来取地址，在一个值前面加上该操作符，就可以得到其对应的地址\n*：取值运算符，可根据地址来取值，在一个地址前面加上该操作符，就可以得到地址中存储的值\n 指针 (Pivot)\n指针的全名，叫作指针变量，既然指针是变量，也就意味着指针具备上述三种属性（类型，地址，值）\n 类型\nint* pInt;      //定义一个用于指向整型变量的指针pInt\nchar* pChar;    //定义一个用于指向字符型变量的指针pInt\ndouble* pDble;  //定义一个用于指向双精度型变量的指针pInt\n注意，int*p，int* p，int *p，int * p 是一个意思，但我个人倾向于写成 int* p 的形式，因为这样的定义反映了它的内涵和功能——定义一个用来指向整型变量的指针变量p\n 地址和值\n指针既然是变量，那么它就一定有地址，也有值，指针变量毕竟是个变量，也需要安身之处，所以它有自己的地址，但它特殊就特殊在，它的值也是一个地址，并且它可以访问这个地址所存储的值。\n\n\n\n\n\n\n\n\n\n社区人口普查员可以根据手上的登记簿，到自己社区内的人家里去查户口，同时人口普查员自己也住着出租屋，这里的人口普查员就是指针，出租屋就是指针的地址，登记簿就是指针的值，查户口就是根据自己的值（别人的地址）来访问别人地址存储的值。\n我们可以运行以下代码测试一下\nint a = 3;\nint* p = &amp;a;\nprintf(\"%d\",a);     //3           变量a的值\nprintf(\"%d\",&amp;a);    //6422044     变量a的地址\nprintf(\"%d\",p);     //6422044     指针变量p的值\nprintf(\"%d\",&amp;p);    //6422032     指针变量p自己的地址\nprintf(\"%d\",*p);    //3           指针变量p根据自己的值去访问a，得到a的值\nprintf(\"%d\",&amp;*p);   //6422044     先取到a的值，再根据a的值取地址\n综上所述，指针的本质是——具有访问功能的变量\n 指针的基本应用\n 1. 修改实参的值\n我们都知道，当我们向函数传递普通变量参数（非数组）时，在函数中操作的实际上是实参的副本——也叫形参，也就是说，在函数中对参数作的改动，都是对形参的改动，不会作用到实参身上。\n当我们需要对在函数内部对实参作出改动时，就需要用到指针。\n例如常用的交换函数\nvoid Swap (int* a, int* b)\n&#123;\n    int temp;\n    temp = *b;\n    *b = *a;\n    *a = temp;\n&#125;\n我们传进去的参数是两个地址值，需要注意的是，这与上文所说的并不冲突，传入的地址也被拷贝成副本作为形参，但是这并不影响我们的操作，因为我们不需要修改这两条地址，我们想要修改的，是这两条地址存储的值。\n\n\n\n\n\n\n\n\n\n不妨把函数想象成一间只有窗口的小黑屋，里面住着一个刺客，有两个人走到窗口，A向里面喊，我家在北京路1号，B向里面喊，我家在北京路2号，这样一来，黑屋里的刺客会拿小本本记下A、B的地址，然后第二天夜里分别前往A、B的家中，月黑风高处，杀人好时机。这里的刺客就是函数的内容，A、B向屋里喊地址的过程就是“传递参数”，黑屋刺客小本本上的地址就是参数的副本（形参），刺客潜入他俩家中执行暗杀任务，就是根据地址值访问并修改地址存储的值。\n 2.作多返回值函数的出口参数\n当函数需要多个返回值时，只能返回一个值的 return 功能就不够用了，我们可以多设置几个参数，用于接收函数的处理结果，这样的参数叫做函数的“出口参数”，一般来讲，出口参数需要能够修改到实参的值，所以需要一般使用指针变量作出口参数。\n举个例子。\nvoid GetMaxScore (int score[], int length, int* pMaxScore, int* pMaxNumber)\n&#123;\n    /*Function：获取学生列表中的最高分，并返回最高分学生的学号*/\n    int max_num, max_score;\n    for (int i = 0; i &lt; length; i++) &#123;\n        if (score[i] >= max) &#123;\n            max_num = i;\n            max_score = score[i];\n        &#125;\n    &#125;\n    /*函数结束，将结果赋给出口参数，修改实参的值*/\n    *pMaxScore = max_score;\n    *pMaxNumber = max_num;\n&#125;\n\n 指针和数组\n 数组的底层知识\n1. 数组是一片连续的内存空间，且每个单位内存空间的大小是确定的\n例如，定义一个长度为5的整型数组 int a[5] ，由于 int 型数据占4个字节，系统就会开辟一块连续的、占20个字节的内存空间，用于存放数组 a\n2. 数组可以通过下标随机访问\n与线性表不同，数组可以通过下标值在 O(1) 时间内访问到任何数组内部元素的值，这依赖于数组的内存空间是连续且等大的，这样一来，只要提供数组的首地址和下标值，就可以通过下面的计算，得到数组任意下标位置的地址值，从而在 O(1) 时间内访问到该元素\nint arr[10];\n&amp;arr[i] = arr + i * sizeof(int);\n//arr是数组名，代表数组的首地址\n//此处的等号不是赋值运算，只为说明计算地址的方法\n3. 二维数组的本质\n二维数组虽然在逻辑上类似于一个矩阵，但在物理上，它仍然是一个一维数组，也就是由若干个等大单位内存空间组成的一片连续内存空间。\n我们不妨把二维数组的每一行看成一个整体（一个一维数组），那么二维数组实际上也是一个一维数组，只不过这个一维数组的每个元素还是一维数组。\n但话又说回来，一维数组要怎么“塞进去”呢？\n实际上，二维数组的每个元素值，实际上是对应子数组的地址值。\n换句话说，系统开辟了另外的空间来存放子数组的具体值，而这个二维数组相当于是子数组的索引数组。\n现在我们来讨论，为什么在声明二维数组时，第二维的长度不能省略？\n有了以上知识的铺垫，这个问题就转换成了一个等价子问题：\n为什么在声明一维数组时，数组的长度不能省略？\n答案应该是显然的——否则系统根本不知道应该开辟多长一片连续内存空间来存放这个一维数组。\n 数组名 = 指针？\n 指针和结构体\n","slug":"pivot_and_array","date":"2020-10-30T16:00:00.000Z","categories_index":"C/C++","tags_index":"C/C++,指针,笔记总结","author_index":"菲尔普斯"},{"id":"f4e7ecf8b446abc26f94ba3ad7edad20","title":"Hexo + Gitee 部署个人博客","content":"最近在尝试搭建个人博客，本来刚安装好WordPress，突然觉得这种动态的CMS有点过于臃肿，用来作个人博客的管理平台有点杀鸡用牛刀的意思.\n后来在B站看了CodeSheep的介绍视频，决定尝试VuePress，但搭建好后又发现过于“静态”，缺少给文章打tag , category 之类的功能，对于经常需要更新的博客，维护起来比较麻烦（可能还是更适合做完全静态的展示页面，如开发者文档）。\n几经周转，最终在今天用Hexo将博客部署在了Gitee上，写作和文章管理的体验都非常不错。\n\n 基本步骤\n下面展示我个人安装过程的主要步骤\n 1. 安装Node.js\n到官网下载Node.js并无脑安装即可，安装后会自带npm包管理器\n注意，官网一般会提供两个版本，分别是LTS(Long Term Support)和Current版，下载LTS版即可\n下载后可打开命令行输入以下命令验证是否安装成功\nnode -v\nnpm -v\n 2. 安装Git\nGoogle搜索Git，选择系统对应版本无脑下载安装即可\n 3. 安装cnpm\n\n\n\n\n\n\n\n\n\n这一步是可选的，只为了加快速度\n管理员身份打开Powershell或cmd（Win10用户可以用Windows Terminal，非常舒适），输入以下命令\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\nWindows用户在这一步可能会遭遇命令行报错，需要键入以下命令并按回车\nset-ExecutionPolicy RemoteSigned\n\n\n\n\n\n\n\n\n\n下文默认打开命令行都使用管理员身份\n 4. 安装Hexo\ncnpm -g hexo-cli\n同理，可输入 hexo -v 来验证安装成功\n 5. 初始化Hexo\n建立准备用于存放博客所有文件的文件夹，例如 D:\\Hexo_Blog\n用命令行进入这个目录\ncd D:\\Hexo_Blog\n\n\n\n\n\n\n\n\n\nTips:一般命令行会有路径补全功能，只要输入文件夹名前几个字母再按 Tab 键即可自动补全路径\n确认命令行当前操作目录位于 D:\\Hexo_Blog ，在此目录下输入以下命令，初始化Hexo\nhexo init\n\n\n\n\n\n\n\n\n\n如果在这一步报错，请检查是否已经正确安装Git\n 6. 本地预览博客\n至此，Hexo的安装和初始化已经完成，此时Hexo会为博客自动安装默认主题，并放入一篇名为Hello World的文章\n我们可以启动本地服务暂时预览，命令行键入\nhexo server\n打开浏览器，在地址栏输入: localhost:4000，按回车即可预览\n Hexo的日常操作介绍\n 目录结构\n.\n├── _config.yml \n├── package.json\n├── public \n├── scaffolds\n├── source\n|   ├── _drafts\n|   ├── _posts\n|   └── img\n└── themes\n_config.yml ：Hexo的配置文件，可修改博客主题、文档模板等配置\n/source/_posts/ ：存放 .md 格式的文章\n/source/img/ ：存放整个博客的图片资源，在配置文件中的 /img/... 指的就是该位置\n/public/ ：存放Hexo通过渲染将 source 中的 .md 文件渲染成的 .html 文件，也就是生成的静态页面\n/themes/ ：存放第三方主题的位置，下载的主题需要存放到此处\n 创建和写作\n可以通过以下命令新建文章，Hexo会自动创建 article_title.md 文件并存放于 /source/_post 目录下\nhexo new \"article_title\"\n像我就比较头铁，直接在 /source/_post 目录下自己建 .md 文档即可开始写作\n写作前可以在markdown文件的头部书写一些文章的元数据，如\n---\ntitle: 这里写文章名\ndata: 2020-10-28\nauthor: cj\ncategory: 这里写文章从属的目录名（可省略）\ntags: [标签1,标签2]\nindex_img: 文章缩略图路径\nbanner_img: 文章Banner大图路径\n---\n 生成静态页面\n输入以下命令，Hexo会自动将 /source/ 目录下的所有文章全部生成静态页面，存放到 /public/ 目录下\nhexo generate\n 本地服务器预览\n输入以下命令，Hexo自动将博客部署到本地，默认端口4000，访问地址 http://localhost:4000 即可预览\nhexo server\n\n\n\n\n\n\n\n\n\n注意，本地预览可以理解为“暂时挂载的服务”，可以在刚才的命令行窗口按 Ctrl + C 结束挂载，如果你修改了配置文件或需要重新生成页面，你需要先结束挂载\n 将Hexo部署到云（以Gitee为例）\n 创建Gitee仓库\n登录Gitee创建个人仓库，可以选 private 或者 public，其他选项随意（如果没有Gitee账户需要先注册一个）\n下面我们需要记住和区分三样东西：仓库名、仓库路径、网站路径\n以我的博客为例（其中的 coiggahou 是我的Gitee用户名，cjpark 是我的仓库名，，分别替换成你的即可）\n我的仓库名称: cjpark\n我的仓库路径为: https:&#x2F;&#x2F;gitee.com&#x2F;coiggahou&#x2F;cjpark \n我的网站路径: https:&#x2F;&#x2F;coiggahou.gitee.io&#x2F;cjpark\n 创建本地Git信息\n之前在本地安装Git之后，如果没有进行基础配置，那么需要配置以下用户名和邮箱（作为每次push时的凭据）\ngit config --global user.name \"填写用户名\"\ngit config --global user.email \"填写邮箱\"\n 本地和Gitee通讯\n终端输入\nssh-keygen -t rsa -C \"这里输入简单短语描述公钥名称\"\n再输入\ncat ~/.ssh/id_rsa.pub\n可以看到公钥的内容，我们将其全部选中并复制，准备放到Gitee上\n访问Gitee，个人 -&gt; 设置 -&gt; 安全设置 -&gt; SSH公钥 -&gt; 添加公钥 -&gt; 输入并保存公钥\n接下来在终端输入以下命令测试是否配置成功\nssh -T git@gitee.com\n若输出“Hi!..”表明本地和Gitee通讯成功\n 安装Hexo用于部署的插件\nnpm install hexo-deployer-git\n 在Hexo配置中添加仓库信息\n打开 _config.yml，找到以下 deploy 分支，填写下面的信息\ndeploy:\n    type: git\n    repo: 这里填写仓库地址\n    branch: 推送到仓库的分支（没设置就填master）\n 将站点push到仓库\n在本地站点目录下，执行\nhexo deploy\n\n\n\n\n\n\n\n\n\n注意，这里我们push到仓库的只是本地站点目录的 /public/ 目录，也就是所有由Hexo生成的静态页面，其他配置文件和 /source/等目录都不会被push到仓库\n 开启Gitee Pages服务\n登录Gitee，进入之前创建的用于存放博客文件的仓库，点击 服务 中的 Gitee Pages，完成基本设置，开启服务\n 访问站点\n此步常见问题是访问后能加在基本的HTML结构，但是网页没有CSS样式，解决方案如下\n打开 _config.yml，找到以下项并填写或修改\nurl: 填写网站的地址\nroot: 填写网站的目录（如果你的网站建立在子目录，需要特别注意填写此处）\n 更新 Gitee Pages\n总体来讲，日常写作更新博文的流程如下：\n\n/source/_post/ 目录下新建 .md 文件，添加元数据，写作（图片素材应放在 /source/img/ 目录下，文章中才能正常插入显示）\n写作完成后，运行 hexo generate 生成静态页面\n运行 hexo server 本地预览\n本地预览确认达到理想效果后，hexo deploy 推送到仓库\n登录Gitee进入对应仓库的Gitee Pages服务，点击更新\n访问站点即可看到更新\n\n 个人建议\n从此以后，我们的文章都将存放于本地博客站点目录下的 /source/_post/ 目录下，但我总觉得不太安全，于是在Gitee另外开了一个仓库，用于存放我本地 /source/ 目录下的所有文件。\n大致操作步骤为：\n\n在Gitee新建私人仓库\n进入 /source/ 目录下，在此处打开命令行终端，按照Gitee初始仓库的操作至指南进行即可\n\ngit init      //本地仓库初始化\ngit add -A    //这步是将source目录下所有文件添加到本地仓库\ngit commit -m \"first-commit\"\ngit remote add origin git@gitee.com:用户名/仓库名.git\ngit push -u origin master  //将本地的master分支push到远端的仓库，其中origin是仓库的别名\n\n由于我之前已经建立了SSH公钥，故push时只需要输入密码即可\n\n这样一来，每次我在本地写好文章之后，就可以直接将文章push到Gitee的远程仓库作为备份，剩下再按 generate -&gt; deploy 的步骤部署到站点，也就是实现文章存储与站点部署相分离，保证文档的安全。\n 参考\nHexo官方文档  https://hexo.io/docs/\nEasyHexo（实用Hexo入门指南）  https://easyhexo.com/\nHexo Fluid（我使用的Hexo主题）https://hexo.fluid-dev.com/docs\n","slug":"hexo_plus_gitee","date":"2020-10-27T02:53:36.000Z","categories_index":"","tags_index":"前端","author_index":"菲尔普斯"},{"id":"ec0439b9fef997560e6463dca51af921","title":"梦想的起点 | 深圳","content":"谨以此文，开启深圳追梦之旅\n\n 题记\n2018年冬，深圳北站。\n孤身一人来到陌生的城市，少年抬起头，看着一抹暖阳洒在“深圳北”的站牌上，稚嫩的脸庞上，写满了懵懂、好奇、憧憬与希望。\n2020年9月，深圳南山西丽大学城。\n经过3年的磨炼，略显成熟的少年，在他青涩的18岁，紧握着手里的通知书，来到了哈工大（深圳），他紧张地四处张望，寻找着计算机科学与技术学院的新生报到点。\n2020年10月，深圳北站。\n班级组织活动参观莲花山公园，回校的路上途径深圳北站换乘地铁，看着模样分毫未变的站台和熙熙攘攘的人群，一抹熟悉感涌上心头，想到终于有机会实现两年前与自己约定的梦想，他难以压抑内心的激动，瞬间泪湿了眼眶…\n 与深圳的初次邂逅\n那是2018年的冬天。我还在读高一。背着电脑包，拖着行李箱，第一次一个人坐高铁、出远门，到达一个陌生的城市——深圳。\n去深圳干什么？去参加一个冬令营。\n\n依赖于身边OI大佬的指导，通过了大疆RM的笔试和面试，有幸通过选拔成为 2018大疆Robomaster高中生机器人冬令营 的一员。\n那是我人生中第一次经历面试、笔试这样的筛选环节，那时候的我什么都不会，只在初中学过一点前端和C++，哪怕非常认真地做了准备，我仍然在电话面试时战战兢兢、一身冷汗。\n当时面试官问的问题是：\n请你简单讲一下指针。\n请你简单介绍一下什么是最小堆、最大堆。\n没有学过数据结构和算法的我，在那一刻无比的窘迫，只能老老实实说，我不会。\n坦白讲，入营之后几天内，我受到了极大的打击和挫败。\n每个队伍内的分工具体是算法、机械和嵌入式三个方向。算法队员负责针对具体题目建模、设计算法并用代码实现；机械队员负责设计和组装整台机器人的机械传动结构；嵌入式队员则负责程序端和机械端的衔接、沟通与嵌入。\n\n队长问我你是什么方向？算法吗？什么是深搜、广搜、二叉树？我不会。机械吗？我连螺丝都拧不利索。我只能跟着队里主攻嵌入式的大佬，帮他看看代码和库函数，然后干一些做PPT、写日志报告的杂活。\n当时我真的觉得自己很没用。队里要用Github管理代码，我连命令行都不会；机械老哥要我去拿个电机，我连电机型号都不知道在哪看…更别说什么3D打印、最短路算法设计、调开发板了。（现在回头看来，真的要感谢当时队长和队员们都非常包容我并且耐心地指导我，才让我不至于崩溃）\n\n但话又说回来，正是这段近乎黑暗的经历，带给了我无穷无尽的收获，深刻地影响了我在那之后的选择和道路。\n那时候的我，\n看着来自五湖四海的大佬们，视觉识别、敏捷开发、机械结构、设计算法，各显神通；\n看着表现优异的个别营员，接受各地顶尖大学的现场面试，拿到Offer或降分；\n看着大疆RM基地里，各个岗位的工程师，满怀激情地工作；\n看着我的队长用高水平的开发成果、惊艳全场的PPT和优秀的演讲表达能力在答辩时征服现场评委，拿到港科大Offer…\n有一天干完活在一起吃烧烤，队长向我展示了他的经历——大疆社区优秀飞手、深圳各种科创比赛获奖者、个人网站开发者、魅族手机特约评测写作者…他吸了一口杯里的可乐，跟我说：“你以后想不想出来创业？我特别想创业，我才不想给别人打工。我有信心成为一名全栈工程师。”\n那时连函数都还没学懂的我，背着电脑包走在深圳凌晨4点的夜里，看着夜空中的闪亮的星星，就像看到了我内心悄然腾跃而起的火种。\n我要考上顶尖大学的计算机系。\n我想成为像队长那样酷的开发者。\n我要全面发展我的技能（英语、演讲、沟通表达、PPT…）\n我想成为一名全栈工程师。\n我渴望变强。\n 我的大学\n从那次冬令营回来以后，我又经历了一次成绩排名的暴跌，在家人、学校、班级环境的重重压力下，从每天起早摸黑到中午不睡觉刷题，从周末留校自习到剪断羽毛球拍的拍线，那段时间里，我经历了前所未有的压力和困难，也实现了前所未有的自我突破…后来的两年里，我还算保持了相对自律的习惯，最终在高考取得还算满意的成绩。\n在填报志愿的时候，我的原则是非计算机系不读，当时的备选项大概有：同济大学计算机系、华中科技大学计算机系、哈尔滨工业大学（深圳）计算机系、中山大学计算机系、北京理工大学计算机系…\n\n最终我选择了哈尔滨工业大学（深圳），作出这个选择，除了考虑学校、专业、就业等方面之外，要说其中没有对深圳这个城市的活力和氛围的一点点感情的加分，那是不可能的。\n 重燃火种\n入学大概一个多月后，计算机学院组织了一场由两个指定班级参加的校长班会（校长会到场发言和指导），辅导员让我上台作一次演讲，分享我选择计算机专业的初心和对未来的规划与期望。在写演讲稿的时候，我多次提到了那次大疆冬令营对我的启发和影响，我甚至觉得，短短9分钟的演讲，远远不足以表达我内心对此真实而热切的情感…\n\n就在班会后的第二天，班里组织活动去参观莲花山公园，活动结束后，在坐地铁回学校的路上，需要到深圳北站换乘地铁，不变的站牌、依旧拥挤的站台、广播里反复播放的电脑合成女声…\n\n一切都是那么的熟悉，仿佛又回到了两年前。\n我还是我，我还背着电脑包。\n看着随处可见的“深圳北站”提示牌，一遍又一遍听着站台的“深圳北”提示播音，我有些恍惚，更多的是感慨、激动和自豪。\n现在的我，英语口语表达水平、PPT设计制作水平、演讲水平，也算是勉强达到了当初自己对自己的期望。\n\n现在的我，面对当初的那几道算法题，即便不一定能全A，至少应该不至于完全没有思路。\n现在的我，也能通过折腾和学习，学会实用Git和Github的基本功能，也能通过 Hexo + Gitee 搭建出属于自己的个人博客了。\n\n现在的我，能够在一流学府的良好氛围中，学习专业知识，追逐自己的梦想了…\n感谢一直坚持的自己，感谢我的爸妈和亲人给我的支持和鼓励，我才有机会走到这个平台上。\n 未来的期望\n\n希望未来四年里，能够不断学习和积累，掌握更多专业的计算机工程技能，成为一名全栈工程师。\n深圳，是梦开始的地方。\n希望能在深圳，创造自己的未来！\n","slug":"thought_at_szb","date":"2020-10-26T16:00:00.000Z","categories_index":"随笔","tags_index":"","author_index":"菲尔普斯"},{"id":"8ccb240acaf1eee2e5457b7879df4395","title":"Anki×生物-记忆方法和经验分享","content":" 主题概览\n\nAnki的简要介绍\n我是如何了解到Anki的\n高三后期Anki的使用体验及效果\nAnki给我带来的思考和启发\n\n\n 前言\n说来惭愧。\n笔者本来计划高考后的暑假集中精力写一系列文章来分享高考的应试经验和收获，当作是将自己三年的一些经验进行简单的总结和输出，能够分享出来供大家参考。但因暑假非常非常忙，跟同学一起搞一波小创业的同时还要兼顾家里的琐事，实在抽不出时间。大一入学一个月来更是各种头秃（真·高四），今天总算在学习之余能抽空写一篇文章，分享笔者高三后期使用Anki记忆生物知识的经历。\n 引入\n你是否有过这样的经历？\n\n每完成一章学习之后，将知识集中梳理到笔记本上\n做了详细全面的总结，还加入了个人的理解和思考\n甚至还整理了知识大纲或者思维导图…\n\n但是只有快到期末的时候才会翻开复习\n而且翻开后发现都忘差不多了。。。\n如果您有这样的习惯，笔者强烈推荐您尝试一下Anki~\n今年疫情期间，笔者宅在家里复习备考，时间比较充裕，于是按照【植物】和【动物】两个专题将整个高中知识从不同的切入点重构了一遍，在幕布整理成大纲后，还将相关的经验分享到了知乎（文末附链接）。\n但笔者后来发现，知识“主题式”、“脉络式”的梳理工作固然重要（我将其理解为类似于梳理重构记忆神经回路的过程，这对形成知识体系很有帮助），但当我们面对联系松散的、碎片化的记忆内容时，这种方式是不太适用的。\n简单来讲，我们需要搞清楚的问题是——我想要训练的，是对知识体系脉络的熟悉感和掌控感，还是对各种碎片化知识的迅速反应？\n举个例子，当你需要构建《生物必修三》的【生态系统】章节的整体框架和知识结构时，你需要的是上述中的前者——利用一切你能利用的大纲、思维导图、手写框图等【结构化整理工具】来整理和重构你的记忆网络；当你需要将《生物选修一》中的各种制果酒果醋酸菜腐乳的步骤细节记得滚瓜烂熟形成肌肉记忆时，你需要的是上述中的后者——训练自己对特定关键词的迅速反应能力。\n今天笔者想要介绍的Anki就是上文提到的“训练快速反应”的非常理想的一款工具。\n 什么是Anki\n广义上来讲，Anki是一种记忆方法。\n大家应该都了解过所谓的“艾宾浩斯遗忘曲线”，笔者在此不再赘述——简单来讲，其想要传达的核心思想就是：要想建立牢固的记忆，必须依靠“间隔重复”的方法，按一定的周期定期回顾复习，不断提醒大脑巩固记忆。\nAnki便是一种将“间隔重复”和“遗忘曲线”理论付诸实践的方法。它的基本记忆模块叫“记忆卡片”，一定数目的关系比较密切的、属于同一目录的卡片组成“记忆牌组”，使用者需要每天学习一定数目的卡片，同时复习之前已经学习过的卡片，系统会根据用户对卡片的熟悉程度，自动安排每张卡片在之后每一天的复习间隔和出现次数——这样以来，使用者不需要将精力分散在安排复习计划上（毕竟这是一件让人非常头疼的事情），只需要每天在黄金记忆时间（起床后与睡前）或碎片时间打开App进行卡片的复习和学习即可，以达到“在不知不觉间”牢固记忆的目的。\n现在市面上有不同基于Anki的电脑客户端和App，文末会附上传送门，方便大家作进一步的了解，本文的焦点主要还是集中在Anki的思想方法和简单应用。\n 我是如何了解到Anki的\n说来也巧，今年疫情在家备考时，经常上知乎写一些与数学、生物相关的文章，既是利用输出的方式来巩固已有知识，也当作是极度紧张焦虑时期的一种自我缓冲和放松的方式。\n但说不焦虑是假的，在当时笔者学校进行的各种线上测试中，笔者成绩起伏不定，内心非常焦虑，各种知识点看了又忘，答题手感差，记忆也不流畅，经常半夜因为焦虑而睡不着觉。\n就在某天凌晨2点，笔者在知乎刷到了叶峻峣写的有关Anki的文章，当时看了非常激动——笔者终于有机会可以借助软件工具来改正自己的不良的复习习惯了。当时笔者在黑夜中从床上蹦起来，坐在书桌前一边阅览Anki专栏的相关文章，一边思索着如何将自己需要将哪些知识放到Anki中复习、以及如何将要记忆的知识用卡片的形式组织起来…\n完成了初步计划之后，抬头一看已经凌晨4点半，当时距离高考还有3个月多一些，但笔者在两个多月的黑暗孤独的备考以来，第一次在窗外依稀的光亮中看到了希望。\n Anki的使用体验和效果\n先说效果：\n想必全国卷地区的在读高三生或者高考过来人都知道，《生物必修三》《生物选修一》《生物选修三》这三本课本中，有大量需要背诵的碎片知识，尤其是后两本书的各种碎片化知识更是几乎毫无联系，但偏偏理综就爱考上述内容的默写题。笔者在离高考剩下3个月左右的时间开始使用Anki，在不算长的时间内，成功做到了对对上述三本教材中几乎所有默写题滚瓜烂熟、秒问秒答的程度。\n当初在手机上下载Anki的App之后，笔者每天抽1小时左右仔细阅读生物教材，将每个所有可能以【问答/默写题】形式考察的知识点，都制成了Anki卡片。\nBTW，当时笔者在家里实在静不下心来学习，于是每天都会去社区图书馆，是的你没看错，所有Anki卡片的学习和复习都是在我走路往返图书馆的路上完成的！\n只要你每天肯割舍那么一点点走路听歌的时间，日积月累就会达到惊人的效果，这就是科学的“间隔重复”记忆方法的力量！\n\n\n\n\n\n\n\n\n\n备注：除了背诵生物文字默写题以外，笔者在平时订正理综试卷时，也会将一些易错点以【短语/短句】的形式概括制成卡片来反复提醒自己，亲测这种方法比所谓的错题本要有效得多~\n最后笔者高考的成绩虽说没能特别理想，差一步踏进北航，但也算是没有什么遗憾了。即便最后看不到生物成绩，难以量化评估Anki的使用效果，但至少在高三的后期阶段，Anki作为一项提高效率的记忆工具，极大地增强了笔者的应试信心（算是有一种模糊的精神寄托？），这也算是很重要的一项收获。\n 思考和启发\n说了这么多有关Anki的具体原理和使用体验，笔者还认为，我们更应该从“使用Anki得到的良好效果”来反向思考一个问题——那就是合适的工具和方法之于提升学习效率的重要性。\n从小到大，我们都被长辈灌输一种“个人努力胜于一切”的观念，以至于我们在成长过程中、在学习生活中，都或多或少地过分强调了“个人主观能动性”，认为只要拼命努力就可以做好一切事情，反倒忽视了工具、方法在提高效率方面不可替代的重要性。\n在做一件事情之前，笔者认为需要先准备好以下几点：\n（尽量避免过多的理论，只给出具体的例子）\n 1.信息\n\n\n\n\n\n\n\n\n\n信息优势帮助你走向正确的决策和路线\n如果你在高一就清楚地了解到高三的考察重点和高压氛围，你是不是可以从高一就开始认真审阅生物课本、背诵重点句，而不是到高三才意识到这些内容的重要性？你是不是可以从高一就开始坚持晨跑，提前准备好强健的体魄以应对高强度的竞争，而不是在高三后期每天累成狗之后还要坚持下操场练体能？…\n 2.资源\n\n\n\n\n\n\n\n\n\n资源优势使你避开弯路并加快你进步的速度\n如果你在高一阶段就向有经验的学长学姐去了解【圆锥曲线】模块的经典书籍和学习路线，你是不是可以避免在鱼龙混杂的教辅市场东摸西找、最后还将时间浪费在了一本质量堪忧的教辅书上、建立了错误的思维模式？如果你在高一阶段就设法了解过某个学科的优秀网课资源，是不是可以避免受教学水平较差的老师的错误引导导致学习痛苦不堪（我是说如果）？…\n 3.工具\n\n\n\n\n\n\n\n\n\n工具提高你的学习效率\n如果你提前了解过Anki这款高效的记忆工具，你是不是可以在高中三年的学习中积累大量的卡片和知识、让自己复习的效率数倍于他人？如果你提前了解过各种数学绘图软件，你是不是在学习导数的时候对各种动态参数变化问题能有更直观的理解和体会？\n 4.决心\n\n\n\n\n\n\n\n\n\n这反而是最次要的\n确定自己的学习路线并坚定地执行有多重要，想必不需要我过多地叙述了。\n以上都是我的切身体会，笔者只想强调一点，那就是：在开始做一件事情之前，你在上述四个方面所花时间的价值，远远高于后续坚持努力的时间价值。\n当然，努力也很重要，我们要用最高效的方法，付出不亚于他人的努力。\n","slug":"Anki_Biology","date":"2020-10-26T06:53:36.000Z","categories_index":"高考","tags_index":"高考,生物","author_index":"菲尔普斯"},{"id":"3b3adefb31727270472d3ca610693d83","title":"VuePress部署轻量级个人博客","content":"本文介绍笔者折腾 VuePress 的过程。\n\n 1. 安装node.js\n到官网下载稳定版安装即可\n 2. 按照官网指示进行基本安装配置\n\n创建目录\n包管理器初始化（yarn, npm二选一）\n安装vuepress为本地依赖\n创建docs目录，并在下面手动创建README.md\npackage.json添加两条scripts\n用npm run docs:dev命令启动服务器\n在localhost上初步预览\n\n\n\n\n\n\n\n\n\n\n如果出现显示中文乱码问题，是cmd创建的md文件编码不对，删掉自己建一个即可\n 3. 创建官网推荐的目录结构（区分大小写）\n\n\n\n\n\n\n\n\n\n注意：所有文件的相对路径都相对于docs目录\n 4. 了解默认路由地址\n\n\n\n文件相对路径\n页面路由地址\n\n\n\n\n/README.md\n/\n\n\n/guide/README.md\n/guide/\n\n\n/config.md\n/config.html\n\n\n\n\n\n\n\n\n\n\n\n\n注意：如果是要指某目录下默认的README.md，注意目录最后也要加一个斜杠\n 5. 了解基本原理\nmd文件放到.docs目录下后，在根目录下执行npm run docs:dev命令，就会在指定的输入目录（默认在../dist目录下）以docs下的文件目录结构为参照，输出相同的目录结构，将对应目录下的.md文件生成html静态页面\n 6. 什么时候需要重新执行dev命令？\n\n\n\n\n\n\n\n\n\n注意：dev命令是包含了build命令在内的\n\n\n凡是更改了配置文件/config.js或者其他配置文件的，必须重新执行一次npm run docs:dev，但如果是对已经存在的且已经build过的markdown文件进行更改，本地localhost是可以自动刷新的，不需要重新build或者dev（当然，如果vuepress部署在github或者虚拟主机，当然要重新上传）\n\n\n每次build，相当于是将docs下的目录结构copy到dist下，再每个目录一一对应地，将md文件转换为静态html页面\n\n\n 7.如何部署到云？\n无论是放到虚拟主机、码云还是github上，都只需要将dist目录下的所有东西（也就是全部的静态页面）扔上去，就可以了，虚拟主机需要放到public_html文件夹下，如果是github需要放到对应的repository下\n","slug":"vuepress_configurating","date":"2020-10-23T16:00:00.000Z","categories_index":"","tags_index":"前端,博客","author_index":"菲尔普斯"},{"id":"87fe1dbbd2e32cc15a0b1461130095f4","title":"LC 724 寻找数组中心索引","content":" 题目\n给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。\n我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n\n示例 1：\n输入：\nnums &#x3D; [1, 7, 3, 6, 5, 6]\n输出：3\n解释：\n索引 3 (nums[3] &#x3D; 6) 的左侧数之和 (1 + 7 + 3 &#x3D; 11)，与右侧数之和 (5 + 6 &#x3D; 11) 相等。\n同时, 3 也是第一个符合要求的中心索引。\n示例 2：\n输入：\nnums &#x3D; [1, 2, 3]\n输出：-1\n解释：\n数组中不存在满足此条件的中心索引。\n说明：\n\nnums 的长度范围为 [0, 10000]。\n任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-pivot-index\n 分析\n\n外层循环对数组每个元素进行遍历\n内层两个分开的循环，左指针遍历当前元素左边的元素并求和，右指针遍历当前元素右边的元素并求和，然后比较左右和是否相等，相等则截断操作并返回索引值\n后来发现自己是SB，明明可以不用右指针，可在一开始就遍历数组元素，对所有元素求和并储存all_sum，以后每次得到left_sum时，可直接用一条减法来算出right_sum，就不用浪费时间\n注意自己测试的用例一定要涵盖一般情况和特殊情况，确定没有问题再提交\n传参时传入指向数组的指针时，在函数中可直接用数组名访问数组（因为实际上这个指针传入的就是数组的首地址，跟直接传数组名是一样的效果）\n注意小细节：for循环最后一步的自增，小于号取不取等，是否所有的输入情况都已经保证函数有出口（返回值）…\n\n 代码\nint pivotIndex(int* nums, int numsSize)&#123;\n    int left_sum = 0;\n    int right_sum = 0;\n    int i = 0, l_piv = 0, r_piv = 0;\n    int all_sum = 0;\n    for (int k = 0; k &lt; numsSize; k++) &#123;\n        all_sum += nums[k];\n    &#125;\n    for (i = 0; i &lt; numsSize; i++) &#123;\n        for (l_piv = 0; l_piv &lt; i; l_piv++) &#123;\n            left_sum += nums[l_piv];\n        &#125;\n        right_sum = all_sum - left_sum - nums[i];\n        // for (r_piv = numsSize-1; r_piv > l_piv; r_piv--) &#123;\n        //     right_sum += nums[r_piv];\n        // &#125;\n        if (left_sum == right_sum) &#123;\n            return l_piv;\n            break;\n        &#125;\n        left_sum = 0;\n        right_sum = 0;\n        //printf(\\n);\n    &#125;\n    if (i == numsSize) &#123;\n        return -1;\n    &#125;\n    return 0;\n&#125;","slug":"find_middle_index","date":"2020-10-19T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,数组","author_index":"菲尔普斯"},{"id":"cc5694c524a85a8db61dce85d10a8751","title":"Win命令行常用语句","content":" 操作文件和目录\n切换到某个目录，用具体路径代替[directory_name]\ncd [directory_name]\n\n在当前操作目录下新建文件夹\nmkdir [new_folder_name]\n用Visual Studio Code打开当前文件夹作为工作区\ncode .\n在命令行中运行当前目录下.exe可执行文件\n.\\[file_name].exe\n 编译代码源文件\n编译当前目录下的.c源码文件为可执行文件，文件名用[file_name]代替，第一个[file_name]为源码文件名，第二个[file_name]为生成的.exe文件的文件名\ngcc [file_name].c -o [file_name]\n若要编译C++文件，同理\ng++ [file_name].c -o [file_name]\nJava源文件编译生成.class文件\njavac [file_name].java\n运行java编译生成的.class文件，[class_name]代表主类名\njava [class_name]","slug":"win_powershell_commands","date":"2020-10-19T16:00:00.000Z","categories_index":"Windows","tags_index":"命令行,Windows","author_index":"菲尔普斯"},{"id":"bf14c276bb885a007bbd4fa6c728a7f6","title":"LC 73 矩阵置零","content":" 题目\n给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。\n\n示例 1:\n输入: \n[\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n输出: \n[\n  [1,0,1],\n  [0,0,0],\n  [1,0,1]\n]\n示例 2:\n输入: \n[\n  [0,1,2,0],\n  [3,4,5,2],\n  [1,3,1,5]\n]\n输出: \n[\n  [0,0,0,0],\n  [0,4,5,0],\n  [0,3,1,0]\n]\n进阶:\n一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。\n一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。\n你能想出一个常数空间的解决方案吗？\n\n\n\n\n\n\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/set-matrix-zeroes\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n 分析\n(1) 最朴素的想法，遍历矩阵中的每一个元素，检查是否为0\n(2) 若是0，则所在行与所在列的所有元素（除0外）全部标记为-99\n(3) 标记完后重新遍历矩阵，将值为0或-99的全部设为0\n(4) 这里要注意，为什么第2点说标记-99时要排除本身值为0的元素？因为如果一开始同一行或同一列有几个0，如果在找到第一个0时，就用-99标记所在行、列的所有元素，那么所在行列的其他0就会被覆盖掉，继续遍历的时候会被忽略，导致最后有些行列没有清零\n 代码\nvoid setZeroes(int** matrix, int matrixSize, int* matrixColSize)&#123;\n    for (int row = 0; row &lt; matrixSize; row++) &#123;\n        for (int col = 0; col &lt; matrixColSize[0]; col++) &#123;\n            if (matrix[row][col] == 0) &#123;\n                for (int i = 0; i &lt; matrixColSize[0]; i++) &#123;\n                    if (matrix[row][i] != 0) &#123;\n                        matrix[row][i] = -99;\n                    &#125;\n                &#125;\n                for (int j = 0; j &lt; matrixSize; j++) &#123;\n                    if (matrix[j][col] != 0) &#123;\n                        matrix[j][col] = -99;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;          \n    &#125;\n    for (int row = 0; row &lt; matrixSize; row++) &#123;\n        for (int col = 0; col &lt; matrixColSize[0]; col++) &#123;\n            if (matrix[row][col] == -99 || matrix[row][col] == 0) &#123;\n                matrix[row][col] = 0;\n            &#125;\n        &#125;          \n    &#125;\n&#125;\n 改进的解法\n(1) 利用首行和首列（姑且称之为“矩阵外围”）作为标记数组，来记录所指的行或列是否需要清零（相当于一个“表头”的作用）\n(2) 一开始先检查左上角的元素是否为0，决定外围是否需要全部清零（当然外围清零这个操作一定要留到最后）\n(3) 分别检查外围行和外围列（不包括左上角元素，否则会出现覆盖问题）是否存在0，一旦发现0，开个变量先记为1，意为在程序的最后需要对外围行(列)清零\n(4) 遍历内矩阵（即去掉外围的矩阵），每次找到0，就将那个位置所对应的行列“表头”设为0\n(5) 再次遍历内矩阵，每到一个位置，就检查该位置对应的表头是否为0，若是，则该位置设为0，一轮遍历下来，内矩阵已经清零完毕\n(6) 最后处理外围，根据一开始的记录变量 if_Row0_Need 和 if_Col0_Need 来决定是否清零外围行或列，清零之后，流程结束。\n(7) 虽然改该方法时间复杂度仍为O(n^2)，但其中的【表头记录】思想是值得学习的\nvoid setZeroes(int** matrix, int matrixSize, int* matrixColSize)\n&#123;\n    int row = 0, col = 0;\n    int if_Row0_Need = 0;//记录外围行在最后是否需要清零\n    int if_Col0_Need = 0;//记录外围列在最后是否需要清零\n\n    //对左上角元素先写特判，否则引发覆盖问题\n    if (matrix[0][0] == 0) &#123;\n        if_Col0_Need = 1;\n        if_Row0_Need = 1;\n    &#125;\n\n    //初始在第0行查找是否有0，先暂时记录，最后清理\n    //查找对象不包括左上角元素\n    for (int i = 1; i &lt; matrixColSize[0]; i++) &#123;\n        if (matrix[0][i] == 0) &#123;\n            if_Row0_Need = 1;\n        &#125;\n    &#125;\n    //初始在第0列查找是否有0，先暂时记录，最后清理\n    //查找对象不包括左上角元素\n    for (int j = 1; j &lt; matrixSize; j++) &#123;\n        if (matrix[j][0] == 0) &#123;\n            if_Col0_Need = 1;\n        &#125;\n    &#125;\n\n    //遍历内矩阵，用第0行与第0列（表头）来记录对应行或列是否需要清零\n    for (row = 1; row &lt; matrixSize; row++) &#123;\n        for (col = 1; col &lt; matrixColSize[0]; col++) &#123;\n            if (matrix[row][col] == 0) &#123;\n                matrix[0][col] = 0;\n                matrix[row][0] = 0;\n            &#125;\n        &#125;\n    &#125;\n\n    //再次遍历内矩阵，根据外围（表头）的标记对内矩阵清零\n    for (row = 1; row &lt; matrixSize; row++) &#123;\n        for (col = 1; col &lt; matrixColSize[0]; col++) &#123;\n            if (matrix[row][0] == 0 || matrix[0][col] == 0) &#123;\n                matrix[row][col] = 0;\n            &#125;\n        &#125;\n    &#125;\n\n    //最后根据记录变量决定是否清零外围行和外围列\n    if (if_Row0_Need == 1) &#123;\n        for (col = 0; col &lt; matrixColSize[0]; col++) &#123;\n            matrix[0][col] = 0;\n        &#125;\n    &#125;\n    if (if_Col0_Need == 1) &#123;\n        for (row = 0; row &lt; matrixSize; row++) &#123;\n            matrix[row][0] = 0;\n        &#125;\n    &#125;\n&#125;","slug":"zero_matrix","date":"2020-10-19T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,题解,数组,矩阵","author_index":"菲尔普斯"},{"id":"cd323795eed6bc4ed4af1d469745b308","title":"VSCode C/C++环境配置傻瓜教程","content":"介绍VSCode C/C++环境配置过程\n\n 一、官网下载VS Code并安装\n\n\n\n\n\n\n\n\n\n你想装在哪个盘都没问题\nVisual Studio Code 64bit for Windows 官网下载地址\nhttps://code.visualstudio.com\n 二、下载MinGW编译器\n\n\n\n\n\n\n\n\n\n进行这一步首先你要翻墙，具体怎么翻墙请查看科学上网教程\n访问SourceForge官网，在搜索框输入 mingw ，点击搜索，如图所示\n[SourceForge官网链接：https://sourceforge.net/]\n\n\n\n搜索结果出来后，向下滚动页面，选择 MinGW-w64 for 32 and 64 bit Windows ，即下图圈出的这一项（不要选其他！）\n\n\n点击进入之后，不要急！不要点 Download ！点 Download 按钮下面的 File\n\n\n点击File后，将页面向下滚动，找到并点击MinGW-W64 GCC-8.1.0下面的 x86_64-win32-seh\n\n\n点击后稍等几秒，会自动开始下载，是一个 .7z 压缩包，我们先将它保存到桌面\n\n\n 三、安装编译器\n 1.打开压缩包，先将里面的文件拖到桌面上\n\n\n\n\n\n\n\n\n\n如果压缩包打不开，请百度haozip，下载解压软件\n\n\n 2.将刚刚拿出来的mingw64文件夹，移动到C:\\Program Files目录下\n\n\n\n\n\n\n\n\n\n备注：其实你想放哪都可以，只要你别忘了你把它放在什么路径下就行了\n\n\n 3.现在随便用点什么东西，记下下面三个路径（后面配置vscode会用到）\n编译器目录：\nC:\\Program Files\\mingw64\\bin\nC++编译器地址：\nC:\\Program Files\\mingw64\\bin\\g++.exe\nC++Debugger地址：\nC:\\Program Files\\mingw64\\bin\\gdb.exe\n\n\n\n\n\n\n\n\n\n如果自己将mingw64文件夹放到了别的目录，请自行替换成对应路径\n\n 4.按下图所示步骤打开【高级系统设置】\n打开资源管理器，右键点击 此电脑 ，点击 属性 ，跳转到新的窗口，在新窗口左栏找到 高级系统设置 ，点击进入\n\n\n 5.打开环境变量配置窗口\n\n\n 6.选中下方【系统变量】条目框里面的【Path】，然后点击下方的【编辑】\n\n\n 7.点击【新建】，把之前讲过的”编译器目录“复制进去，点击确定\n也就是这条路径\nC:\\Program Files\\mingw64\\bin\n\n\n 8.检验编译器是否安装成功\n搜索 cmd 并运行\n\n\n输入下面的命令（注意gcc和-v中间有一个空格）\ngcc -v\n\n如果弹出一大堆东西，且最后一行写了gcc的版本号为8.1.0，则安装成功\n\n 四、配置VS Code\n 1.建立VS Code工作区\n找个你喜欢的目录，在此目录下新建一个文件夹，比如CppWorkSpace，它将作为你用VS Code编写C/C++代码的工作区，比如我将我的工作区建立在以下路径\nD:\\CppWorkSpace\n\n\n\n\n\n\n\n\n\n注意！工作区的完整路径（也就是从盘符开始一直到工作区文件夹经过的路径）不能含有中文字符！否则后续Debug过程会出现报错！\n接下来请在工作区目录下建立一个叫作 .vscode 的文件夹，即\nD:\\CppWorkSpace\\.vscode\n进入 .vscode 文件夹，新建一个名叫 tasks.json 的文件\nD:\\CppWorkSpace\\.vscode\\tasks.json\n打开VS Code，在顶部菜单栏选择 File -&gt; Open Folder ，选择你的CppWorkSpace文件夹\n\n\n\n现在可以从VS Code的左边栏看见打开的工作区目录了\n\n\n 2.配置tasks.json文件\n双击打开 tasks.json ，若里面有代码，将其全部删除，然后复制以下代码，粘贴到tasks.json中\n&#123;\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n      &#123;\n        \"type\": \"shell\",\n        \"label\": \"C/C++: g++.exe build active file\",\n        \"command\": \"C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe\",\n        \"args\": [\"-g\", \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\"],\n        \"options\": &#123;\n          \"cwd\": \"$&#123;workspaceFolder&#125;\"\n        &#125;,\n        \"problemMatcher\": [\"$gcc\"],\n        \"group\": &#123;\n          \"kind\": \"build\",\n          \"isDefault\": true\n        &#125;\n      &#125;\n    ]\n  &#125;\n粘贴完毕后，我们需要做一点改动，将这个路径\n&#123;\n\"command\": \"C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-win32-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe\"\n&#125;\n替换成\n&#123;\n\"command\": \"C:\\\\Program Files\\\\mingw64\\\\bin\\\\g++.exe\"\n&#125;\n也就是我们上文提到的【编译器地址】，但是注意！需要将单斜杠 \\ 改成双斜杠 \\\\ ，JSON文件才能识别你的编译器路径。\n到这里， tasks.json 配置完毕。\n请重启VS Code！\n\n 3.配置launch.json文件\n与上一条类似地，在 .vscode 目录下新建一个 launch.json 文件，并用VScode打开\n\n如果打开后里面有代码，请全部删除，然后将以下代码复制粘贴至launch.json\n&#123;\n\"version\": \"0.2.0\",\n\"configurations\": [\n&#123;\n\"name\": \"g++.exe - Build and debug active file\",\n\"type\": \"cppdbg\",\n\"request\": \"launch\",\n\"program\": \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\",\n\"args\": [],\n\"stopAtEntry\": false,\n\"cwd\": \"$&#123;workspaceFolder&#125;\",\n\"environment\": [],\n\"externalConsole\": false,\n\"MIMode\": \"gdb\",\n\"miDebuggerPath\": \"C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe\",\n\"setupCommands\": [\n&#123;\n\"description\": \"Enable pretty-printing for gdb\",\n\"text\": \"-enable-pretty-printing\",\n\"ignoreFailures\": true\n&#125;\n],\n\"preLaunchTask\": \"C/C++: g++.exe build active file\"\n&#125;\n]\n&#125;\n我们需要将\n&#123;\n  \"miDebuggerPath\": \"C:\\\\Program Files\\\\mingw-w64\\\\x86_64-8.1.0-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe\"\n&#125;\n替换成\n&#123;\n  \"miDebuggerPath\": \"C:\\\\Program Files\\\\mingw64\\\\bin\\\\gdb.exe\"\n&#125;\n也就是我们上文提到的【C++Debugger地址】，同样注意单斜杠全部改成双斜杠。\n配置完成。\n请重启VS Code！\n 五、运行和Debug\n 1.编译运行\n在工作区目录下新建一个 .cpp 文件，如 kbd.cpp ，随意编写一段C或C++代码，如\n#include &lt;cstdio&gt;\nusing namespace std;\nint main ()\n&#123;\nprintf(&quot;hahahaha&quot;);\nreturn 0;\n&#125;\n按下 Ctrl + Shift + B ，如有弹出选择，则选 C/C++:g++.exe build active file\n此时不出意外，终端会弹出\n终端将被任务重用，按任意键关闭\n或者\nTerminal will be reused, press any key to exit.\n如图\n\n\n说明已经编译器已经成功将 kbd.cpp 编译成 kbd.exe 并放到同个目录下\n但它并不会自动帮你运行\n此时可以返回VS Code自带终端，输入\n.\\kbd.exe\n即可在VS Code自带终端里运行代码，如图\n\n 2.另一种方法——直接用自带终端编译运行\n我们需要知道，命令行是有【当前目录】的，也就是这行字\nPS D:\\CppWorkSpace>\n的意思表示命令行当前操控的目录为D盘下的CppWorkSpace目录\n我们需要编译的 .cpp 代码源文件必须在控制台操控的目录下\n例如我想要编译CppWorkSpace目录下的a.c文件，则应输入 g++ a.c（中间有空格），即\nPS D:\\CppWorkSpace>g++ a.c\n片刻后命令行就会刷新，表示编译完成，这时可以直接用 .\\a.exe 命令运行编译好的程序\nPS D:\\CppWorkSpace>.\\a.exe\n全过程如下图中控制台所示\n\n\n附常用命令：\n（1）在当前目录下新建名为 name 的文件夹\nmkdir name\n（2）进入当前目录下名为 folder 的子目录\ncd folder\n（3）用vscode打开当前目录作为工作区\ncode .\n\n 3.调试\n例如：在CppWorkSpace工作区下，打开 abc.cpp ，按 F5\n\n\n\n\n\n\n\n\n\n部分笔记本电脑如联想小新的需要按 Fn + F5\n就会有断点、调试、监控功能\n\n\n\n\n\n\n\n\n\n如果按F5后报错 No such file or directory ，请检查文件完整路径是否含有中文！\n\n","slug":"cpp_vscode","date":"2020-10-15T15:00:00.000Z","categories_index":"C/C++","tags_index":"工具,C/C++,环境配置,VSCode","author_index":"菲尔普斯"},{"id":"91488b0487c2b26df0c04913aab99fd6","title":"[Demo] 堆排序","content":"#include &lt;stdio.h>\n\nvoid SwapInArray(int arr[], int x, int y)\n&#123;\n    /*Function：将数组中两个元素的值进行交换*/\n    int tmp;\n    tmp = arr[x];\n    arr[x] = arr[y];\n    arr[y] = tmp;\n    return; \n&#125;\n\nvoid Heapify(int tree[], int n, int i)\n&#123;\n    /*Function：使tree[]中给定的以i为父节点的单个子树成为堆*/\n\n    //[递归出口]若遍历到任何一个叶节点，结束Heapify\n    if (i > n/2) &#123;\n        return;\n    &#125;\n\n    //首先默认i节点数值最大\n    int max = i;\n    //若左儿子存在且更大，暂时标记左儿子最大（先不交换，因为可能右儿子还要更大）\n    if (i*2 &lt;= n &amp;&amp; tree[i*2] > tree[max]) &#123;\n        max = i*2; \n    &#125;\n    //若右儿子存在且还要更大，标记右儿子为该三元子树中的最大节点\n    if (i*2+1 &lt;= n &amp;&amp; tree[i*2+1] > tree[max]) &#123;\n        max = i*2+1;\n    &#125;\n    //如果i不是最大，说明需要更换\n    if (max != i) &#123;\n        //交换i和儿子max的数值（不交换编号）\n        SwapInArray(tree, max, i);\n        Heapify(tree, n, max);\n        /*\n            为什么此处需要递归？\n            因为我们在BuildMaxTree()中是自底向上使用Heapify()的，\n            可能会出现的情况是：Build之前的乱序树中，接近顶端\n            有一些很小很小的数，我们在Build时遍历到此处，对接近顶端的\n            子树使用Heapify时，这些很小的数会下沉，成为下方子树的父节点，\n            而它的子节点有可能比它要大，所以我们要对这些子树继续Heapify，\n            让这些很小的数继续下沉，有多深沉多深，\n            所以Heapify()需要递归调用自己来处理脚下的所有树，\n            保证让上面任何应该下沉的小数都下沉到它应该去的深度。\n        */\n    &#125;\n    return;\n&#125;\n\nvoid BuildMaxHeap(int tree[], int n)\n&#123;\n    /*Function：将无序数组建立成最大堆*/\n\n    //从倒数第二层最后一个节点开始，向上遍历每一个节点，对每一个节点Heapify()\n    for (int i = n/2; i >= 1; i--) &#123;\n        Heapify(tree, n, i);\n    &#125;\n&#125;\n\nint DeleteMax(int tree[], int n)\n&#123;\n    /*\n        将末尾叶节点值直接赋给树顶节点，\n        此时除了树顶外所有子树都满足最大堆，\n        再对树顶节点Heapify()\n    */\n    int tmp;\n    tmp = tree[1];\n    tree[1] = tree[n];\n    Heapify(tree, n, 1);\n    return tmp;\n&#125;\n\n\nint main()\n&#123;\n    int tree[10001];\n    int arr[10001];//存放排序结果\n    int num;\n    scanf(\"%d\", &amp;num);\n    for (int i = 1; i &lt;= num; i++) &#123;\n        scanf(\"%d\", &amp;tree[i]);\n    &#125;\n\n    BuildMaxHeap(tree, num); \n\n    //倒序记录最大堆输出结果\n    for(int i = num; i >= 1; i--) &#123;\n        arr[i] = DeleteMax(tree,i);\n        /*\n            如果每次for循环都向DeleteMax()传递参数num，\n            那么DeleteMax()中的n--就不起作用，\n            于是改成每次for循环向DeleteMax()传输i,\n            等效于手动删除堆的末尾叶节点.\n        */\n    &#125;\n    for (int i = 1; i &lt;= num; i++) &#123;\n        printf(\"%d \",arr[i]);\n    &#125;\n    return 0;\n&#125;","slug":"demo_heapsort","date":"2020-10-03T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,排序,堆","author_index":"菲尔普斯"},{"id":"1abc49c5902eda16bbaa0acd742568ec","title":"[Demo] 归并排序","content":"#include &lt;stdio.h>\n#include &lt;stdlib.h>\n\nvoid Merge (int arr[], int L, int M, int R)\n&#123;\n    /*此处数组的头指针和尾指针需要参数给出，便于获取数组长度*/\n\n\n\n    int LEFT_SIZE = M - L + 1; //M算作左序列一份子，左序列长度额外加一\n    int RIGHT_SIZE = R - M; //M不算右序列份子，右序列长度不需要加一\n    \n    //分别新建数组存放左、右子序列\n    int L_arr[LEFT_SIZE];\n    int R_arr[RIGHT_SIZE];\n\n    //先原封不动将数组左、右两边分别copy到左、右子序列\n    for (int i = L; i &lt;= M; i++) &#123; //M是属于左序列的，所以要从L到M遍历\n        L_arr[i-L] = arr[i];\n    &#125;\n    for (int j = M+1; j &lt;= R; j++) &#123; //M不属于右序列，所以从(M+1)遍历到R\n        R_arr[j-M-1] = arr[j];\n    &#125;\n\n    //复制完毕后，同时操作左右子序列，排序、重构母序列\n    int i = 0; //左序列起始位置\n    int j = 0; //右序列起始位置\n    int k = L; //k作为母序列控制指针\n\n    //i,j都未到终点时，交替移动\n    //此处不等号不取等，就是因为数组长度与末位下标相差1\n    while (i &lt; LEFT_SIZE  &amp;&amp; j &lt; RIGHT_SIZE) &#123;\n        if (L_arr[i] &lt;= R_arr[j]) &#123;\n            arr[k] = L_arr[i];\n            i++;\n            k++;\n        &#125; else &#123;\n            arr[k] = R_arr[j];\n            j++;\n            k++;\n        &#125;\n    &#125;\n    //若j先超过终点，将左边子序列后面剩余的数按顺序照搬到母序列\n    while (i &lt; LEFT_SIZE) &#123;\n        arr[k] = L_arr[i];\n        k++;\n        i++;\n    &#125;\n    //若i先超过终点，将右边子序列后面剩余的数按顺序照搬到母序列\n    while (j &lt; RIGHT_SIZE) &#123;\n        arr[k] = R_arr[j];\n        k++;\n        j++;\n    &#125;\n&#125;\n\nvoid MergeSort (int arr[], int L, int R)\n&#123;\n    /*\n    为什么将分界点的计算放到MergeSort()里面而非其他位置？\n    1.Merge()是被MergeSort()调用的子函数，在MergeSort中算出M，以参数形式传给Merge()，更方便\n    2.避免了在main()中计算M的麻烦，保证了main()中只写主干程序\n    */\n\n    /*\n        此处有巨坑，算出半长度后要记得加上左指针值，\n        另外要考虑整数除法其实是向下取整的，\n        要特别注意到最深处（每个子序列只有一个数）时，L,M,R的取值分别是多少，\n        以此确定[防止递归死循环的判定条件]应该怎么写，\n        可以举简单序列在纸上模拟运行到最后一步，观察L,M,R的特点，\n        本例中得出判定条件为 if (L > (R-1))\n    */\n    int M = L + (R - L) / 2;   //中点到底偏向哪边不重要，举简单例子观察就行\n    \n    //递归调用函数必备，防死循环的条件判定\n    //一般来讲，最好通过观察实际用例来写，yy很容易出错\n    if (L > (R-1)) &#123;\n        return;\n    &#125; else &#123;\n        MergeSort(arr, L, M);\n        MergeSort(arr, M+1, R);\n        Merge(arr, L, M, R);\n    &#125;\n    \n&#125;\n\nint main ()\n&#123;\n    //输入待排序列的长度与内容\n    int n = 0;\n    int arr[100000];\n    scanf(\"%d\", &amp;n);\n    for (int i = 0; i &lt; n; i++) &#123;\n        scanf(\"%d\",&amp;arr[i]);\n    &#125;\n\n    //排序\n    MergeSort(arr, 0, n-1);\n\n    //输出结果\n    for (int i = 0; i &lt; n; i++) &#123;\n        printf(\"%d \",arr[i]);\n    &#125;\n    return 0;\n&#125;\n\n/*\n    补充：\n    1.测试用例一定要全面，长度为奇数和偶数的序列都要测试；\n    2.从0开始还是从1开始？在写的时候就要想好，等全部码完再查错很困难；\n    3.不等号到底要不要取等？用特殊样例测清楚再写；\n    4.如果从0开始管理数组，特别注意数组长度和末尾下标之间是相差1的；\n*/","slug":"demo_mergesort","date":"2020-10-02T16:00:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,排序","author_index":"菲尔普斯"},{"id":"cdcaa64e46db961619b177c66af1aa77","title":"[Demo] 快速排序","content":"#include &lt;stdio.h>\n\n//对要操作的变量采用全局定义，可以避免指针的操作\nint a[101],n;\nint times = 0;\n\nvoid quickSort(int left, int right)\n&#123;\n    //left,right分别为左右指针\n    \n    int i, j, t, bin;\n    //若指针错位，退出函数\n    if (left > right) &#123;\n        return;\n    &#125;\n\n    //bin是一开始确定的基准数，也就是left指针所指的数\n    bin = a[left];\n    i = left;//左搜索针\n    j = right;//右搜索针\n    while (i != j) &#123;\n        while (a[j] >= bin &amp;&amp; i &lt; j) &#123;\n            j--;\n        &#125;\n        //先右后左，右搜索针找不到就一直找，找到符合要求的第一个，才轮到左搜索针出发\n        while (a[i] &lt;= bin &amp;&amp; i &lt; j) &#123;\n            i++;\n        &#125;\n        //此时i,j都找到目标，若未互相超过对方，则交换两数\n        if (i &lt; j) &#123;\n            t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        &#125;\n        /*\n        问：\n        如果不在两个while处加上“i&lt;j”的条件，\n        i,j到底会不会穿越对方？\n        答： \n        假设现在i,j尚未碰面，j正在移动，\n        最坏的情况是，j向左移动一直找不到比bin小的数，\n        那么j的救命稻草，一定是i所指的数，这个数在上一步刚刚因为\n        自身比bin要小而被交换到这里，所以j最多移动到i所指的位置，\n        不可能穿越i；\n        但是！这时候轮到i移动了！i还没移动时，所指的数，\n        一定是比bin小的，正是因为这样它才被换过来，\n        所以i必然是至少要前进1步的，一旦这1步走出去，\n        i就会超越j，这对情侣各奔东西，再也无法回头看对方一眼，\n        到此为止，算法完蛋。\n        综上，两处while都必须加上i&lt;j的条件，确保两者不互相穿过对方。\n        */\n    &#125;\n\n    //最后，将[两针碰面位置所指的数]与bin交换\n    a[left] = a[i];\n    a[i] = bin;\n    \n    //此后，数组被分成以bin为界限的各自独立的两块，分别再对这两个序列使用quickSort即可（递归）\n    //传递给quickSort函数的是左右边界定位标，表明要处理序列的起点和终点\n    quickSort(left, i-1);\n    quickSort(i+1, right);\n    /*\n    问：如何确保递归自动退出而不陷入死循环？\n    答：这就要用到quickSort()函数刚开始加入的判断语句，\n        if(left>right)return;\n        如果排序已经完成，此时quickSort处理的对象，起点等于终点，\n        即传入参数left=right，执行完后，递归传入left不变，right减一，\n        就会造成left>right，此时让函数return即可结束递归。\n\n    */\n    return;\n&#125;\n\nint main()\n&#123;\n    scanf(\"%d\",&amp;n);\n    for (int i=1; i&lt;=n; i++) &#123;\n        scanf(\"%d\",&amp;a[i]);\n    &#125;\n\n    quickSort(1, n);\n\n    for (int i=1; i&lt;=n; i++) &#123;\n        printf(\"%d \",a[i]);\n    &#125;\n\n    return 0;\n&#125;","slug":"demo_quicksort","date":"2020-09-26T08:22:00.000Z","categories_index":"算法题解/笔记","tags_index":"算法,排序","author_index":"菲尔普斯"}]