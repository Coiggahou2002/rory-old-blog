{"title":"[Demo] 快速排序","uid":"cdcaa64e46db961619b177c66af1aa77","slug":"demo_quicksort","date":"2020-09-26T08:22:00.000Z","updated":"2020-12-08T02:16:08.000Z","comments":true,"path":"api/articles/demo_quicksort.json","keywords":null,"cover":"/img/algorithm.png","content":"<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token comment\">//对要操作的变量采用全局定义，可以避免指针的操作</span>\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">101</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>n<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> times <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">//left,right分别为左右指针</span>\n    \n    <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">,</span> bin<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//若指针错位，退出函数</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">></span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">//bin是一开始确定的基准数，也就是left指针所指的数</span>\n    bin <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    i <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span><span class=\"token comment\">//左搜索针</span>\n    j <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span><span class=\"token comment\">//右搜索针</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> bin <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            j<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//先右后左，右搜索针找不到就一直找，找到符合要求的第一个，才轮到左搜索针出发</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> bin <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">//此时i,j都找到目标，若未互相超过对方，则交换两数</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            t <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">/*\n        问：\n        如果不在两个while处加上“i&lt;j”的条件，\n        i,j到底会不会穿越对方？\n        答： \n        假设现在i,j尚未碰面，j正在移动，\n        最坏的情况是，j向左移动一直找不到比bin小的数，\n        那么j的救命稻草，一定是i所指的数，这个数在上一步刚刚因为\n        自身比bin要小而被交换到这里，所以j最多移动到i所指的位置，\n        不可能穿越i；\n        但是！这时候轮到i移动了！i还没移动时，所指的数，\n        一定是比bin小的，正是因为这样它才被换过来，\n        所以i必然是至少要前进1步的，一旦这1步走出去，\n        i就会超越j，这对情侣各奔东西，再也无法回头看对方一眼，\n        到此为止，算法完蛋。\n        综上，两处while都必须加上i&lt;j的条件，确保两者不互相穿过对方。\n        */</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">//最后，将[两针碰面位置所指的数]与bin交换</span>\n    a<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> bin<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">//此后，数组被分成以bin为界限的各自独立的两块，分别再对这两个序列使用quickSort即可（递归）</span>\n    <span class=\"token comment\">//传递给quickSort函数的是左右边界定位标，表明要处理序列的起点和终点</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/*\n    问：如何确保递归自动退出而不陷入死循环？\n    答：这就要用到quickSort()函数刚开始加入的判断语句，\n        if(left>right)return;\n        如果排序已经完成，此时quickSort处理的对象，起点等于终点，\n        即传入参数left=right，执行完后，递归传入left不变，right减一，\n        就会造成left>right，此时让函数return即可结束递归。\n\n    */</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d \"</span><span class=\"token punctuation\">,</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>","text":"#include &lt;stdio.h> //对要操作的变量采用全局定义，可以避免指针的操作 int a[101],n; int times = 0; void quickSort(int left, int right) &#123; //left,right分别为左右指针 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"算法题解/笔记","slug":"算法题解-笔记","count":26,"path":"api/categories/算法题解-笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":21,"path":"api/tags/算法.json"},{"name":"排序","slug":"排序","count":4,"path":"api/tags/排序.json"}],"toc":"","author":{"name":"菲尔普斯","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/72149771?v=4","link":"/","description":"你曾经灼热的眼眶，是人生中少数的笨拙又可贵的时刻","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"[Demo] 归并排序","uid":"1abc49c5902eda16bbaa0acd742568ec","slug":"demo_mergesort","date":"2020-10-02T16:00:00.000Z","updated":"2020-12-18T09:20:20.000Z","comments":true,"path":"api/articles/demo_mergesort.json","keywords":null,"cover":"/img/algorithm.png","text":"#include &lt;stdio.h> #include &lt;stdlib.h> void Merge (int arr[], int L, int M, int R) &#123; /*此处数组的头指针和尾指针需要参数给出，便于获取数组长度*/ int LEFT_SIZ...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"算法题解/笔记","slug":"算法题解-笔记","count":26,"path":"api/categories/算法题解-笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":21,"path":"api/tags/算法.json"},{"name":"排序","slug":"排序","count":4,"path":"api/tags/排序.json"}],"author":{"name":"菲尔普斯","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/72149771?v=4","link":"/","description":"你曾经灼热的眼眶，是人生中少数的笨拙又可贵的时刻","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}