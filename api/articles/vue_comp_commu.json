{"title":"Vue 的组件通信总结","uid":"9eb5ca10bff6be7f75941f8be934e3c2","slug":"vue_comp_commu","date":"2021-11-09T06:15:00.000Z","updated":"2022-08-01T02:30:48.113Z","comments":true,"path":"api/articles/vue_comp_commu.json","keywords":null,"cover":[],"content":"<p><img src=\"https://cjpark-1304138896.cos.ap-guangzhou.myqcloud.com/note_img/20211105171412.png\" alt=\"\" /></p>\n<span id=\"more\"></span>\n<h2 id=\"常用方案\"><a class=\"markdownIt-Anchor\" href=\"#常用方案\"></a> 常用方案</h2>\n<ul>\n<li>通过 <code>props</code> 传递</li>\n<li><code>$emit</code> 触发自定义事件</li>\n<li>使用 <code>$ref</code></li>\n<li>使用事件总线</li>\n<li><code>$parent</code> 或 <code>$root</code></li>\n<li><code>attrs</code> 与 <code>listeners</code></li>\n<li><code>provide</code> 与 <code>inject</code></li>\n<li>通过 Vuex</li>\n</ul>\n<h2 id=\"具体场景\"><a class=\"markdownIt-Anchor\" href=\"#具体场景\"></a> 具体场景</h2>\n<h3 id=\"父传子\"><a class=\"markdownIt-Anchor\" href=\"#父传子\"></a> 父传子</h3>\n<p><strong>父组件通过给 <code>props</code> 给子组件传值.</strong></p>\n<p>通过一个简单例子来说明，场景如下：</p>\n<p>父组件是一个显示文章的页面视图，子组件叫 <code>MarkdownContent</code>，能将 Markdown 字符串渲染成 HTML 字符串，每次用户打开一篇文章，父组件都需要向服务端发请求，拿到 Markdown 字符串格式的文章，然后交给子组件渲染，所以产生了向子组件传值的需求.</p>\n<p>父组件中需要通过 <code>v-bind:子组件属性名</code> 传入数据，如下</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;!--父组件中通过:attribute形式给子组件传值--&gt;\n\n&lt;template&gt;\n  &lt;MarkdownContent :markdownContent&#x3D;&quot;comment.content&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport MarkdownContent from &quot;.&#x2F;MarkdownContent&quot;;\nexport default &#123;\n  components: &#123;\n    MarkdownContent  \n  &#125;,\n  data() &#123;\n    return &#123;\n      comment: &#123;\n        author: &#39;&#39;,\n        content: &#39;&#39;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>子组件中需要设置相应的 <code>props</code>，并设置好数据绑定</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;mavon-editor v-model&#x3D;&quot;markdownContent&quot;&gt;\n  &lt;&#x2F;mavon-editor&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  props: &#123;\n    markdownContent: &#123;\n      type: String,\n        default: &#39;&#39;,\n        required: true\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"子传父\"><a class=\"markdownIt-Anchor\" href=\"#子传父\"></a> 子传父</h3>\n<p>子组件通过 <code>this.$emit('向外暴露事件名'，携带数据)</code> 来向父组件传值.</p>\n<p>举例说明，场景如下：</p>\n<p>父组件是一个评论区页面，子组件是一个简单的 Markdown 文本编辑框加上一个“提交”按钮，现在我们希望，当用户输入了评论并点击了子组件里的“提交”按钮时，父组件能够收到通知并拿到这份评论文本，通过 HTTP 请求发给服务端.</p>\n<p>我们可以这么做：</p>\n<p>给子组件的提交按钮绑定一个处理事件，在该事件中 <code>emit</code></p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;mavon-editor v-model&#x3D;&quot;content&quot;&#x2F;&gt;\n  &lt;v-btn @click&#x3D;&quot;handleCommit&quot;&gt;\n    发表评论\n  &lt;&#x2F;v-btn&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      content: &#39;&#39;,\n    &#125;\n  &#125;\n  methods: &#123;\n    handleCommit() &#123;\n      this.$emit(&#39;onCommit&#39;, this.content)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>同时，在父组件中通过 <code>v-on:子组件emit的函数名=&quot;父组件中某个处理函数(接收emit的数据参数)&quot;</code>来感知</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;Comments @onCommit&#x3D;&quot;commitToServer&quot;&#x2F;&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  methods: &#123;\n    commitToServer(contentOfComment) &#123;\n      HttpService(&#123;\n        url: &#39;...&#39;,\n        method: &#39;post&#39;,\n        data: &#123;\n          comment: contentOfComment\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"父组件从子组件取数据\"><a class=\"markdownIt-Anchor\" href=\"#父组件从子组件取数据\"></a> 父组件从子组件取数据</h3>\n<p>如果并不需要“子组件触发某事件时父组件收到通知”的效果，而仅仅只需要让父组件取出子组件的数据，可以通过 <code>this.$refs</code> 来实现.</p>\n<p>例如，子组件是一个文本框，父组件希望点击按钮时，能够直接取出子组件文本框的内容</p>\n<p>如下，子组件做自己就好，不需要做任何特殊的准备</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;!--子组件--&gt;\n&lt;template&gt;\n  &lt;v-text-field v-model&#x3D;&quot;text&quot;&gt;&lt;&#x2F;v-text-field&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  name: &#39;ChildComponent&#39;,\n  data() &#123;\n    return &#123;\n      text: &#39;&#39;\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>父组件中，需要给子组件加一个 <code>ref</code> 属性，也就是引用名，加上就可以取数据了</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;!--父组件--&gt;\n&lt;template&gt;\n  &lt;ChildComponent ref&#x3D;&quot;myChild&quot;&#x2F;&gt;\n  &lt;v-btn @click&#x3D;&quot;getText&quot;&gt;&lt;&#x2F;v-btn&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport ChildComponent from &#39;...&#39;\nexport default &#123;\n  components: &#123;\n    ChildComponent\n  &#125;,\n  methods: &#123;\n    getText() &#123;\n      console.log(this.$refs.myChild.text);\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"兄弟组件之间传\"><a class=\"markdownIt-Anchor\" href=\"#兄弟组件之间传\"></a> 兄弟组件之间传</h3>\n<h4 id=\"eventbus\"><a class=\"markdownIt-Anchor\" href=\"#eventbus\"></a> EventBus</h4>\n<p>使用事件总线，即创建一个空的 Vue 实例来充当 <code>EventBus</code>，具体例子待补充</p>\n<h4 id=\"parent-或-root\"><a class=\"markdownIt-Anchor\" href=\"#parent-或-root\"></a> $parent 或 $root</h4>\n<p>即通过共同祖先来通信</p>\n<p>兄弟 A 使用 <code>this.$parent.emit('haha', someData)</code></p>\n<p>兄弟 B 使用 <code>this.$parent.on('haha', callbackFunction)</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>$parent 取的是上一级组件，$root 取的是根组件</p></blockquote>\n<h3 id=\"祖先给子孙传\"><a class=\"markdownIt-Anchor\" href=\"#祖先给子孙传\"></a> 祖先给子孙传</h3>\n<h4 id=\"使用-provide-与-inject\"><a class=\"markdownIt-Anchor\" href=\"#使用-provide-与-inject\"></a> 使用 provide 与 inject</h4>\n<p>祖先组件中提供 <code>provide()</code>，返回一个数据对象，子孙组件使用 <code>inject</code> 来接受 ，具体如下</p>\n<p>祖先组件用 <code>provide</code> 提供一个返回对象的函数</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">export default &#123;\n  data() &#123;\n    return &#123;\n      myData: &#123;\n        name: &#39;abc&#39;,\n        sex: &#39;boy&#39;\n      &#125;\n    &#125;\n  &#125;,\n  provide() &#123;\n    return &#123;\n      providedData: this.myData\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>子孙组件用 <code>inject</code> 接收</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;template&gt;\n  &lt;div&gt;&#123;&#123; providedData.name &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  inject: [&quot;providedData&quot;]\n&#125;\n&lt;&#x2F;script&gt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>需要特别注意的是，通过 provide 与 inject 传递的数据并不是响应式的</strong>，也就是说，祖先组件传值给子孙组件之后，如果祖先组件中那个值改变了，子孙组件无法被通知，也无法响应变化.</p>\n<p><strong>但其实，如果传的是一个对象，那祖先组件和子孙组件的数据依然是同步的</strong>，这是因为传对象是引用传值，所以祖先和孙子读写的是同一个地址上的东西.</p>\n<p>而如果传的是基本数据类型，那就真没法响应式了.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这种方式的缺点非常明显，即便传的是对象，数据能够同步，但假若一个祖先组件将同一份对象传给了很多个子孙，那么任何一个子孙对数据的修改都将影响全局.</p></blockquote>\n<h4 id=\"使用-attrs-与-listeners\"><a class=\"markdownIt-Anchor\" href=\"#使用-attrs-与-listeners\"></a> 使用 $attrs 与 $listeners</h4>\n<p>待补充</p>\n","text":" 常用方案 通过 props 传递 $emit 触发自定义事件 使用 $ref 使用事件总线 $parent 或 $root attrs 与 listeners provide 与 inject 通过 Vuex 具体场景 父传子 父组件通过给 props 给子组件传值. 通过一个...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"项目经验","slug":"项目经验","count":2,"path":"api/categories/项目经验.json"}],"tags":[{"name":"前端开发","slug":"前端开发","count":3,"path":"api/tags/前端开发.json"},{"name":"经验","slug":"经验","count":2,"path":"api/tags/经验.json"},{"name":"随笔","slug":"随笔","count":2,"path":"api/tags/随笔.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%A1%88\"><span class=\"toc-text\"> 常用方案</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\"> 具体场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E4%BC%A0%E5%AD%90\"><span class=\"toc-text\"> 父传子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%90%E4%BC%A0%E7%88%B6\"><span class=\"toc-text\"> 子传父</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BB%8E%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8F%96%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\"> 父组件从子组件取数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0\"><span class=\"toc-text\"> 兄弟组件之间传</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#eventbus\"><span class=\"toc-text\"> EventBus</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#parent-%E6%88%96-root\"><span class=\"toc-text\"> $parent 或 $root</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A5%96%E5%85%88%E7%BB%99%E5%AD%90%E5%AD%99%E4%BC%A0\"><span class=\"toc-text\"> 祖先给子孙传</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-provide-%E4%B8%8E-inject\"><span class=\"toc-text\"> 使用 provide 与 inject</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-attrs-%E4%B8%8E-listeners\"><span class=\"toc-text\"> 使用 $attrs 与 $listeners</span></a></li></ol></li></ol></li></ol>","author":{"name":"菲尔普斯","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/72149771?v=4","link":"/","description":"你曾经灼热的眼眶，是人生中少数的笨拙又可贵的时刻","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"npm cheat sheet","uid":"17c4a4a2974859ec97857b45c9cf78f2","slug":"npm_cheat_sheet","date":"2022-01-07T12:45:00.000Z","updated":"2022-08-01T02:35:06.896Z","comments":true,"path":"api/articles/npm_cheat_sheet.json","keywords":null,"cover":[],"text":"全局更新 npm：npm i npm -g 强制清理缓存(高版本禁用)：npm cache clean --force 安装 cnpm：npm install -g cnpm --registry=https://registry.npm.taobao.org 命令 版本 npm...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"前端开发","slug":"前端开发","count":1,"path":"api/categories/前端开发.json"}],"tags":[{"name":"前端开发","slug":"前端开发","count":3,"path":"api/tags/前端开发.json"},{"name":"npm","slug":"npm","count":1,"path":"api/tags/npm.json"}],"author":{"name":"菲尔普斯","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/72149771?v=4","link":"/","description":"你曾经灼热的眼眶，是人生中少数的笨拙又可贵的时刻","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"刷题笔记 | 链表","uid":"6db5ceff1cffdec592e2386e6fd66245","slug":"linklist_solutions","date":"2021-03-31T13:19:00.000Z","updated":"2021-03-31T13:26:10.000Z","comments":true,"path":"api/articles/linklist_solutions.json","keywords":null,"cover":"/img/leetcode.png","text":"本文用于记录笔者刷链表类型题的笔记和题解. 力扣 206. 反转链表 https://leetcode-cn.com/problems/reverse-linked-list/ 三指针法 struct ListNode* reverseList(struct ListNode* ...","link":"","photos":[],"count_time":{"symbolsCount":"7.9k","symbolsTime":"7 mins."},"categories":[{"name":"算法题解/笔记","slug":"算法题解-笔记","count":26,"path":"api/categories/算法题解-笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":21,"path":"api/tags/算法.json"},{"name":"题解","slug":"题解","count":16,"path":"api/tags/题解.json"},{"name":"链表","slug":"链表","count":4,"path":"api/tags/链表.json"}],"author":{"name":"菲尔普斯","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/72149771?v=4","link":"/","description":"你曾经灼热的眼眶，是人生中少数的笨拙又可贵的时刻","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}